\section{mlpack\+:\+:data Namespace Reference}
\label{namespacemlpack_1_1data}\index{mlpack\+::data@{mlpack\+::data}}


Functions to load and save matrices and models.  


\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \textbf{ Bag\+Of\+Words\+Encoding\+Policy}
\begin{DoxyCompactList}\small\item\em Definition of the \doxyref{Bag\+Of\+Words\+Encoding\+Policy}{p.}{classmlpack_1_1data_1_1BagOfWordsEncodingPolicy} class. \end{DoxyCompactList}\item 
class \textbf{ Char\+Extract}
\begin{DoxyCompactList}\small\item\em The class is used to split a string into characters. \end{DoxyCompactList}\item 
class \textbf{ Custom\+Imputation}
\begin{DoxyCompactList}\small\item\em A simple custom imputation class. \end{DoxyCompactList}\item 
class \textbf{ Dataset\+Mapper}
\begin{DoxyCompactList}\small\item\em Auxiliary information for a dataset, including mappings to/from strings (or other types) and the datatype of each dimension. \end{DoxyCompactList}\item 
class \textbf{ Dictionary\+Encoding\+Policy}
\begin{DoxyCompactList}\small\item\em Dicitonary\+Enocding\+Policy is used as a helper class for \doxyref{String\+Encoding}{p.}{classmlpack_1_1data_1_1StringEncoding}. \end{DoxyCompactList}\item 
struct \textbf{ Has\+Serialize}
\item 
struct \textbf{ Has\+Serialize\+Function}
\item 
class \textbf{ Image\+Info}
\begin{DoxyCompactList}\small\item\em Implements meta-\/data of images required by \doxyref{data\+::\+Load}{p.}{namespacemlpack_1_1data_abbff2a667bf247e00b1fc09b7ca5f831} and \doxyref{data\+::\+Save}{p.}{namespacemlpack_1_1data_accd1605a1d160c09ee75c93a587dc313} for loading and saving images into arma\+::\+Mat. \end{DoxyCompactList}\item 
class \textbf{ Imputer}
\begin{DoxyCompactList}\small\item\em Given a dataset of a particular datatype, replace user-\/specified missing value with a variable dependent on the Strategy\+Type and Mapper\+Type. \end{DoxyCompactList}\item 
class \textbf{ Increment\+Policy}
\begin{DoxyCompactList}\small\item\em \doxyref{Increment\+Policy}{p.}{classmlpack_1_1data_1_1IncrementPolicy} is used as a helper class for \doxyref{Dataset\+Mapper}{p.}{classmlpack_1_1data_1_1DatasetMapper}. \end{DoxyCompactList}\item 
class \textbf{ Listwise\+Deletion}
\begin{DoxyCompactList}\small\item\em A complete-\/case analysis to remove the values containing mapped\+Value. \end{DoxyCompactList}\item 
class \textbf{ Load\+C\+SV}
\begin{DoxyCompactList}\small\item\em Load the csv file.\+This class use boost\+::spirit to implement the parser, please refer to following link {\tt http\+://theboostcpplibraries.\+com/boost.\+spirit} for quick review. \end{DoxyCompactList}\item 
class \textbf{ Max\+Abs\+Scaler}
\begin{DoxyCompactList}\small\item\em A simple Max\+Abs Scaler class. \end{DoxyCompactList}\item 
class \textbf{ Mean\+Imputation}
\begin{DoxyCompactList}\small\item\em A simple mean imputation class. \end{DoxyCompactList}\item 
class \textbf{ Mean\+Normalization}
\begin{DoxyCompactList}\small\item\em A simple Mean Normalization class. \end{DoxyCompactList}\item 
class \textbf{ Median\+Imputation}
\begin{DoxyCompactList}\small\item\em This is a class implementation of simple median imputation. \end{DoxyCompactList}\item 
class \textbf{ Min\+Max\+Scaler}
\begin{DoxyCompactList}\small\item\em A simple Min\+Max Scaler class. \end{DoxyCompactList}\item 
class \textbf{ Missing\+Policy}
\begin{DoxyCompactList}\small\item\em \doxyref{Missing\+Policy}{p.}{classmlpack_1_1data_1_1MissingPolicy} is used as a helper class for \doxyref{Dataset\+Mapper}{p.}{classmlpack_1_1data_1_1DatasetMapper}. \end{DoxyCompactList}\item 
class \textbf{ P\+C\+A\+Whitening}
\begin{DoxyCompactList}\small\item\em A simple \doxyref{P\+C\+A\+Whitening}{p.}{classmlpack_1_1data_1_1PCAWhitening} class. \end{DoxyCompactList}\item 
class \textbf{ Scaling\+Model}
\begin{DoxyCompactList}\small\item\em The model to save to disk. \end{DoxyCompactList}\item 
class \textbf{ Split\+By\+Any\+Of}
\begin{DoxyCompactList}\small\item\em The \doxyref{Split\+By\+Any\+Of}{p.}{classmlpack_1_1data_1_1SplitByAnyOf} class tokenizes a string using a set of delimiters. \end{DoxyCompactList}\item 
class \textbf{ Standard\+Scaler}
\begin{DoxyCompactList}\small\item\em A simple Standard Scaler class. \end{DoxyCompactList}\item 
class \textbf{ String\+Encoding}
\begin{DoxyCompactList}\small\item\em The class translates a set of strings into numbers using various encoding algorithms. \end{DoxyCompactList}\item 
class \textbf{ String\+Encoding\+Dictionary}
\begin{DoxyCompactList}\small\item\em This class provides a dictionary interface for the purpose of string encoding. \end{DoxyCompactList}\item 
class \textbf{ String\+Encoding\+Dictionary$<$ boost\+::string\+\_\+view $>$}
\item 
class \textbf{ String\+Encoding\+Dictionary$<$ int $>$}
\item 
struct \textbf{ String\+Encoding\+Policy\+Traits}
\begin{DoxyCompactList}\small\item\em This is a template struct that provides some information about various encoding policies. \end{DoxyCompactList}\item 
struct \textbf{ String\+Encoding\+Policy\+Traits$<$ Dictionary\+Encoding\+Policy $>$}
\begin{DoxyCompactList}\small\item\em The specialization provides some information about the dictionary encoding policy. \end{DoxyCompactList}\item 
class \textbf{ Tf\+Idf\+Encoding\+Policy}
\begin{DoxyCompactList}\small\item\em Definition of the \doxyref{Tf\+Idf\+Encoding\+Policy}{p.}{classmlpack_1_1data_1_1TfIdfEncodingPolicy} class. \end{DoxyCompactList}\item 
class \textbf{ Z\+C\+A\+Whitening}
\begin{DoxyCompactList}\small\item\em A simple \doxyref{Z\+C\+A\+Whitening}{p.}{classmlpack_1_1data_1_1ZCAWhitening} class. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename Token\+Type $>$ }\\using \textbf{ Bag\+Of\+Words\+Encoding} = \textbf{ String\+Encoding}$<$ \textbf{ Bag\+Of\+Words\+Encoding\+Policy}, \textbf{ String\+Encoding\+Dictionary}$<$ Token\+Type $>$ $>$
\begin{DoxyCompactList}\small\item\em A convenient alias for the \doxyref{String\+Encoding}{p.}{classmlpack_1_1data_1_1StringEncoding} class with \doxyref{Bag\+Of\+Words\+Encoding\+Policy}{p.}{classmlpack_1_1data_1_1BagOfWordsEncodingPolicy} and the default dictionary for the given token type. \end{DoxyCompactList}\item 
using \textbf{ Dataset\+Info} = \textbf{ Dataset\+Mapper}$<$ \textbf{ data\+::\+Increment\+Policy} $>$
\item 
{\footnotesize template$<$typename Token\+Type $>$ }\\using \textbf{ Dictionary\+Encoding} = \textbf{ String\+Encoding}$<$ \textbf{ Dictionary\+Encoding\+Policy}, \textbf{ String\+Encoding\+Dictionary}$<$ Token\+Type $>$ $>$
\begin{DoxyCompactList}\small\item\em A convenient alias for the \doxyref{String\+Encoding}{p.}{classmlpack_1_1data_1_1StringEncoding} class with \doxyref{Dictionary\+Encoding\+Policy}{p.}{classmlpack_1_1data_1_1DictionaryEncodingPolicy} and the default dictionary for the given token type. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Token\+Type $>$ }\\using \textbf{ Tf\+Idf\+Encoding} = \textbf{ String\+Encoding}$<$ \textbf{ Tf\+Idf\+Encoding\+Policy}, \textbf{ String\+Encoding\+Dictionary}$<$ Token\+Type $>$ $>$
\begin{DoxyCompactList}\small\item\em A convenient alias for the \doxyref{String\+Encoding}{p.}{classmlpack_1_1data_1_1StringEncoding} class with \doxyref{Tf\+Idf\+Encoding\+Policy}{p.}{classmlpack_1_1data_1_1TfIdfEncodingPolicy} and the default dictionary for the given token type. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
enum \textbf{ Datatype} \+: bool \{ \newline
\textbf{ numeric} = 0, 
\newline
\textbf{ categorical} = 1
 \}\begin{DoxyCompactList}\small\item\em The Datatype enum specifies the types of data mlpack algorithms can use. \end{DoxyCompactList}
\item 
enum \textbf{ format} \{ \newline
\textbf{ autodetect}, 
\newline
\textbf{ json}, 
\newline
\textbf{ xml}, 
\newline
\textbf{ binary}
 \}\begin{DoxyCompactList}\small\item\em Define the formats we can read through cereal. \end{DoxyCompactList}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
arma\+::file\+\_\+type \textbf{ Auto\+Detect} (std\+::fstream \&stream, const std\+::string \&filename)
\begin{DoxyCompactList}\small\item\em Attempt to auto-\/detect the type of a file given its extension, and by inspecting the parts of the file to disambiguate between types when necessary. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void \textbf{ Binarize} (const arma\+::\+Mat$<$ T $>$ \&input, arma\+::\+Mat$<$ T $>$ \&output, const double threshold)
\begin{DoxyCompactList}\small\item\em Given an input dataset and threshold, set values greater than threshold to 1 and values less than or equal to the threshold to 0. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void \textbf{ Binarize} (const arma\+::\+Mat$<$ T $>$ \&input, arma\+::\+Mat$<$ T $>$ \&output, const double threshold, const size\+\_\+t dimension)
\begin{DoxyCompactList}\small\item\em Given an input dataset and threshold, set values greater than threshold to 1 and values less than or equal to the threshold to 0. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename eT $>$ }\\void \textbf{ Confusion\+Matrix} (const arma\+::\+Row$<$ size\+\_\+t $>$ predictors, const arma\+::\+Row$<$ size\+\_\+t $>$ responses, arma\+::\+Mat$<$ eT $>$ \&output, const size\+\_\+t num\+Classes)
\begin{DoxyCompactList}\small\item\em A confusion matrix is a summary of prediction results on a classification problem. \end{DoxyCompactList}\item 
arma\+::file\+\_\+type \textbf{ Detect\+From\+Extension} (const std\+::string \&filename)
\begin{DoxyCompactList}\small\item\em Return the type based only on the extension. \end{DoxyCompactList}\item 
std\+::string \textbf{ Extension} (const std\+::string \&filename)
\item 
std\+::string \textbf{ Get\+String\+Type} (const arma\+::file\+\_\+type \&type)
\begin{DoxyCompactList}\small\item\em Given a file type, return a logical name corresponding to that file type. \end{DoxyCompactList}\item 
arma\+::file\+\_\+type \textbf{ Guess\+File\+Type} (std\+::istream \&f)
\begin{DoxyCompactList}\small\item\em Given an istream, attempt to guess the file type. \end{DoxyCompactList}\item 
\textbf{ H\+A\+S\+\_\+\+E\+X\+A\+C\+T\+\_\+\+M\+E\+T\+H\+O\+D\+\_\+\+F\+O\+RM} (serialize, Has\+Serialize\+Check)
\item 
bool \textbf{ Image\+Format\+Supported} (const std\+::string \&file\+Name, const bool save=false)
\begin{DoxyCompactList}\small\item\em Checks if the given image filename is supported. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\bool \textbf{ Is\+Na\+N\+Inf} (T \&val, const std\+::string \&token)
\begin{DoxyCompactList}\small\item\em See if the token is a NaN or an Inf, and if so, set the value accordingly and return a boolean representing whether or not it is. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename eT $>$ }\\bool \textbf{ Load} (const std\+::string \&filename, arma\+::\+Mat$<$ eT $>$ \&matrix, const bool fatal=false, const bool transpose=true, const arma\+::file\+\_\+type input\+Load\+Type=arma\+::auto\+\_\+detect)
\begin{DoxyCompactList}\small\item\em Loads a matrix from file, guessing the filetype from the extension. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename eT $>$ }\\bool \textbf{ Load} (const std\+::string \&filename, arma\+::\+Sp\+Mat$<$ eT $>$ \&matrix, const bool fatal=false, const bool transpose=true)
\begin{DoxyCompactList}\small\item\em Loads a sparse matrix from file, using arma\+::coord\+\_\+ascii format. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename eT $>$ }\\bool \textbf{ Load} (const std\+::string \&filename, arma\+::\+Col$<$ eT $>$ \&vec, const bool fatal=false)
\begin{DoxyCompactList}\small\item\em Don\textquotesingle{}t document these with doxygen; these declarations aren\textquotesingle{}t helpful to users. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename eT $>$ }\\bool \textbf{ Load} (const std\+::string \&filename, arma\+::\+Row$<$ eT $>$ \&rowvec, const bool fatal=false)
\begin{DoxyCompactList}\small\item\em Load a row vector from a file, guessing the filetype from the extension. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename eT , typename Policy\+Type $>$ }\\bool \textbf{ Load} (const std\+::string \&filename, arma\+::\+Mat$<$ eT $>$ \&matrix, \textbf{ Dataset\+Mapper}$<$ Policy\+Type $>$ \&info, const bool fatal=false, const bool transpose=true)
\begin{DoxyCompactList}\small\item\em Loads a matrix from a file, guessing the filetype from the extension and mapping categorical features with a \doxyref{Dataset\+Mapper}{p.}{classmlpack_1_1data_1_1DatasetMapper} object. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\bool \textbf{ Load} (const std\+::string \&filename, const std\+::string \&name, T \&t, const bool fatal=false, \textbf{ format} f=format\+::autodetect)
\begin{DoxyCompactList}\small\item\em Don\textquotesingle{}t document these with doxygen; they aren\textquotesingle{}t helpful for users to know about. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename eT $>$ }\\bool \textbf{ Load} (const std\+::string \&filename, arma\+::\+Mat$<$ eT $>$ \&matrix, \textbf{ Image\+Info} \&info, const bool fatal=false)
\begin{DoxyCompactList}\small\item\em Image load/save interfaces. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename eT $>$ }\\bool \textbf{ Load} (const std\+::vector$<$ std\+::string $>$ \&files, arma\+::\+Mat$<$ eT $>$ \&matrix, \textbf{ Image\+Info} \&info, const bool fatal=false)
\begin{DoxyCompactList}\small\item\em Load the image file into the given matrix. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename eT $>$ }\\void \textbf{ Load\+A\+R\+FF} (const std\+::string \&filename, arma\+::\+Mat$<$ eT $>$ \&matrix)
\begin{DoxyCompactList}\small\item\em A utility function to load an A\+R\+FF dataset as numeric features (that is, as an Armadillo matrix without any modification). \end{DoxyCompactList}\item 
{\footnotesize template$<$typename eT , typename Policy\+Type $>$ }\\void \textbf{ Load\+A\+R\+FF} (const std\+::string \&filename, arma\+::\+Mat$<$ eT $>$ \&matrix, \textbf{ Dataset\+Mapper}$<$ Policy\+Type $>$ \&info)
\begin{DoxyCompactList}\small\item\em A utility function to load an A\+R\+FF dataset as numeric and categorical features, using the Dataset\+Info structure for mapping. \end{DoxyCompactList}\item 
bool \textbf{ Load\+Image} (const std\+::string \&filename, arma\+::\+Mat$<$ unsigned char $>$ \&matrix, \textbf{ Image\+Info} \&info, const bool fatal=false)
\item 
{\footnotesize template$<$typename eT , typename Row\+Type $>$ }\\void \textbf{ Normalize\+Labels} (const Row\+Type \&labels\+In, arma\+::\+Row$<$ size\+\_\+t $>$ \&labels, arma\+::\+Col$<$ eT $>$ \&mapping)
\begin{DoxyCompactList}\small\item\em Given a set of labels of a particular datatype, convert them to unsigned labels in the range [0, n) where n is the number of different labels. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Row\+Type , typename Mat\+Type $>$ }\\void \textbf{ One\+Hot\+Encoding} (const Row\+Type \&labels\+In, Mat\+Type \&output)
\begin{DoxyCompactList}\small\item\em Given a set of labels of a particular datatype, convert them to binary vector. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename eT $>$ }\\void \textbf{ One\+Hot\+Encoding} (const arma\+::\+Mat$<$ eT $>$ \&input, const arma\+::\+Col$<$ size\+\_\+t $>$ \&indices, arma\+::\+Mat$<$ eT $>$ \&output)
\begin{DoxyCompactList}\small\item\em Overloaded function for the above function, which takes a matrix as input and also a vector of indices to encode and outputs a matrix. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename eT $>$ }\\void \textbf{ One\+Hot\+Encoding} (const arma\+::\+Mat$<$ eT $>$ \&input, arma\+::\+Mat$<$ eT $>$ \&output, const \textbf{ data\+::\+Dataset\+Info} \&dataset\+Info)
\begin{DoxyCompactList}\small\item\em Overloaded function for the above function, which takes a matrix as input and also a Dataset\+Info object and outputs a matrix. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename eT $>$ }\\void \textbf{ Revert\+Labels} (const arma\+::\+Row$<$ size\+\_\+t $>$ \&labels, const arma\+::\+Col$<$ eT $>$ \&mapping, arma\+::\+Row$<$ eT $>$ \&labels\+Out)
\begin{DoxyCompactList}\small\item\em Given a set of labels that have been mapped to the range [0, n), map them back to the original labels given by the \textquotesingle{}mapping\textquotesingle{} vector. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename eT $>$ }\\bool \textbf{ Save} (const std\+::string \&filename, const arma\+::\+Mat$<$ eT $>$ \&matrix, const bool fatal=false, bool transpose=true, arma\+::file\+\_\+type input\+Save\+Type=arma\+::auto\+\_\+detect)
\begin{DoxyCompactList}\small\item\em Saves a matrix to file, guessing the filetype from the extension. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename eT $>$ }\\bool \textbf{ Save} (const std\+::string \&filename, const arma\+::\+Sp\+Mat$<$ eT $>$ \&matrix, const bool fatal=false, bool transpose=true)
\begin{DoxyCompactList}\small\item\em Saves a sparse matrix to file, guessing the filetype from the extension. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\bool \textbf{ Save} (const std\+::string \&filename, const std\+::string \&name, T \&t, const bool fatal=false, \textbf{ format} f=format\+::autodetect)
\begin{DoxyCompactList}\small\item\em Saves a model to file, guessing the filetype from the extension, or, optionally, saving the specified format. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename eT $>$ }\\bool \textbf{ Save} (const std\+::string \&filename, arma\+::\+Mat$<$ eT $>$ \&matrix, \textbf{ Image\+Info} \&info, const bool fatal=false)
\begin{DoxyCompactList}\small\item\em Save the image file from the given matrix. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename eT $>$ }\\bool \textbf{ Save} (const std\+::vector$<$ std\+::string $>$ \&files, arma\+::\+Mat$<$ eT $>$ \&matrix, \textbf{ Image\+Info} \&info, const bool fatal=false)
\begin{DoxyCompactList}\small\item\em Save the image file from the given matrix. \end{DoxyCompactList}\item 
bool \textbf{ Save\+Image} (const std\+::string \&filename, arma\+::\+Mat$<$ unsigned char $>$ \&image, \textbf{ Image\+Info} \&info, const bool fatal=false)
\begin{DoxyCompactList}\small\item\em Helper function to save files. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , typename Labels\+Type , typename  = std\+::enable\+\_\+if\+\_\+t$<$arma\+::is\+\_\+arma\+\_\+type$<$\+Labels\+Type$>$\+::value$>$$>$ }\\void \textbf{ Split} (const arma\+::\+Mat$<$ T $>$ \&input, const Labels\+Type \&input\+Label, arma\+::\+Mat$<$ T $>$ \&train\+Data, arma\+::\+Mat$<$ T $>$ \&test\+Data, Labels\+Type \&train\+Label, Labels\+Type \&test\+Label, const double test\+Ratio, const bool shuffle\+Data=true)
\begin{DoxyCompactList}\small\item\em Given an input dataset and labels, split into a training set and test set. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void \textbf{ Split} (const arma\+::\+Mat$<$ T $>$ \&input, arma\+::\+Mat$<$ T $>$ \&train\+Data, arma\+::\+Mat$<$ T $>$ \&test\+Data, const double test\+Ratio, const bool shuffle\+Data=true)
\begin{DoxyCompactList}\small\item\em Given an input dataset, split into a training set and test set. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , typename Labels\+Type , typename  = std\+::enable\+\_\+if\+\_\+t$<$arma\+::is\+\_\+arma\+\_\+type$<$\+Labels\+Type$>$\+::value$>$$>$ }\\std\+::tuple$<$ arma\+::\+Mat$<$ T $>$, arma\+::\+Mat$<$ T $>$, Labels\+Type, Labels\+Type $>$ \textbf{ Split} (const arma\+::\+Mat$<$ T $>$ \&input, const Labels\+Type \&input\+Label, const double test\+Ratio, const bool shuffle\+Data=true, const bool stratify\+Data=false)
\begin{DoxyCompactList}\small\item\em Given an input dataset and labels, split into a training set and test set. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\std\+::tuple$<$ arma\+::\+Mat$<$ T $>$, arma\+::\+Mat$<$ T $>$ $>$ \textbf{ Split} (const arma\+::\+Mat$<$ T $>$ \&input, const double test\+Ratio, const bool shuffle\+Data=true)
\begin{DoxyCompactList}\small\item\em Given an input dataset, split into a training set and test set. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Field\+Type , typename T , typename  = std\+::enable\+\_\+if\+\_\+t$<$              arma\+::is\+\_\+\+Col$<$typename Field\+Type\+::object\+\_\+type$>$\+::value $\vert$$\vert$              arma\+::is\+\_\+\+Mat\+\_\+only$<$typename Field\+Type\+::object\+\_\+type$>$\+::value$>$$>$ }\\void \textbf{ Split} (const Field\+Type \&input, const arma\+::field$<$ T $>$ \&input\+Label, Field\+Type \&train\+Data, arma\+::field$<$ T $>$ \&train\+Label, Field\+Type \&test\+Data, arma\+::field$<$ T $>$ \&test\+Label, const double test\+Ratio, const bool shuffle\+Data=true)
\begin{DoxyCompactList}\small\item\em Given an input dataset and labels, split into a training set and test set. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Field\+Type , class  = std\+::enable\+\_\+if\+\_\+t$<$              arma\+::is\+\_\+\+Col$<$typename Field\+Type\+::object\+\_\+type$>$\+::value $\vert$$\vert$              arma\+::is\+\_\+\+Mat\+\_\+only$<$typename Field\+Type\+::object\+\_\+type$>$\+::value$>$$>$ }\\void \textbf{ Split} (const Field\+Type \&input, Field\+Type \&train\+Data, Field\+Type \&test\+Data, const double test\+Ratio, const bool shuffle\+Data=true)
\begin{DoxyCompactList}\small\item\em Given an input dataset, split into a training set and test set. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Field\+Type , typename T , class  = std\+::enable\+\_\+if\+\_\+t$<$              arma\+::is\+\_\+\+Col$<$typename Field\+Type\+::object\+\_\+type$>$\+::value $\vert$$\vert$              arma\+::is\+\_\+\+Mat\+\_\+only$<$typename Field\+Type\+::object\+\_\+type$>$\+::value$>$$>$ }\\std\+::tuple$<$ Field\+Type, Field\+Type, arma\+::field$<$ T $>$, arma\+::field$<$ T $>$ $>$ \textbf{ Split} (const Field\+Type \&input, const arma\+::field$<$ T $>$ \&input\+Label, const double test\+Ratio, const bool shuffle\+Data=true)
\begin{DoxyCompactList}\small\item\em Given an input dataset and labels, split into a training set and test set. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Field\+Type , class  = std\+::enable\+\_\+if\+\_\+t$<$              arma\+::is\+\_\+\+Col$<$typename Field\+Type\+::object\+\_\+type$>$\+::value $\vert$$\vert$              arma\+::is\+\_\+\+Mat\+\_\+only$<$typename Field\+Type\+::object\+\_\+type$>$\+::value$>$$>$ }\\std\+::tuple$<$ Field\+Type, Field\+Type $>$ \textbf{ Split} (const Field\+Type \&input, const double test\+Ratio, const bool shuffle\+Data=true)
\begin{DoxyCompactList}\small\item\em Given an input dataset, split into a training set and test set. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Input\+Type $>$ }\\void \textbf{ Split\+Helper} (const Input\+Type \&input, Input\+Type \&train, Input\+Type \&test, const double test\+Ratio, const arma\+::uvec \&order=arma\+::uvec())
\begin{DoxyCompactList}\small\item\em This helper function splits any {\ttfamily input} data into training and testing parts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , typename Labels\+Type , typename  = std\+::enable\+\_\+if\+\_\+t$<$arma\+::is\+\_\+arma\+\_\+type$<$\+Labels\+Type$>$\+::value$>$$>$ }\\void \textbf{ Stratified\+Split} (const arma\+::\+Mat$<$ T $>$ \&input, const Labels\+Type \&input\+Label, arma\+::\+Mat$<$ T $>$ \&train\+Data, arma\+::\+Mat$<$ T $>$ \&test\+Data, Labels\+Type \&train\+Label, Labels\+Type \&test\+Label, const double test\+Ratio, const bool shuffle\+Data=true)
\begin{DoxyCompactList}\small\item\em Given an input dataset and labels, stratify into a training set and test set. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Functions to load and save matrices and models. 

Functions to load and save matrices.

\subsection{Typedef Documentation}
\mbox{\label{namespacemlpack_1_1data_a728f5dac92331960e1e5822919dd2a41}} 
\index{mlpack\+::data@{mlpack\+::data}!Bag\+Of\+Words\+Encoding@{Bag\+Of\+Words\+Encoding}}
\index{Bag\+Of\+Words\+Encoding@{Bag\+Of\+Words\+Encoding}!mlpack\+::data@{mlpack\+::data}}
\subsubsection{Bag\+Of\+Words\+Encoding}
{\footnotesize\ttfamily using \textbf{ Bag\+Of\+Words\+Encoding} =  \textbf{ String\+Encoding}$<$\textbf{ Bag\+Of\+Words\+Encoding\+Policy}, \textbf{ String\+Encoding\+Dictionary}$<$Token\+Type$>$ $>$}



A convenient alias for the \doxyref{String\+Encoding}{p.}{classmlpack_1_1data_1_1StringEncoding} class with \doxyref{Bag\+Of\+Words\+Encoding\+Policy}{p.}{classmlpack_1_1data_1_1BagOfWordsEncodingPolicy} and the default dictionary for the given token type. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Token\+Type} & Type of the tokens. \\
\hline
\end{DoxyTemplParams}


Definition at line 167 of file bag\+\_\+of\+\_\+words\+\_\+encoding\+\_\+policy.\+hpp.

\mbox{\label{namespacemlpack_1_1data_aa243ad7e4d29363b858bbc92b732921d}} 
\index{mlpack\+::data@{mlpack\+::data}!Dataset\+Info@{Dataset\+Info}}
\index{Dataset\+Info@{Dataset\+Info}!mlpack\+::data@{mlpack\+::data}}
\subsubsection{Dataset\+Info}
{\footnotesize\ttfamily typedef \textbf{ Dataset\+Mapper}$<$ \textbf{ Increment\+Policy}, std\+::string $>$ \textbf{ Dataset\+Info}}



Definition at line 196 of file dataset\+\_\+mapper.\+hpp.

\mbox{\label{namespacemlpack_1_1data_aaa7ca4dc9e2a0d1189d7717b98c01933}} 
\index{mlpack\+::data@{mlpack\+::data}!Dictionary\+Encoding@{Dictionary\+Encoding}}
\index{Dictionary\+Encoding@{Dictionary\+Encoding}!mlpack\+::data@{mlpack\+::data}}
\subsubsection{Dictionary\+Encoding}
{\footnotesize\ttfamily using \textbf{ Dictionary\+Encoding} =  \textbf{ String\+Encoding}$<$\textbf{ Dictionary\+Encoding\+Policy}, \textbf{ String\+Encoding\+Dictionary}$<$Token\+Type$>$ $>$}



A convenient alias for the \doxyref{String\+Encoding}{p.}{classmlpack_1_1data_1_1StringEncoding} class with \doxyref{Dictionary\+Encoding\+Policy}{p.}{classmlpack_1_1data_1_1DictionaryEncodingPolicy} and the default dictionary for the given token type. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Token\+Type} & Type of the tokens. \\
\hline
\end{DoxyTemplParams}


Definition at line 146 of file dictionary\+\_\+encoding\+\_\+policy.\+hpp.

\mbox{\label{namespacemlpack_1_1data_adc64c1431b690f470d4949729d31191f}} 
\index{mlpack\+::data@{mlpack\+::data}!Tf\+Idf\+Encoding@{Tf\+Idf\+Encoding}}
\index{Tf\+Idf\+Encoding@{Tf\+Idf\+Encoding}!mlpack\+::data@{mlpack\+::data}}
\subsubsection{Tf\+Idf\+Encoding}
{\footnotesize\ttfamily using \textbf{ Tf\+Idf\+Encoding} =  \textbf{ String\+Encoding}$<$\textbf{ Tf\+Idf\+Encoding\+Policy}, \textbf{ String\+Encoding\+Dictionary}$<$Token\+Type$>$ $>$}



A convenient alias for the \doxyref{String\+Encoding}{p.}{classmlpack_1_1data_1_1StringEncoding} class with \doxyref{Tf\+Idf\+Encoding\+Policy}{p.}{classmlpack_1_1data_1_1TfIdfEncodingPolicy} and the default dictionary for the given token type. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Token\+Type} & Type of the tokens. \\
\hline
\end{DoxyTemplParams}


Definition at line 345 of file tf\+\_\+idf\+\_\+encoding\+\_\+policy.\+hpp.



\subsection{Enumeration Type Documentation}
\mbox{\label{namespacemlpack_1_1data_aa7714fa0b7efc7b31cbda21da607c5b6}} 
\index{mlpack\+::data@{mlpack\+::data}!Datatype@{Datatype}}
\index{Datatype@{Datatype}!mlpack\+::data@{mlpack\+::data}}
\subsubsection{Datatype}
{\footnotesize\ttfamily enum \textbf{ Datatype} \+: bool}



The Datatype enum specifies the types of data mlpack algorithms can use. 

The vast majority of mlpack algorithms can only use numeric data (i.\+e. float/double/etc.), but some algorithms can use categorical data, specified via this Datatype enum and the \doxyref{Dataset\+Mapper}{p.}{classmlpack_1_1data_1_1DatasetMapper} class. \begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{numeric@{numeric}!mlpack\+::data@{mlpack\+::data}}\index{mlpack\+::data@{mlpack\+::data}!numeric@{numeric}}}\mbox{\label{namespacemlpack_1_1data_aa7714fa0b7efc7b31cbda21da607c5b6a1b5484703e716389553255e6f11f12ec}} 
numeric&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{categorical@{categorical}!mlpack\+::data@{mlpack\+::data}}\index{mlpack\+::data@{mlpack\+::data}!categorical@{categorical}}}\mbox{\label{namespacemlpack_1_1data_aa7714fa0b7efc7b31cbda21da607c5b6a2992a7ab833605792145cd40762644c7}} 
categorical&\\
\hline

\end{DoxyEnumFields}


Definition at line 24 of file datatype.\+hpp.

\mbox{\label{namespacemlpack_1_1data_a387137c43ed9616d39ba90e890d181eb}} 
\index{mlpack\+::data@{mlpack\+::data}!format@{format}}
\index{format@{format}!mlpack\+::data@{mlpack\+::data}}
\subsubsection{format}
{\footnotesize\ttfamily enum \textbf{ format}}



Define the formats we can read through cereal. 

\begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{autodetect@{autodetect}!mlpack\+::data@{mlpack\+::data}}\index{mlpack\+::data@{mlpack\+::data}!autodetect@{autodetect}}}\mbox{\label{namespacemlpack_1_1data_a387137c43ed9616d39ba90e890d181eba7038b9ea9dd309cf5cc8f7122f6c0cee}} 
autodetect&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{json@{json}!mlpack\+::data@{mlpack\+::data}}\index{mlpack\+::data@{mlpack\+::data}!json@{json}}}\mbox{\label{namespacemlpack_1_1data_a387137c43ed9616d39ba90e890d181eba23ac0259f4d3527268c85207a3c2e1f0}} 
json&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{xml@{xml}!mlpack\+::data@{mlpack\+::data}}\index{mlpack\+::data@{mlpack\+::data}!xml@{xml}}}\mbox{\label{namespacemlpack_1_1data_a387137c43ed9616d39ba90e890d181ebac0a194d2e3cadd6447861e57368c2581}} 
xml&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{binary@{binary}!mlpack\+::data@{mlpack\+::data}}\index{mlpack\+::data@{mlpack\+::data}!binary@{binary}}}\mbox{\label{namespacemlpack_1_1data_a387137c43ed9616d39ba90e890d181eba4c41ae0ac8cc59e0caeaa4984dd5d469}} 
binary&\\
\hline

\end{DoxyEnumFields}


Definition at line 20 of file format.\+hpp.



\subsection{Function Documentation}
\mbox{\label{namespacemlpack_1_1data_aa47724fc0e8e354c6ca18818d81705a3}} 
\index{mlpack\+::data@{mlpack\+::data}!Auto\+Detect@{Auto\+Detect}}
\index{Auto\+Detect@{Auto\+Detect}!mlpack\+::data@{mlpack\+::data}}
\subsubsection{Auto\+Detect()}
{\footnotesize\ttfamily arma\+::file\+\_\+type mlpack\+::data\+::\+Auto\+Detect (\begin{DoxyParamCaption}\item[{std\+::fstream \&}]{stream,  }\item[{const std\+::string \&}]{filename }\end{DoxyParamCaption})}



Attempt to auto-\/detect the type of a file given its extension, and by inspecting the parts of the file to disambiguate between types when necessary. 

(For instance, a .csv file could be delimited by spaces, commas, or tabs.) This is meant to be used during loading.

If the file is detected as a C\+SV, and the C\+SV is detected to have a header row, {\ttfamily stream} will be fast-\/forwarded to point at the second line of the file.


\begin{DoxyParams}{Parameters}
{\em stream} & Opened file stream to look into for autodetection. \\
\hline
{\em filename} & Name of the file. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The detected file type. arma\+::file\+\_\+type\+\_\+unknown if unknown. 
\end{DoxyReturn}
\mbox{\label{namespacemlpack_1_1data_a28da72e55467d0872681827b30b490ac}} 
\index{mlpack\+::data@{mlpack\+::data}!Binarize@{Binarize}}
\index{Binarize@{Binarize}!mlpack\+::data@{mlpack\+::data}}
\subsubsection{Binarize()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void mlpack\+::data\+::\+Binarize (\begin{DoxyParamCaption}\item[{const arma\+::\+Mat$<$ T $>$ \&}]{input,  }\item[{arma\+::\+Mat$<$ T $>$ \&}]{output,  }\item[{const double}]{threshold }\end{DoxyParamCaption})}



Given an input dataset and threshold, set values greater than threshold to 1 and values less than or equal to the threshold to 0. 

This overload applies the changes to all dimensions.


\begin{DoxyCode}
arma::Mat<double> input = loadData();
arma::Mat<double> output;
\textcolor{keywordtype}{double} threshold = 0.5;

\textcolor{comment}{// Binarize the whole Matrix. All positive values in will be set to 1 and}
\textcolor{comment}{// the values less than or equal to 0.5 will become 0.}
Binarize<double>(input, output, threshold);
\end{DoxyCode}



\begin{DoxyParams}{Parameters}
{\em input} & Input matrix to Binarize. \\
\hline
{\em output} & Matrix you want to save binarized data into. \\
\hline
{\em threshold} & Threshold can by any number. \\
\hline
\end{DoxyParams}


Definition at line 41 of file binarize.\+hpp.



References omp\+\_\+size\+\_\+t.

\mbox{\label{namespacemlpack_1_1data_a39606420520e81f5e87d6ea1e64c27ae}} 
\index{mlpack\+::data@{mlpack\+::data}!Binarize@{Binarize}}
\index{Binarize@{Binarize}!mlpack\+::data@{mlpack\+::data}}
\subsubsection{Binarize()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void mlpack\+::data\+::\+Binarize (\begin{DoxyParamCaption}\item[{const arma\+::\+Mat$<$ T $>$ \&}]{input,  }\item[{arma\+::\+Mat$<$ T $>$ \&}]{output,  }\item[{const double}]{threshold,  }\item[{const size\+\_\+t}]{dimension }\end{DoxyParamCaption})}



Given an input dataset and threshold, set values greater than threshold to 1 and values less than or equal to the threshold to 0. 

This overload takes a dimension and applys the changes to the given dimension.


\begin{DoxyCode}
arma::Mat<double> input = loadData();
arma::Mat<double> output;
\textcolor{keywordtype}{double} threshold = 0.5;
\textcolor{keywordtype}{size\_t} dimension = 0;

\textcolor{comment}{// Binarize the first dimension. All positive values in the first dimension}
\textcolor{comment}{// will be set to 1 and the values less than or equal to 0 will become 0.}
Binarize<double>(input, output, threshold, dimension);
\end{DoxyCode}



\begin{DoxyParams}{Parameters}
{\em input} & Input matrix to Binarize. \\
\hline
{\em output} & Matrix you want to save binarized data into. \\
\hline
{\em threshold} & Threshold can by any number. \\
\hline
{\em dimension} & Feature to apply the Binarize function. \\
\hline
\end{DoxyParams}


Definition at line 77 of file binarize.\+hpp.



References omp\+\_\+size\+\_\+t.

\mbox{\label{namespacemlpack_1_1data_a3bb1b3de86790e53265efa63e5965d41}} 
\index{mlpack\+::data@{mlpack\+::data}!Confusion\+Matrix@{Confusion\+Matrix}}
\index{Confusion\+Matrix@{Confusion\+Matrix}!mlpack\+::data@{mlpack\+::data}}
\subsubsection{Confusion\+Matrix()}
{\footnotesize\ttfamily void mlpack\+::data\+::\+Confusion\+Matrix (\begin{DoxyParamCaption}\item[{const arma\+::\+Row$<$ size\+\_\+t $>$}]{predictors,  }\item[{const arma\+::\+Row$<$ size\+\_\+t $>$}]{responses,  }\item[{arma\+::\+Mat$<$ eT $>$ \&}]{output,  }\item[{const size\+\_\+t}]{num\+Classes }\end{DoxyParamCaption})}



A confusion matrix is a summary of prediction results on a classification problem. 

The number of correct and incorrect predictions are summarized by count and broken down by each class. For example, for 2 classes, the function call will be


\begin{DoxyCode}
ConfusionMatrix(predictors, responses, output, 2)
\end{DoxyCode}


In this case, the output matrix will be of size 2 $\ast$ 2\+:


\begin{DoxyCode}
     0     1
0    TP    FN
1    FP    TN
\end{DoxyCode}


The confusion matrix for two labels will look like what is shown above. In this confusion matrix, TP represents the number of true positives, FP represents the number of false positives, FN represents the number of false negatives, and TN represents the number of true negatives.

When generalizing to 2 or more classes, the row index of the confusion matrix represents the predicted classes and column index represents the actual class.


\begin{DoxyParams}{Parameters}
{\em predictors} & Vector of data points. \\
\hline
{\em responses} & The measured data for each point. \\
\hline
{\em output} & Matrix which is represented as confusion matrix. \\
\hline
{\em num\+Classes} & Number of classes. \\
\hline
\end{DoxyParams}
\mbox{\label{namespacemlpack_1_1data_ac3115b81a148283970b530603b3f2aaa}} 
\index{mlpack\+::data@{mlpack\+::data}!Detect\+From\+Extension@{Detect\+From\+Extension}}
\index{Detect\+From\+Extension@{Detect\+From\+Extension}!mlpack\+::data@{mlpack\+::data}}
\subsubsection{Detect\+From\+Extension()}
{\footnotesize\ttfamily arma\+::file\+\_\+type mlpack\+::data\+::\+Detect\+From\+Extension (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{filename }\end{DoxyParamCaption})}



Return the type based only on the extension. 


\begin{DoxyParams}{Parameters}
{\em filename} & Name of the file whose type we should detect. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Detected type of file. arma\+::file\+\_\+type\+\_\+unknown if unknown. 
\end{DoxyReturn}
\mbox{\label{namespacemlpack_1_1data_a5a13b28050a64b446916c067e1466951}} 
\index{mlpack\+::data@{mlpack\+::data}!Extension@{Extension}}
\index{Extension@{Extension}!mlpack\+::data@{mlpack\+::data}}
\subsubsection{Extension()}
{\footnotesize\ttfamily std\+::string mlpack\+::data\+::\+Extension (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{filename }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line 21 of file extension.\+hpp.

\mbox{\label{namespacemlpack_1_1data_a898633566d45ba664faacc815915e416}} 
\index{mlpack\+::data@{mlpack\+::data}!Get\+String\+Type@{Get\+String\+Type}}
\index{Get\+String\+Type@{Get\+String\+Type}!mlpack\+::data@{mlpack\+::data}}
\subsubsection{Get\+String\+Type()}
{\footnotesize\ttfamily std\+::string mlpack\+::data\+::\+Get\+String\+Type (\begin{DoxyParamCaption}\item[{const arma\+::file\+\_\+type \&}]{type }\end{DoxyParamCaption})}



Given a file type, return a logical name corresponding to that file type. 


\begin{DoxyParams}{Parameters}
{\em type} & Type to get the logical name of. \\
\hline
\end{DoxyParams}
\mbox{\label{namespacemlpack_1_1data_aa2f0956c373bd666d19e70551fecaf90}} 
\index{mlpack\+::data@{mlpack\+::data}!Guess\+File\+Type@{Guess\+File\+Type}}
\index{Guess\+File\+Type@{Guess\+File\+Type}!mlpack\+::data@{mlpack\+::data}}
\subsubsection{Guess\+File\+Type()}
{\footnotesize\ttfamily arma\+::file\+\_\+type mlpack\+::data\+::\+Guess\+File\+Type (\begin{DoxyParamCaption}\item[{std\+::istream \&}]{f }\end{DoxyParamCaption})}



Given an istream, attempt to guess the file type. 

This is taken originally from Armadillo\textquotesingle{}s function guess\+\_\+file\+\_\+type\+\_\+internal(), but we avoid using internal Armadillo functionality.

If the file is detected as a C\+SV, and the C\+SV is detected to have a header row, the stream {\ttfamily f} will be fast-\/forwarded to point at the second line of the file.


\begin{DoxyParams}{Parameters}
{\em f} & Opened istream to look into to guess the file type. \\
\hline
\end{DoxyParams}
\mbox{\label{namespacemlpack_1_1data_acb5cb8a6b868db7d521f8efbe03b6728}} 
\index{mlpack\+::data@{mlpack\+::data}!H\+A\+S\+\_\+\+E\+X\+A\+C\+T\+\_\+\+M\+E\+T\+H\+O\+D\+\_\+\+F\+O\+RM@{H\+A\+S\+\_\+\+E\+X\+A\+C\+T\+\_\+\+M\+E\+T\+H\+O\+D\+\_\+\+F\+O\+RM}}
\index{H\+A\+S\+\_\+\+E\+X\+A\+C\+T\+\_\+\+M\+E\+T\+H\+O\+D\+\_\+\+F\+O\+RM@{H\+A\+S\+\_\+\+E\+X\+A\+C\+T\+\_\+\+M\+E\+T\+H\+O\+D\+\_\+\+F\+O\+RM}!mlpack\+::data@{mlpack\+::data}}
\subsubsection{H\+A\+S\+\_\+\+E\+X\+A\+C\+T\+\_\+\+M\+E\+T\+H\+O\+D\+\_\+\+F\+O\+R\+M()}
{\footnotesize\ttfamily mlpack\+::data\+::\+H\+A\+S\+\_\+\+E\+X\+A\+C\+T\+\_\+\+M\+E\+T\+H\+O\+D\+\_\+\+F\+O\+RM (\begin{DoxyParamCaption}\item[{serialize}]{,  }\item[{Has\+Serialize\+Check}]{ }\end{DoxyParamCaption})}

\mbox{\label{namespacemlpack_1_1data_a6814f77346f5af80d2c25ef3206713cb}} 
\index{mlpack\+::data@{mlpack\+::data}!Image\+Format\+Supported@{Image\+Format\+Supported}}
\index{Image\+Format\+Supported@{Image\+Format\+Supported}!mlpack\+::data@{mlpack\+::data}}
\subsubsection{Image\+Format\+Supported()}
{\footnotesize\ttfamily bool mlpack\+::data\+::\+Image\+Format\+Supported (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{file\+Name,  }\item[{const bool}]{save = {\ttfamily false} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Checks if the given image filename is supported. 


\begin{DoxyParams}{Parameters}
{\em file\+Name} & Name of the image file. \\
\hline
{\em save} & Set to true to check if the file format can be saved, else loaded. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Boolean value indicating success if it is an image. 
\end{DoxyReturn}
\mbox{\label{namespacemlpack_1_1data_a3799ea79b454b97c5f79a82db6958a1b}} 
\index{mlpack\+::data@{mlpack\+::data}!Is\+Na\+N\+Inf@{Is\+Na\+N\+Inf}}
\index{Is\+Na\+N\+Inf@{Is\+Na\+N\+Inf}!mlpack\+::data@{mlpack\+::data}}
\subsubsection{Is\+Na\+N\+Inf()}
{\footnotesize\ttfamily bool mlpack\+::data\+::\+Is\+Na\+N\+Inf (\begin{DoxyParamCaption}\item[{T \&}]{val,  }\item[{const std\+::string \&}]{token }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



See if the token is a NaN or an Inf, and if so, set the value accordingly and return a boolean representing whether or not it is. 



Definition at line 27 of file is\+\_\+naninf.\+hpp.

\mbox{\label{namespacemlpack_1_1data_abbff2a667bf247e00b1fc09b7ca5f831}} 
\index{mlpack\+::data@{mlpack\+::data}!Load@{Load}}
\index{Load@{Load}!mlpack\+::data@{mlpack\+::data}}
\subsubsection{Load()\hspace{0.1cm}{\footnotesize\ttfamily [1/8]}}
{\footnotesize\ttfamily bool mlpack\+::data\+::\+Load (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{filename,  }\item[{arma\+::\+Mat$<$ eT $>$ \&}]{matrix,  }\item[{const bool}]{fatal = {\ttfamily false},  }\item[{const bool}]{transpose = {\ttfamily true},  }\item[{const arma\+::file\+\_\+type}]{input\+Load\+Type = {\ttfamily arma\+:\+:auto\+\_\+detect} }\end{DoxyParamCaption})}



Loads a matrix from file, guessing the filetype from the extension. 

This will transpose the matrix at load time (unless the transpose parameter is set to false).

The supported types of files are the same as found in Armadillo\+:


\begin{DoxyItemize}
\item C\+SV (arma\+::csv\+\_\+ascii), denoted by .csv, or optionally .txt
\item T\+SV (arma\+::raw\+\_\+ascii), denoted by .tsv, .csv, or .txt
\item A\+S\+C\+II (arma\+::raw\+\_\+ascii), denoted by .txt
\item Armadillo A\+S\+C\+II (arma\+::arma\+\_\+ascii), also denoted by .txt
\item P\+GM (arma\+::pgm\+\_\+binary), denoted by .pgm
\item P\+PM (arma\+::ppm\+\_\+binary), denoted by .ppm
\item Raw binary (arma\+::raw\+\_\+binary), denoted by .bin
\item Armadillo binary (arma\+::arma\+\_\+binary), denoted by .bin
\item H\+D\+F5 (arma\+::hdf5\+\_\+binary), denoted by .hdf, .hdf5, .h5, or .he5
\end{DoxyItemize}

By default, this function will try to automatically determine the type of file to load based on its extension and by inspecting the file. If you know the file type and want to specify it manually, override the default {\ttfamily input\+Load\+Type} parameter with the correct type above (e.\+g. {\ttfamily arma\+::csv\+\_\+ascii}.)

If the detected file type is C\+SV ({\ttfamily arma\+::csv\+\_\+ascii}), the first row will be checked for a C\+SV header. If a C\+SV header is not detected, the first row will be treated as data; otherwise, the first row will be skipped.

If the parameter \textquotesingle{}fatal\textquotesingle{} is set to true, a std\+::runtime\+\_\+error exception will be thrown if the matrix does not load successfully. The parameter \textquotesingle{}transpose\textquotesingle{} controls whether or not the matrix is transposed after loading. In most cases, because data is generally stored in a row-\/major format and mlpack requires column-\/major matrices, this should be left at its default value of \textquotesingle{}true\textquotesingle{}.


\begin{DoxyParams}{Parameters}
{\em filename} & Name of file to load. \\
\hline
{\em matrix} & Matrix to load contents of file into. \\
\hline
{\em fatal} & If an error should be reported as fatal (default false). \\
\hline
{\em transpose} & If true, transpose the matrix after loading (default true). \\
\hline
{\em input\+Load\+Type} & Used to determine the type of file to load (default arma\+::auto\+\_\+detect). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Boolean value indicating success or failure of load. 
\end{DoxyReturn}
\mbox{\label{namespacemlpack_1_1data_a7bfd894be870a3409cc7d3b10b08d689}} 
\index{mlpack\+::data@{mlpack\+::data}!Load@{Load}}
\index{Load@{Load}!mlpack\+::data@{mlpack\+::data}}
\subsubsection{Load()\hspace{0.1cm}{\footnotesize\ttfamily [2/8]}}
{\footnotesize\ttfamily bool mlpack\+::data\+::\+Load (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{filename,  }\item[{arma\+::\+Sp\+Mat$<$ eT $>$ \&}]{matrix,  }\item[{const bool}]{fatal = {\ttfamily false},  }\item[{const bool}]{transpose = {\ttfamily true} }\end{DoxyParamCaption})}



Loads a sparse matrix from file, using arma\+::coord\+\_\+ascii format. 

This will transpose the matrix at load time (unless the transpose parameter is set to false). If the filetype cannot be determined, an error will be given.

The supported types of files are the same as found in Armadillo\+:


\begin{DoxyItemize}
\item T\+SV (coord\+\_\+ascii), denoted by .tsv or .txt
\item T\+XT (coord\+\_\+ascii), denoted by .txt
\item Raw binary (raw\+\_\+binary), denoted by .bin
\item Armadillo binary (arma\+\_\+binary), denoted by .bin
\end{DoxyItemize}

If the file extension is not one of those types, an error will be given. This is preferable to Armadillo\textquotesingle{}s default behavior of loading an unknown filetype as raw\+\_\+binary, which can have very confusing effects.

If the parameter \textquotesingle{}fatal\textquotesingle{} is set to true, a std\+::runtime\+\_\+error exception will be thrown if the matrix does not load successfully. The parameter \textquotesingle{}transpose\textquotesingle{} controls whether or not the matrix is transposed after loading. In most cases, because data is generally stored in a row-\/major format and mlpack requires column-\/major matrices, this should be left at its default value of \textquotesingle{}true\textquotesingle{}.


\begin{DoxyParams}{Parameters}
{\em filename} & Name of file to load. \\
\hline
{\em matrix} & Sparse matrix to load contents of file into. \\
\hline
{\em fatal} & If an error should be reported as fatal (default false). \\
\hline
{\em transpose} & If true, transpose the matrix after loading (default true). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Boolean value indicating success or failure of load. 
\end{DoxyReturn}
\mbox{\label{namespacemlpack_1_1data_adb0c6adf83024427e47a03bd7fbfb885}} 
\index{mlpack\+::data@{mlpack\+::data}!Load@{Load}}
\index{Load@{Load}!mlpack\+::data@{mlpack\+::data}}
\subsubsection{Load()\hspace{0.1cm}{\footnotesize\ttfamily [3/8]}}
{\footnotesize\ttfamily bool mlpack\+::data\+::\+Load (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{filename,  }\item[{arma\+::\+Col$<$ eT $>$ \&}]{vec,  }\item[{const bool}]{fatal = {\ttfamily false} }\end{DoxyParamCaption})}



Don\textquotesingle{}t document these with doxygen; these declarations aren\textquotesingle{}t helpful to users. 

Load a column vector from a file, guessing the filetype from the extension.

The supported types of files are the same as found in Armadillo\+:


\begin{DoxyItemize}
\item C\+SV (csv\+\_\+ascii), denoted by .csv, or optionally .txt
\item T\+SV (raw\+\_\+ascii), denoted by .tsv, .csv, or .txt
\item A\+S\+C\+II (raw\+\_\+ascii), denoted by .txt
\item Armadillo A\+S\+C\+II (arma\+\_\+ascii), also denoted by .txt
\item P\+GM (pgm\+\_\+binary), denoted by .pgm
\item P\+PM (ppm\+\_\+binary), denoted by .ppm
\item Raw binary (raw\+\_\+binary), denoted by .bin
\item Armadillo binary (arma\+\_\+binary), denoted by .bin
\item H\+D\+F5, denoted by .hdf, .hdf5, .h5, or .he5
\end{DoxyItemize}

If the file extension is not one of those types, an error will be given. This is preferable to Armadillo\textquotesingle{}s default behavior of loading an unknown filetype as raw\+\_\+binary, which can have very confusing effects.

If the parameter \textquotesingle{}fatal\textquotesingle{} is set to true, a std\+::runtime\+\_\+error exception will be thrown if the matrix does not load successfully.


\begin{DoxyParams}{Parameters}
{\em filename} & Name of file to load. \\
\hline
{\em vec} & Column vector to load contents of file into. \\
\hline
{\em fatal} & If an error should be reported as fatal (default false). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Boolean value indicating success or failure of load. 
\end{DoxyReturn}
\mbox{\label{namespacemlpack_1_1data_ac5679a4dc8c6129e3895a1089855d25d}} 
\index{mlpack\+::data@{mlpack\+::data}!Load@{Load}}
\index{Load@{Load}!mlpack\+::data@{mlpack\+::data}}
\subsubsection{Load()\hspace{0.1cm}{\footnotesize\ttfamily [4/8]}}
{\footnotesize\ttfamily bool mlpack\+::data\+::\+Load (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{filename,  }\item[{arma\+::\+Row$<$ eT $>$ \&}]{rowvec,  }\item[{const bool}]{fatal = {\ttfamily false} }\end{DoxyParamCaption})}



Load a row vector from a file, guessing the filetype from the extension. 

The supported types of files are the same as found in Armadillo\+:


\begin{DoxyItemize}
\item C\+SV (csv\+\_\+ascii), denoted by .csv, or optionally .txt
\item T\+SV (raw\+\_\+ascii), denoted by .tsv, .csv, or .txt
\item A\+S\+C\+II (raw\+\_\+ascii), denoted by .txt
\item Armadillo A\+S\+C\+II (arma\+\_\+ascii), also denoted by .txt
\item P\+GM (pgm\+\_\+binary), denoted by .pgm
\item P\+PM (ppm\+\_\+binary), denoted by .ppm
\item Raw binary (raw\+\_\+binary), denoted by .bin
\item Armadillo binary (arma\+\_\+binary), denoted by .bin
\item H\+D\+F5, denoted by .hdf, .hdf5, .h5, or .he5
\end{DoxyItemize}

If the file extension is not one of those types, an error will be given. This is preferable to Armadillo\textquotesingle{}s default behavior of loading an unknown filetype as raw\+\_\+binary, which can have very confusing effects.

If the parameter \textquotesingle{}fatal\textquotesingle{} is set to true, a std\+::runtime\+\_\+error exception will be thrown if the matrix does not load successfully.


\begin{DoxyParams}{Parameters}
{\em filename} & Name of file to load. \\
\hline
{\em rowvec} & Row vector to load contents of file into. \\
\hline
{\em fatal} & If an error should be reported as fatal (default false). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Boolean value indicating success or failure of load. 
\end{DoxyReturn}
\mbox{\label{namespacemlpack_1_1data_a9af06d46f91871c42f38e30aac5d4666}} 
\index{mlpack\+::data@{mlpack\+::data}!Load@{Load}}
\index{Load@{Load}!mlpack\+::data@{mlpack\+::data}}
\subsubsection{Load()\hspace{0.1cm}{\footnotesize\ttfamily [5/8]}}
{\footnotesize\ttfamily bool mlpack\+::data\+::\+Load (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{filename,  }\item[{arma\+::\+Mat$<$ eT $>$ \&}]{matrix,  }\item[{\textbf{ Dataset\+Mapper}$<$ Policy\+Type $>$ \&}]{info,  }\item[{const bool}]{fatal = {\ttfamily false},  }\item[{const bool}]{transpose = {\ttfamily true} }\end{DoxyParamCaption})}



Loads a matrix from a file, guessing the filetype from the extension and mapping categorical features with a \doxyref{Dataset\+Mapper}{p.}{classmlpack_1_1data_1_1DatasetMapper} object. 

This will transpose the matrix (unless the transpose parameter is set to false). This particular overload of \doxyref{Load()}{p.}{namespacemlpack_1_1data_abbff2a667bf247e00b1fc09b7ca5f831} can only load text-\/based formats, such as those given below\+:


\begin{DoxyItemize}
\item C\+SV (csv\+\_\+ascii), denoted by .csv, or optionally .txt
\item T\+SV (raw\+\_\+ascii), denoted by .tsv, .csv, or .txt
\item A\+S\+C\+II (raw\+\_\+ascii), denoted by .txt
\end{DoxyItemize}

If the file extension is not one of those types, an error will be given. This is preferable to Armadillo\textquotesingle{}s default behavior of loading an unknown filetype as raw\+\_\+binary, which can have very confusing effects.

If the parameter \textquotesingle{}fatal\textquotesingle{} is set to true, a std\+::runtime\+\_\+error exception will be thrown if the matrix does not load successfully. The parameter \textquotesingle{}transpose\textquotesingle{} controls whether or not the matrix is transposed after loading. In most cases, because data is generally stored in a row-\/major format and mlpack requires column-\/major matrices, this should be left at its default value of \textquotesingle{}true\textquotesingle{}.

The \doxyref{Dataset\+Mapper}{p.}{classmlpack_1_1data_1_1DatasetMapper} object passed to this function will be re-\/created, so any mappings from previous loads will be lost.


\begin{DoxyParams}{Parameters}
{\em filename} & Name of file to load. \\
\hline
{\em matrix} & Matrix to load contents of file into. \\
\hline
{\em info} & \doxyref{Dataset\+Mapper}{p.}{classmlpack_1_1data_1_1DatasetMapper} object to populate with mappings and data types. \\
\hline
{\em fatal} & If an error should be reported as fatal (default false). \\
\hline
{\em transpose} & If true, transpose the matrix after loading. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Boolean value indicating success or failure of load. 
\end{DoxyReturn}
\mbox{\label{namespacemlpack_1_1data_ac0441d5f7e76f0fcdeec487d4a9732ac}} 
\index{mlpack\+::data@{mlpack\+::data}!Load@{Load}}
\index{Load@{Load}!mlpack\+::data@{mlpack\+::data}}
\subsubsection{Load()\hspace{0.1cm}{\footnotesize\ttfamily [6/8]}}
{\footnotesize\ttfamily bool mlpack\+::data\+::\+Load (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{filename,  }\item[{const std\+::string \&}]{name,  }\item[{T \&}]{t,  }\item[{const bool}]{fatal = {\ttfamily false},  }\item[{\textbf{ format}}]{f = {\ttfamily format\+:\+:autodetect} }\end{DoxyParamCaption})}



Don\textquotesingle{}t document these with doxygen; they aren\textquotesingle{}t helpful for users to know about. 

Load a model from a file, guessing the filetype from the extension, or, optionally, loading the specified format. If automatic extension detection is used and the filetype cannot be determined, an error will be given.

The supported types of files are the same as what is supported by the cereal library\+:


\begin{DoxyItemize}
\item json, denoted by .json
\item xml, denoted by .xml
\item binary, denoted by .bin
\end{DoxyItemize}

The format parameter can take any of the values in the \textquotesingle{}format\textquotesingle{} enum\+: \textquotesingle{}format\+::autodetect\textquotesingle{}, \textquotesingle{}format\+::json\textquotesingle{}, \textquotesingle{}format\+::xml\textquotesingle{}, and \textquotesingle{}format\+::binary\textquotesingle{}. The autodetect functionality operates on the file extension (so, \char`\"{}file.\+txt\char`\"{} would be autodetected as text).

The name parameter should be specified to indicate the name of the structure to be loaded. This should be the same as the name that was used to save the structure (otherwise, the loading procedure will fail).

If the parameter \textquotesingle{}fatal\textquotesingle{} is set to true, then an exception will be thrown in the event of load failure. Otherwise, the method will return false and the relevant error information will be printed to Log\+::\+Warn. \mbox{\label{namespacemlpack_1_1data_aa05aba27ed8693c1c4ed538240a549b1}} 
\index{mlpack\+::data@{mlpack\+::data}!Load@{Load}}
\index{Load@{Load}!mlpack\+::data@{mlpack\+::data}}
\subsubsection{Load()\hspace{0.1cm}{\footnotesize\ttfamily [7/8]}}
{\footnotesize\ttfamily bool mlpack\+::data\+::\+Load (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{filename,  }\item[{arma\+::\+Mat$<$ eT $>$ \&}]{matrix,  }\item[{\textbf{ Image\+Info} \&}]{info,  }\item[{const bool}]{fatal = {\ttfamily false} }\end{DoxyParamCaption})}



Image load/save interfaces. 

Load the image file into the given matrix.


\begin{DoxyParams}{Parameters}
{\em filename} & Name of the image file. \\
\hline
{\em matrix} & Matrix to load the image into. \\
\hline
{\em info} & An object of \doxyref{Image\+Info}{p.}{classmlpack_1_1data_1_1ImageInfo} class. \\
\hline
{\em fatal} & If an error should be reported as fatal (default false). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Boolean value indicating success or failure of load. 
\end{DoxyReturn}
\mbox{\label{namespacemlpack_1_1data_adf6afb44303645116a32d1ed168e0ff1}} 
\index{mlpack\+::data@{mlpack\+::data}!Load@{Load}}
\index{Load@{Load}!mlpack\+::data@{mlpack\+::data}}
\subsubsection{Load()\hspace{0.1cm}{\footnotesize\ttfamily [8/8]}}
{\footnotesize\ttfamily bool mlpack\+::data\+::\+Load (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ std\+::string $>$ \&}]{files,  }\item[{arma\+::\+Mat$<$ eT $>$ \&}]{matrix,  }\item[{\textbf{ Image\+Info} \&}]{info,  }\item[{const bool}]{fatal = {\ttfamily false} }\end{DoxyParamCaption})}



Load the image file into the given matrix. 


\begin{DoxyParams}{Parameters}
{\em files} & A vector consisting of filenames. \\
\hline
{\em matrix} & Matrix to save the image from. \\
\hline
{\em info} & An object of \doxyref{Image\+Info}{p.}{classmlpack_1_1data_1_1ImageInfo} class. \\
\hline
{\em fatal} & If an error should be reported as fatal (default false). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Boolean value indicating success or failure of load. 
\end{DoxyReturn}
\mbox{\label{namespacemlpack_1_1data_a951a7dc1fd86524b8dd245bb91841731}} 
\index{mlpack\+::data@{mlpack\+::data}!Load\+A\+R\+FF@{Load\+A\+R\+FF}}
\index{Load\+A\+R\+FF@{Load\+A\+R\+FF}!mlpack\+::data@{mlpack\+::data}}
\subsubsection{Load\+A\+R\+F\+F()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void mlpack\+::data\+::\+Load\+A\+R\+FF (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{filename,  }\item[{arma\+::\+Mat$<$ eT $>$ \&}]{matrix }\end{DoxyParamCaption})}



A utility function to load an A\+R\+FF dataset as numeric features (that is, as an Armadillo matrix without any modification). 

An exception will be thrown if any features are non-\/numeric. \mbox{\label{namespacemlpack_1_1data_aa2a4a09a274c068e08373200fe611422}} 
\index{mlpack\+::data@{mlpack\+::data}!Load\+A\+R\+FF@{Load\+A\+R\+FF}}
\index{Load\+A\+R\+FF@{Load\+A\+R\+FF}!mlpack\+::data@{mlpack\+::data}}
\subsubsection{Load\+A\+R\+F\+F()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void mlpack\+::data\+::\+Load\+A\+R\+FF (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{filename,  }\item[{arma\+::\+Mat$<$ eT $>$ \&}]{matrix,  }\item[{\textbf{ Dataset\+Mapper}$<$ Policy\+Type $>$ \&}]{info }\end{DoxyParamCaption})}



A utility function to load an A\+R\+FF dataset as numeric and categorical features, using the Dataset\+Info structure for mapping. 

An exception will be thrown upon failure.

A pre-\/existing Dataset\+Info object can be passed in, but if the dimensionality of the given Dataset\+Info object (info.\+Dimensionality()) does not match the dimensionality of the data, a std\+::invalid\+\_\+argument exception will be thrown. If an empty Dataset\+Info object is given (constructed with the default constructor or otherwise, so that info.\+Dimensionality() is 0), it will be set to the right dimensionality.

This ability to pass in pre-\/existing Dataset\+Info objects is very necessary when, e.\+g., loading a test set after training. If the same Dataset\+Info from loading the training set is not used, then the test set may be loaded with different mappings---which can cause horrible problems!


\begin{DoxyParams}{Parameters}
{\em filename} & Name of A\+R\+FF file to load. \\
\hline
{\em matrix} & Matrix to load data into. \\
\hline
{\em info} & Dataset\+Info object; can be default-\/constructed or pre-\/existing from another call to \doxyref{Load\+A\+R\+F\+F()}{p.}{namespacemlpack_1_1data_a951a7dc1fd86524b8dd245bb91841731}. \\
\hline
\end{DoxyParams}
\mbox{\label{namespacemlpack_1_1data_a01155770d761c5cf686a666f3622caa5}} 
\index{mlpack\+::data@{mlpack\+::data}!Load\+Image@{Load\+Image}}
\index{Load\+Image@{Load\+Image}!mlpack\+::data@{mlpack\+::data}}
\subsubsection{Load\+Image()}
{\footnotesize\ttfamily bool mlpack\+::data\+::\+Load\+Image (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{filename,  }\item[{arma\+::\+Mat$<$ unsigned char $>$ \&}]{matrix,  }\item[{\textbf{ Image\+Info} \&}]{info,  }\item[{const bool}]{fatal = {\ttfamily false} }\end{DoxyParamCaption})}

\mbox{\label{namespacemlpack_1_1data_a664b3fa5243889e2aed47ee750f840ed}} 
\index{mlpack\+::data@{mlpack\+::data}!Normalize\+Labels@{Normalize\+Labels}}
\index{Normalize\+Labels@{Normalize\+Labels}!mlpack\+::data@{mlpack\+::data}}
\subsubsection{Normalize\+Labels()}
{\footnotesize\ttfamily void mlpack\+::data\+::\+Normalize\+Labels (\begin{DoxyParamCaption}\item[{const Row\+Type \&}]{labels\+In,  }\item[{arma\+::\+Row$<$ size\+\_\+t $>$ \&}]{labels,  }\item[{arma\+::\+Col$<$ eT $>$ \&}]{mapping }\end{DoxyParamCaption})}



Given a set of labels of a particular datatype, convert them to unsigned labels in the range [0, n) where n is the number of different labels. 

Also, a reverse mapping from the new label to the old value is stored in the \textquotesingle{}mapping\textquotesingle{} vector.


\begin{DoxyParams}{Parameters}
{\em labels\+In} & Input labels of arbitrary datatype. \\
\hline
{\em labels} & Vector that unsigned labels will be stored in. \\
\hline
{\em mapping} & Reverse mapping to convert new labels back to old labels. \\
\hline
\end{DoxyParams}
\mbox{\label{namespacemlpack_1_1data_a0d41d92266983ceb192346478a54ec23}} 
\index{mlpack\+::data@{mlpack\+::data}!One\+Hot\+Encoding@{One\+Hot\+Encoding}}
\index{One\+Hot\+Encoding@{One\+Hot\+Encoding}!mlpack\+::data@{mlpack\+::data}}
\subsubsection{One\+Hot\+Encoding()\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily void mlpack\+::data\+::\+One\+Hot\+Encoding (\begin{DoxyParamCaption}\item[{const Row\+Type \&}]{labels\+In,  }\item[{Mat\+Type \&}]{output }\end{DoxyParamCaption})}



Given a set of labels of a particular datatype, convert them to binary vector. 

The categorical values be mapped to integer values. Then, each integer value is represented as a binary vector that is all zero values except the index of the integer, which is marked with a 1.


\begin{DoxyParams}{Parameters}
{\em labels\+In} & Input labels of arbitrary datatype. \\
\hline
{\em output} & Binary matrix. \\
\hline
\end{DoxyParams}
\mbox{\label{namespacemlpack_1_1data_a91f3e880da9955942bd129414fe617a9}} 
\index{mlpack\+::data@{mlpack\+::data}!One\+Hot\+Encoding@{One\+Hot\+Encoding}}
\index{One\+Hot\+Encoding@{One\+Hot\+Encoding}!mlpack\+::data@{mlpack\+::data}}
\subsubsection{One\+Hot\+Encoding()\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily void mlpack\+::data\+::\+One\+Hot\+Encoding (\begin{DoxyParamCaption}\item[{const arma\+::\+Mat$<$ eT $>$ \&}]{input,  }\item[{const arma\+::\+Col$<$ size\+\_\+t $>$ \&}]{indices,  }\item[{arma\+::\+Mat$<$ eT $>$ \&}]{output }\end{DoxyParamCaption})}



Overloaded function for the above function, which takes a matrix as input and also a vector of indices to encode and outputs a matrix. 

Indices represent the I\+Ds of the dimensions to be one-\/hot encoded.


\begin{DoxyParams}{Parameters}
{\em input} & Input dataset to be encoded. \\
\hline
{\em indices} & Index of rows to be encoded. \\
\hline
{\em output} & Encoded matrix. \\
\hline
\end{DoxyParams}
\mbox{\label{namespacemlpack_1_1data_a007765ae6ce1f59513e6644bd2c66988}} 
\index{mlpack\+::data@{mlpack\+::data}!One\+Hot\+Encoding@{One\+Hot\+Encoding}}
\index{One\+Hot\+Encoding@{One\+Hot\+Encoding}!mlpack\+::data@{mlpack\+::data}}
\subsubsection{One\+Hot\+Encoding()\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily void mlpack\+::data\+::\+One\+Hot\+Encoding (\begin{DoxyParamCaption}\item[{const arma\+::\+Mat$<$ eT $>$ \&}]{input,  }\item[{arma\+::\+Mat$<$ eT $>$ \&}]{output,  }\item[{const \textbf{ data\+::\+Dataset\+Info} \&}]{dataset\+Info }\end{DoxyParamCaption})}



Overloaded function for the above function, which takes a matrix as input and also a Dataset\+Info object and outputs a matrix. 

This function encodes all the dimensions marked {\ttfamily Datatype\+::categorical} in the \doxyref{data\+::\+Dataset\+Info}{p.}{namespacemlpack_1_1data_aa243ad7e4d29363b858bbc92b732921d}.


\begin{DoxyParams}{Parameters}
{\em input} & Input dataset to be encoded. \\
\hline
{\em output} & Encoded matrix. \\
\hline
{\em dataset\+Info} & Dataset\+Info object that has information about data. \\
\hline
\end{DoxyParams}
\mbox{\label{namespacemlpack_1_1data_a901fe08dcdc58734f64a864dbdef0a28}} 
\index{mlpack\+::data@{mlpack\+::data}!Revert\+Labels@{Revert\+Labels}}
\index{Revert\+Labels@{Revert\+Labels}!mlpack\+::data@{mlpack\+::data}}
\subsubsection{Revert\+Labels()}
{\footnotesize\ttfamily void mlpack\+::data\+::\+Revert\+Labels (\begin{DoxyParamCaption}\item[{const arma\+::\+Row$<$ size\+\_\+t $>$ \&}]{labels,  }\item[{const arma\+::\+Col$<$ eT $>$ \&}]{mapping,  }\item[{arma\+::\+Row$<$ eT $>$ \&}]{labels\+Out }\end{DoxyParamCaption})}



Given a set of labels that have been mapped to the range [0, n), map them back to the original labels given by the \textquotesingle{}mapping\textquotesingle{} vector. 


\begin{DoxyParams}{Parameters}
{\em labels} & Set of normalized labels to convert. \\
\hline
{\em mapping} & Mapping to use to convert labels. \\
\hline
{\em labels\+Out} & Vector to store new labels in. \\
\hline
\end{DoxyParams}
\mbox{\label{namespacemlpack_1_1data_accd1605a1d160c09ee75c93a587dc313}} 
\index{mlpack\+::data@{mlpack\+::data}!Save@{Save}}
\index{Save@{Save}!mlpack\+::data@{mlpack\+::data}}
\subsubsection{Save()\hspace{0.1cm}{\footnotesize\ttfamily [1/5]}}
{\footnotesize\ttfamily bool mlpack\+::data\+::\+Save (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{filename,  }\item[{const arma\+::\+Mat$<$ eT $>$ \&}]{matrix,  }\item[{const bool}]{fatal = {\ttfamily false},  }\item[{bool}]{transpose = {\ttfamily true},  }\item[{arma\+::file\+\_\+type}]{input\+Save\+Type = {\ttfamily arma\+:\+:auto\+\_\+detect} }\end{DoxyParamCaption})}



Saves a matrix to file, guessing the filetype from the extension. 

This will transpose the matrix at save time. If the filetype cannot be determined, an error will be given.

The supported types of files are the same as found in Armadillo\+:


\begin{DoxyItemize}
\item C\+SV (arma\+::csv\+\_\+ascii), denoted by .csv, or optionally .txt
\item A\+S\+C\+II (arma\+::raw\+\_\+ascii), denoted by .json
\item Armadillo A\+S\+C\+II (arma\+::arma\+\_\+ascii), also denoted by .txt
\item P\+GM (arma\+::pgm\+\_\+binary), denoted by .pgm
\item P\+PM (arma\+::ppm\+\_\+binary), denoted by .ppm
\item Raw binary (arma\+::raw\+\_\+binary), denoted by .bin
\item Armadillo binary (arma\+::arma\+\_\+binary), denoted by .bin
\item H\+D\+F5 (arma\+::hdf5\+\_\+binary), denoted by .hdf5, .hdf, .h5, or .he5
\end{DoxyItemize}

By default, this function will try to automatically determine the format to save with based only on the filename\textquotesingle{}s extension. If you would prefer to specify a file type manually, override the default {\ttfamily input\+Save\+Type} parameter with the correct type above (e.\+g. {\ttfamily arma\+::csv\+\_\+ascii}.)

If the \textquotesingle{}fatal\textquotesingle{} parameter is set to true, a std\+::runtime\+\_\+error exception will be thrown upon failure. If the \textquotesingle{}transpose\textquotesingle{} parameter is set to true, the matrix will be transposed before saving. Generally, because mlpack stores matrices in a column-\/major format and most datasets are stored on disk as row-\/major, this parameter should be left at its default value of \textquotesingle{}true\textquotesingle{}.


\begin{DoxyParams}{Parameters}
{\em filename} & Name of file to save to. \\
\hline
{\em matrix} & Matrix to save into file. \\
\hline
{\em fatal} & If an error should be reported as fatal (default false). \\
\hline
{\em transpose} & If true, transpose the matrix before saving (default true). \\
\hline
{\em input\+Save\+Type} & File type to save to (defaults to arma\+::auto\+\_\+detect). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Boolean value indicating success or failure of save. 
\end{DoxyReturn}
\mbox{\label{namespacemlpack_1_1data_ad5510cd863171eb3bc1dec000a78b482}} 
\index{mlpack\+::data@{mlpack\+::data}!Save@{Save}}
\index{Save@{Save}!mlpack\+::data@{mlpack\+::data}}
\subsubsection{Save()\hspace{0.1cm}{\footnotesize\ttfamily [2/5]}}
{\footnotesize\ttfamily bool mlpack\+::data\+::\+Save (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{filename,  }\item[{const arma\+::\+Sp\+Mat$<$ eT $>$ \&}]{matrix,  }\item[{const bool}]{fatal = {\ttfamily false},  }\item[{bool}]{transpose = {\ttfamily true} }\end{DoxyParamCaption})}



Saves a sparse matrix to file, guessing the filetype from the extension. 

This will transpose the matrix at save time. If the filetype cannot be determined, an error will be given.

The supported types of files are the same as found in Armadillo\+:


\begin{DoxyItemize}
\item T\+SV (coord\+\_\+ascii), denoted by .tsv or .txt
\item T\+XT (coord\+\_\+ascii), denoted by .txt
\item Raw binary (raw\+\_\+binary), denoted by .bin
\item Armadillo binary (arma\+\_\+binary), denoted by .bin
\end{DoxyItemize}

If the file extension is not one of those types, an error will be given. If the \textquotesingle{}fatal\textquotesingle{} parameter is set to true, a std\+::runtime\+\_\+error exception will be thrown upon failure. If the \textquotesingle{}transpose\textquotesingle{} parameter is set to true, the matrix will be transposed before saving. Generally, because mlpack stores matrices in a column-\/major format and most datasets are stored on disk as row-\/major, this parameter should be left at its default value of \textquotesingle{}true\textquotesingle{}.


\begin{DoxyParams}{Parameters}
{\em filename} & Name of file to save to. \\
\hline
{\em matrix} & Sparse matrix to save into file. \\
\hline
{\em fatal} & If an error should be reported as fatal (default false). \\
\hline
{\em transpose} & If true, transpose the matrix before saving (default true). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Boolean value indicating success or failure of save. 
\end{DoxyReturn}
\mbox{\label{namespacemlpack_1_1data_af30f8bfca9b924d6d935c9f1fae91778}} 
\index{mlpack\+::data@{mlpack\+::data}!Save@{Save}}
\index{Save@{Save}!mlpack\+::data@{mlpack\+::data}}
\subsubsection{Save()\hspace{0.1cm}{\footnotesize\ttfamily [3/5]}}
{\footnotesize\ttfamily bool mlpack\+::data\+::\+Save (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{filename,  }\item[{const std\+::string \&}]{name,  }\item[{T \&}]{t,  }\item[{const bool}]{fatal = {\ttfamily false},  }\item[{\textbf{ format}}]{f = {\ttfamily format\+:\+:autodetect} }\end{DoxyParamCaption})}



Saves a model to file, guessing the filetype from the extension, or, optionally, saving the specified format. 

If automatic extension detection is used and the filetype cannot be determined, and error will be given.

The supported types of files are the same as what is supported by the cereal library\+:


\begin{DoxyItemize}
\item json, denoted by .json
\item xml, denoted by .xml
\item binary, denoted by .bin
\end{DoxyItemize}

The format parameter can take any of the values in the \textquotesingle{}format\textquotesingle{} enum\+: \textquotesingle{}format\+::autodetect\textquotesingle{}, \textquotesingle{}format\+::json\textquotesingle{}, \textquotesingle{}format\+::xml\textquotesingle{}, and \textquotesingle{}format\+::binary\textquotesingle{}. The autodetect functionality operates on the file extension (so, \char`\"{}file.\+txt\char`\"{} would be autodetected as text).

The name parameter should be specified to indicate the name of the structure to be saved. If \doxyref{Load()}{p.}{namespacemlpack_1_1data_abbff2a667bf247e00b1fc09b7ca5f831} is later called on the generated file, the name used to load should be the same as the name used for this call to \doxyref{Save()}{p.}{namespacemlpack_1_1data_accd1605a1d160c09ee75c93a587dc313}.

If the parameter \textquotesingle{}fatal\textquotesingle{} is set to true, then an exception will be thrown in the event of a save failure. Otherwise, the method will return false and the relevant error information will be printed to Log\+::\+Warn. \mbox{\label{namespacemlpack_1_1data_a255acca42390d66faaed4521eb502de8}} 
\index{mlpack\+::data@{mlpack\+::data}!Save@{Save}}
\index{Save@{Save}!mlpack\+::data@{mlpack\+::data}}
\subsubsection{Save()\hspace{0.1cm}{\footnotesize\ttfamily [4/5]}}
{\footnotesize\ttfamily bool mlpack\+::data\+::\+Save (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{filename,  }\item[{arma\+::\+Mat$<$ eT $>$ \&}]{matrix,  }\item[{\textbf{ Image\+Info} \&}]{info,  }\item[{const bool}]{fatal = {\ttfamily false} }\end{DoxyParamCaption})}



Save the image file from the given matrix. 


\begin{DoxyParams}{Parameters}
{\em filename} & Name of the image file. \\
\hline
{\em matrix} & Matrix to save the image from. \\
\hline
{\em info} & An object of \doxyref{Image\+Info}{p.}{classmlpack_1_1data_1_1ImageInfo} class. \\
\hline
{\em fatal} & If an error should be reported as fatal (default false). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Boolean value indicating success or failure of load. 
\end{DoxyReturn}
\mbox{\label{namespacemlpack_1_1data_a9402b433306b2735be417a07d8397d9c}} 
\index{mlpack\+::data@{mlpack\+::data}!Save@{Save}}
\index{Save@{Save}!mlpack\+::data@{mlpack\+::data}}
\subsubsection{Save()\hspace{0.1cm}{\footnotesize\ttfamily [5/5]}}
{\footnotesize\ttfamily bool mlpack\+::data\+::\+Save (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ std\+::string $>$ \&}]{files,  }\item[{arma\+::\+Mat$<$ eT $>$ \&}]{matrix,  }\item[{\textbf{ Image\+Info} \&}]{info,  }\item[{const bool}]{fatal = {\ttfamily false} }\end{DoxyParamCaption})}



Save the image file from the given matrix. 


\begin{DoxyParams}{Parameters}
{\em files} & A vector consisting of filenames. \\
\hline
{\em matrix} & Matrix to save the image from. \\
\hline
{\em info} & An object of \doxyref{Image\+Info}{p.}{classmlpack_1_1data_1_1ImageInfo} class. \\
\hline
{\em fatal} & If an error should be reported as fatal (default false). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Boolean value indicating success or failure of load. 
\end{DoxyReturn}
\mbox{\label{namespacemlpack_1_1data_a5053734839d456ce3bfe20b16a467d0c}} 
\index{mlpack\+::data@{mlpack\+::data}!Save\+Image@{Save\+Image}}
\index{Save\+Image@{Save\+Image}!mlpack\+::data@{mlpack\+::data}}
\subsubsection{Save\+Image()}
{\footnotesize\ttfamily bool mlpack\+::data\+::\+Save\+Image (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{filename,  }\item[{arma\+::\+Mat$<$ unsigned char $>$ \&}]{image,  }\item[{\textbf{ Image\+Info} \&}]{info,  }\item[{const bool}]{fatal = {\ttfamily false} }\end{DoxyParamCaption})}



Helper function to save files. 

Implementation in save\+\_\+image.\+cpp. \mbox{\label{namespacemlpack_1_1data_a32f749a2ac526fd90ab112400fad6ef2}} 
\index{mlpack\+::data@{mlpack\+::data}!Split@{Split}}
\index{Split@{Split}!mlpack\+::data@{mlpack\+::data}}
\subsubsection{Split()\hspace{0.1cm}{\footnotesize\ttfamily [1/8]}}
{\footnotesize\ttfamily void mlpack\+::data\+::\+Split (\begin{DoxyParamCaption}\item[{const arma\+::\+Mat$<$ T $>$ \&}]{input,  }\item[{const Labels\+Type \&}]{input\+Label,  }\item[{arma\+::\+Mat$<$ T $>$ \&}]{train\+Data,  }\item[{arma\+::\+Mat$<$ T $>$ \&}]{test\+Data,  }\item[{Labels\+Type \&}]{train\+Label,  }\item[{Labels\+Type \&}]{test\+Label,  }\item[{const double}]{test\+Ratio,  }\item[{const bool}]{shuffle\+Data = {\ttfamily true} }\end{DoxyParamCaption})}



Given an input dataset and labels, split into a training set and test set. 

Example usage below. This overload places the split dataset into the four output parameters given (train\+Data, test\+Data, train\+Label, and test\+Label).


\begin{DoxyCode}
arma::mat input = loadData();
arma::Row<size\_t> label = loadLabel();
arma::mat trainData;
arma::mat testData;
arma::Row<size\_t> trainLabel;
arma::Row<size\_t> testLabel;
math::RandomSeed(100); \textcolor{comment}{// Set the seed if you like.}

\textcolor{comment}{// Split the dataset into a training and test set, with 30% of the data being}
\textcolor{comment}{// held out for the test set.}
Split(input, label, trainData,
               testData, trainLabel, testLabel, 0.3);
\end{DoxyCode}



\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Type of the elements of the input matrix. \\
\hline
{\em Labels\+Type} & Type of input labels. It can be arma\+::\+Mat, arma\+::\+Row, arma\+::\+Cube or arma\+::\+Sp\+Mat. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em input} & Input dataset to split. \\
\hline
{\em input\+Label} & Input labels to split. \\
\hline
{\em train\+Data} & Matrix to store training data into. \\
\hline
{\em test\+Data} & Matrix to store test data into. \\
\hline
{\em train\+Label} & Vector to store training labels into. \\
\hline
{\em test\+Label} & Vector to store test labels into. \\
\hline
{\em test\+Ratio} & Percentage of dataset to use for test set (between 0 and 1). \\
\hline
{\em shuffle\+Data} & If true, the sample order is shuffled; otherwise, each sample is visited in linear order. (Default true.) \\
\hline
\end{DoxyParams}


Definition at line 255 of file split\+\_\+data.\+hpp.



References Split\+Helper().



Referenced by Split().

\mbox{\label{namespacemlpack_1_1data_a0ac4c8b737e134361d49d5c1c3f9f6ba}} 
\index{mlpack\+::data@{mlpack\+::data}!Split@{Split}}
\index{Split@{Split}!mlpack\+::data@{mlpack\+::data}}
\subsubsection{Split()\hspace{0.1cm}{\footnotesize\ttfamily [2/8]}}
{\footnotesize\ttfamily void mlpack\+::data\+::\+Split (\begin{DoxyParamCaption}\item[{const arma\+::\+Mat$<$ T $>$ \&}]{input,  }\item[{arma\+::\+Mat$<$ T $>$ \&}]{train\+Data,  }\item[{arma\+::\+Mat$<$ T $>$ \&}]{test\+Data,  }\item[{const double}]{test\+Ratio,  }\item[{const bool}]{shuffle\+Data = {\ttfamily true} }\end{DoxyParamCaption})}



Given an input dataset, split into a training set and test set. 

Example usage below. This overload places the split dataset into the two output parameters given (train\+Data, test\+Data).


\begin{DoxyCode}
arma::mat input = loadData();
arma::mat trainData;
arma::mat testData;
math::RandomSeed(100); \textcolor{comment}{// Set the seed if you like.}

\textcolor{comment}{// Split the dataset into a training and test set, with 30% of the data being}
\textcolor{comment}{// held out for the test set.}
Split(input, trainData, testData, 0.3);
\end{DoxyCode}



\begin{DoxyParams}{Parameters}
{\em input} & Input dataset to split. \\
\hline
{\em train\+Data} & Matrix to store training data into. \\
\hline
{\em test\+Data} & Matrix to store test data into. \\
\hline
{\em test\+Ratio} & Percentage of dataset to use for test set (between 0 and 1). \\
\hline
{\em shuffle\+Data} & If true, the sample order is shuffled; otherwise, each sample is visited in linear order. (Default true). \\
\hline
\end{DoxyParams}


Definition at line 302 of file split\+\_\+data.\+hpp.



References Split\+Helper().

\mbox{\label{namespacemlpack_1_1data_a38ad55a3d28296d823078fe7d0ced9b2}} 
\index{mlpack\+::data@{mlpack\+::data}!Split@{Split}}
\index{Split@{Split}!mlpack\+::data@{mlpack\+::data}}
\subsubsection{Split()\hspace{0.1cm}{\footnotesize\ttfamily [3/8]}}
{\footnotesize\ttfamily std\+::tuple$<$arma\+::\+Mat$<$T$>$, arma\+::\+Mat$<$T$>$, Labels\+Type, Labels\+Type$>$ mlpack\+::data\+::\+Split (\begin{DoxyParamCaption}\item[{const arma\+::\+Mat$<$ T $>$ \&}]{input,  }\item[{const Labels\+Type \&}]{input\+Label,  }\item[{const double}]{test\+Ratio,  }\item[{const bool}]{shuffle\+Data = {\ttfamily true},  }\item[{const bool}]{stratify\+Data = {\ttfamily false} }\end{DoxyParamCaption})}



Given an input dataset and labels, split into a training set and test set. 

Example usage below. This overload returns the split dataset as a std\+::tuple with four elements\+: an arma\+::\+Mat$<$\+T$>$ containing the training data, an arma\+::\+Mat$<$\+T$>$ containing the test data, an arma\+::\+Row$<$\+U$>$ containing the training labels, and an arma\+::\+Row$<$\+U$>$ containing the test labels.


\begin{DoxyCode}
arma::mat input = loadData();
arma::Row<size\_t> label = loadLabel();
\textcolor{keyword}{auto} splitResult = Split(input, label, 0.2);
\end{DoxyCode}



\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Type of the elements of the input matrix. \\
\hline
{\em Labels\+Type} & Type of input labels. It can be arma\+::\+Mat, arma\+::\+Row, arma\+::\+Cube or arma\+::\+Sp\+Mat. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em input} & Input dataset to split. \\
\hline
{\em input\+Label} & Input labels to split. \\
\hline
{\em test\+Ratio} & Percentage of dataset to use for test set (between 0 and 1). \\
\hline
{\em shuffle\+Data} & If true, the sample order is shuffled; otherwise, each sample is visited in linear order. (Default true). \\
\hline
{\em stratify\+Data} & If true, the train and test splits are stratified so that the ratio of each class in the training and test sets is the same as in the original dataset. Expects labels to be of type arma\+::\+Row$<$$>$ or arma\+::\+Col$<$$>$. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
std\+::tuple containing train\+Data (arma\+::\+Mat$<$\+T$>$), test\+Data (arma\+::\+Mat$<$\+T$>$), train\+Label (arma\+::\+Row$<$\+U$>$), and test\+Label (arma\+::\+Row$<$\+U$>$). 
\end{DoxyReturn}


Definition at line 351 of file split\+\_\+data.\+hpp.



References Split(), and Stratified\+Split().

\mbox{\label{namespacemlpack_1_1data_a91a5ecc1018b88a9cbe745e67d1e8672}} 
\index{mlpack\+::data@{mlpack\+::data}!Split@{Split}}
\index{Split@{Split}!mlpack\+::data@{mlpack\+::data}}
\subsubsection{Split()\hspace{0.1cm}{\footnotesize\ttfamily [4/8]}}
{\footnotesize\ttfamily std\+::tuple$<$arma\+::\+Mat$<$T$>$, arma\+::\+Mat$<$T$>$ $>$ mlpack\+::data\+::\+Split (\begin{DoxyParamCaption}\item[{const arma\+::\+Mat$<$ T $>$ \&}]{input,  }\item[{const double}]{test\+Ratio,  }\item[{const bool}]{shuffle\+Data = {\ttfamily true} }\end{DoxyParamCaption})}



Given an input dataset, split into a training set and test set. 

Example usage below. This overload returns the split dataset as a std\+::tuple with two elements\+: an arma\+::\+Mat$<$\+T$>$ containing the training data and an arma\+::\+Mat$<$\+T$>$ containing the test data.


\begin{DoxyCode}
arma::mat input = loadData();
\textcolor{keyword}{auto} splitResult = Split(input, 0.2);
\end{DoxyCode}



\begin{DoxyParams}{Parameters}
{\em input} & Input dataset to split. \\
\hline
{\em test\+Ratio} & Percentage of dataset to use for test set (between 0 and 1). \\
\hline
{\em shuffle\+Data} & If true, the sample order is shuffled; otherwise, each sample is visited in linear order. (Default true). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
std\+::tuple containing train\+Data (arma\+::\+Mat$<$\+T$>$) and test\+Data (arma\+::\+Mat$<$\+T$>$). 
\end{DoxyReturn}


Definition at line 399 of file split\+\_\+data.\+hpp.



References Split().

\mbox{\label{namespacemlpack_1_1data_a7bca254ee313ff590e7d1bcada13d72a}} 
\index{mlpack\+::data@{mlpack\+::data}!Split@{Split}}
\index{Split@{Split}!mlpack\+::data@{mlpack\+::data}}
\subsubsection{Split()\hspace{0.1cm}{\footnotesize\ttfamily [5/8]}}
{\footnotesize\ttfamily void mlpack\+::data\+::\+Split (\begin{DoxyParamCaption}\item[{const Field\+Type \&}]{input,  }\item[{const arma\+::field$<$ T $>$ \&}]{input\+Label,  }\item[{Field\+Type \&}]{train\+Data,  }\item[{arma\+::field$<$ T $>$ \&}]{train\+Label,  }\item[{Field\+Type \&}]{test\+Data,  }\item[{arma\+::field$<$ T $>$ \&}]{test\+Label,  }\item[{const double}]{test\+Ratio,  }\item[{const bool}]{shuffle\+Data = {\ttfamily true} }\end{DoxyParamCaption})}



Given an input dataset and labels, split into a training set and test set. 

Example usage below. This overload places the split dataset into the four output parameters given (train\+Data, test\+Data, train\+Label, and test\+Label).

The input dataset must be of type arma\+::field. It should have the shape -\/ (n\+\_\+rows = 1, n\+\_\+cols = Number of samples, n\+\_\+slices = 1).

N\+O\+TE\+: Here Field\+Type could be arma\+::field$<$arma\+::mat$>$ or arma\+::field$<$arma\+::vec$>$.


\begin{DoxyCode}
arma::field<arma::mat> input = loadData();
arma::field<arma::vec> label = loadLabel();
arma::field<arma::mat> trainData;
arma::field<arma::mat> testData;
arma::field<arma::vec> trainLabel;
arma::field<arma::vec> testLabel;
math::RandomSeed(100); \textcolor{comment}{// Set the seed if you like.}

\textcolor{comment}{// Split the dataset into a training and test set, with 30% of the data being}
\textcolor{comment}{// held out for the test set.}
Split(input, label, trainData, testData, trainLabel, testLabel, 0.3);
\end{DoxyCode}



\begin{DoxyParams}{Parameters}
{\em input} & Input dataset to split. \\
\hline
{\em input\+Label} & Input labels to split. \\
\hline
{\em train\+Data} & Field\+Type to store training data into. \\
\hline
{\em test\+Data} & Field\+Type test data into. \\
\hline
{\em train\+Label} & Field vector to store training labels into. \\
\hline
{\em test\+Label} & Field vector to store test labels into. \\
\hline
{\em test\+Ratio} & Percentage of dataset to use for test set (between 0 and 1). \\
\hline
{\em shuffle\+Data} & If true, the sample order is shuffled; otherwise, each sample is visited in linear order. (Default true.) \\
\hline
\end{DoxyParams}


Definition at line 449 of file split\+\_\+data.\+hpp.



References Split\+Helper().

\mbox{\label{namespacemlpack_1_1data_a0baaf8bcdf473761f7c59c9e1577d1f1}} 
\index{mlpack\+::data@{mlpack\+::data}!Split@{Split}}
\index{Split@{Split}!mlpack\+::data@{mlpack\+::data}}
\subsubsection{Split()\hspace{0.1cm}{\footnotesize\ttfamily [6/8]}}
{\footnotesize\ttfamily void mlpack\+::data\+::\+Split (\begin{DoxyParamCaption}\item[{const Field\+Type \&}]{input,  }\item[{Field\+Type \&}]{train\+Data,  }\item[{Field\+Type \&}]{test\+Data,  }\item[{const double}]{test\+Ratio,  }\item[{const bool}]{shuffle\+Data = {\ttfamily true} }\end{DoxyParamCaption})}



Given an input dataset, split into a training set and test set. 

Example usage below. This overload places the split dataset into the two output parameters given (train\+Data, test\+Data).

The input dataset must be of type arma\+::field. It should have the shape -\/ (n\+\_\+rows = 1, n\+\_\+cols = Number of samples, n\+\_\+slices = 1)

N\+O\+TE\+: Here Field\+Type could be arma\+::field$<$arma\+::mat$>$ or arma\+::field$<$arma\+::vec$>$


\begin{DoxyCode}
arma::field<arma::mat> input = loadData();
arma::field<arma::mat> trainData;
arma::field<arma::mat> testData;
math::RandomSeed(100); \textcolor{comment}{// Set the seed if you like.}

\textcolor{comment}{// Split the dataset into a training and test set, with 30% of the data being}
\textcolor{comment}{// held out for the test set.}
Split(input, trainData, testData, 0.3);
\end{DoxyCode}



\begin{DoxyParams}{Parameters}
{\em input} & Input dataset to split. \\
\hline
{\em train\+Data} & Field\+Type to store training data into. \\
\hline
{\em test\+Data} & Field\+Type test data into. \\
\hline
{\em test\+Ratio} & Percentage of dataset to use for test set (between 0 and 1). \\
\hline
{\em shuffle\+Data} & If true, the sample order is shuffled; otherwise, each sample is visited in linear order. (Default true). \\
\hline
\end{DoxyParams}


Definition at line 504 of file split\+\_\+data.\+hpp.



References Split\+Helper().

\mbox{\label{namespacemlpack_1_1data_a744850e5ad47df5e0af6f5845009a4d2}} 
\index{mlpack\+::data@{mlpack\+::data}!Split@{Split}}
\index{Split@{Split}!mlpack\+::data@{mlpack\+::data}}
\subsubsection{Split()\hspace{0.1cm}{\footnotesize\ttfamily [7/8]}}
{\footnotesize\ttfamily std\+::tuple$<$Field\+Type, Field\+Type, arma\+::field$<$T$>$, arma\+::field$<$T$>$ $>$ mlpack\+::data\+::\+Split (\begin{DoxyParamCaption}\item[{const Field\+Type \&}]{input,  }\item[{const arma\+::field$<$ T $>$ \&}]{input\+Label,  }\item[{const double}]{test\+Ratio,  }\item[{const bool}]{shuffle\+Data = {\ttfamily true} }\end{DoxyParamCaption})}



Given an input dataset and labels, split into a training set and test set. 

Example usage below. This overload returns the split dataset as a std\+::tuple with four elements\+: an Field\+Type containing the training data, an Field\+Type containing the test data, an arma\+::field$<$arma\+::vec$>$ containing the training labels, and an arma\+::field$<$arma\+::vec$>$ containing the test labels.

The input dataset must be of type arma\+::field. It should have the shape -\/ (n\+\_\+rows = 1, n\+\_\+cols = Number of samples, n\+\_\+slices = 1)

N\+O\+TE\+: Here Field\+Type could be arma\+::field$<$arma\+::mat$>$ or arma\+::field$<$arma\+::vec$>$


\begin{DoxyCode}
arma::field<arma::mat> input = loadData();
arma::field<arma::vec> label = loadLabel();
\textcolor{keyword}{auto} splitResult = Split(input, label, 0.2);
\end{DoxyCode}



\begin{DoxyParams}{Parameters}
{\em input} & Input dataset to split. \\
\hline
{\em input\+Label} & Input labels to split. \\
\hline
{\em test\+Ratio} & Percentage of dataset to use for test set (between 0 and 1). \\
\hline
{\em shuffle\+Data} & If true, the sample order is shuffled; otherwise, each sample is visited in linear order. (Default true). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
std\+::tuple containing train\+Data (Field\+Type), test\+Data (Field\+Type), train\+Label (arma\+::field$<$arma\+::vec$>$), and test\+Label (arma\+::field$<$arma\+::vec$>$). 
\end{DoxyReturn}


Definition at line 554 of file split\+\_\+data.\+hpp.



References Split().

\mbox{\label{namespacemlpack_1_1data_af9b163f42a48fdc8993c2165f9089494}} 
\index{mlpack\+::data@{mlpack\+::data}!Split@{Split}}
\index{Split@{Split}!mlpack\+::data@{mlpack\+::data}}
\subsubsection{Split()\hspace{0.1cm}{\footnotesize\ttfamily [8/8]}}
{\footnotesize\ttfamily std\+::tuple$<$Field\+Type, Field\+Type$>$ mlpack\+::data\+::\+Split (\begin{DoxyParamCaption}\item[{const Field\+Type \&}]{input,  }\item[{const double}]{test\+Ratio,  }\item[{const bool}]{shuffle\+Data = {\ttfamily true} }\end{DoxyParamCaption})}



Given an input dataset, split into a training set and test set. 

Example usage below. This overload returns the split dataset as a std\+::tuple with two elements\+: an Field\+Type containing the training data and an Field\+Type containing the test data.

The input dataset must be of type arma\+::field. It should have the shape -\/ (n\+\_\+rows = 1, n\+\_\+cols = Number of samples, n\+\_\+slices = 1)

N\+O\+TE\+: Here Field\+Type could be arma\+::field$<$arma\+::mat$>$ or arma\+::field$<$arma\+::vec$>$


\begin{DoxyCode}
arma::field<arma::mat> input = loadData();
\textcolor{keyword}{auto} splitResult = Split(input, 0.2);
\end{DoxyCode}



\begin{DoxyParams}{Parameters}
{\em input} & Input dataset to split. \\
\hline
{\em test\+Ratio} & Percentage of dataset to use for test set (between 0 and 1). \\
\hline
{\em shuffle\+Data} & If true, the sample order is shuffled; otherwise, each sample is visited in linear order. (Default true). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
std\+::tuple containing train\+Data (Field\+Type) and test\+Data (Field\+Type). 
\end{DoxyReturn}


Definition at line 601 of file split\+\_\+data.\+hpp.



References Split().

\mbox{\label{namespacemlpack_1_1data_aa8ba4ec838f0ac7dd92c69b6c60dfb22}} 
\index{mlpack\+::data@{mlpack\+::data}!Split\+Helper@{Split\+Helper}}
\index{Split\+Helper@{Split\+Helper}!mlpack\+::data@{mlpack\+::data}}
\subsubsection{Split\+Helper()}
{\footnotesize\ttfamily void mlpack\+::data\+::\+Split\+Helper (\begin{DoxyParamCaption}\item[{const Input\+Type \&}]{input,  }\item[{Input\+Type \&}]{train,  }\item[{Input\+Type \&}]{test,  }\item[{const double}]{test\+Ratio,  }\item[{const arma\+::uvec \&}]{order = {\ttfamily arma\+:\+:uvec()} }\end{DoxyParamCaption})}



This helper function splits any {\ttfamily input} data into training and testing parts. 

In order to shuffle the input data before spliting, an array of shuffled indices of the input data is passed in the form of argument {\ttfamily order}. 

Definition at line 27 of file split\+\_\+data.\+hpp.



Referenced by Split().

\mbox{\label{namespacemlpack_1_1data_ae5943effbe5980ae3af45b5e62240fc8}} 
\index{mlpack\+::data@{mlpack\+::data}!Stratified\+Split@{Stratified\+Split}}
\index{Stratified\+Split@{Stratified\+Split}!mlpack\+::data@{mlpack\+::data}}
\subsubsection{Stratified\+Split()}
{\footnotesize\ttfamily void mlpack\+::data\+::\+Stratified\+Split (\begin{DoxyParamCaption}\item[{const arma\+::\+Mat$<$ T $>$ \&}]{input,  }\item[{const Labels\+Type \&}]{input\+Label,  }\item[{arma\+::\+Mat$<$ T $>$ \&}]{train\+Data,  }\item[{arma\+::\+Mat$<$ T $>$ \&}]{test\+Data,  }\item[{Labels\+Type \&}]{train\+Label,  }\item[{Labels\+Type \&}]{test\+Label,  }\item[{const double}]{test\+Ratio,  }\item[{const bool}]{shuffle\+Data = {\ttfamily true} }\end{DoxyParamCaption})}



Given an input dataset and labels, stratify into a training set and test set. 

It is recommended to have the input labels between the range [0, n) where n is the number of different labels. The \doxyref{Normalize\+Labels()}{p.}{namespacemlpack_1_1data_a664b3fa5243889e2aed47ee750f840ed} function in \doxyref{mlpack\+::data}{p.}{namespacemlpack_1_1data} can be used for this. Expects labels to be of type arma\+::\+Row$<$$>$ or arma\+::\+Col$<$$>$. Throws a runtime error if this is not the case. Example usage below. This overload places the stratified dataset into the four output parameters given (train\+Data, test\+Data, train\+Label, and test\+Label).


\begin{DoxyCode}
arma::mat input = loadData();
arma::Row<size\_t> label = loadLabel();
arma::mat trainData;
arma::mat testData;
arma::Row<size\_t> trainLabel;
arma::Row<size\_t> testLabel;
math::RandomSeed(100); \textcolor{comment}{// Set the seed if you like.}

\textcolor{comment}{// Stratify the dataset into a training and test set, with 30% of the data}
\textcolor{comment}{// being held out for the test set.}
StratifiedSplit(input, label, trainData,
                testData, trainLabel, testLabel, 0.3);
\end{DoxyCode}



\begin{DoxyParams}{Parameters}
{\em input} & Input dataset to stratify. \\
\hline
{\em input\+Label} & Input labels to stratify. \\
\hline
{\em train\+Data} & Matrix to store training data into. \\
\hline
{\em test\+Data} & Matrix to store test data into. \\
\hline
{\em train\+Label} & Vector to store training labels into. \\
\hline
{\em test\+Label} & Vector to store test labels into. \\
\hline
{\em test\+Ratio} & Percentage of dataset to use for test set (between 0 and 1). \\
\hline
{\em shuffle\+Data} & If true, the sample order is shuffled; otherwise, each sample is visited in linear order. (Default true.) \\
\hline
\end{DoxyParams}
Basic idea\+: Let us say we have to stratify a dataset based on labels\+: 0 0 0 0 0 (5 0s) 1 1 1 1 1 1 1 1 1 1 1 (11 1s)

Let our test ratio be 0.\+2. Then, the number of 0 labels in our test set = floor(5 $\ast$ 0.\+2) = 1. The number of 1 labels in our test set = floor(11 $\ast$ 0.\+2) = 2.

In our first pass over the dataset, We visit each label and keep count of each label in our \textquotesingle{}label\+Counts\textquotesingle{} uvec.

We then take a second pass over the dataset. We now maintain an additional uvec \textquotesingle{}test\+Label\+Counts\textquotesingle{} to hold the label counts of our test set.

In this pass, when we encounter a label we check the \textquotesingle{}test\+Label\+Counts\textquotesingle{} uvec for the count of this label in the test set. If this count is less than the required number of labels in the test set, we add the data to the test set and increment the label count in the uvec. If this count is equal to or more than the required count in the test set, we add this data to the train set.

Based on the above steps, we get the following labels in the split set\+: Train set (4 0s, 9 1s) 0 0 0 0 1 1 1 1 1 1 1 1 1

Test set (1 0s, 2 1s) 0 1 1

Definition at line 103 of file split\+\_\+data.\+hpp.



Referenced by Split().

