\section{N\+M\+F\+Multiplicative\+Distance\+Update Class Reference}
\label{classmlpack_1_1amf_1_1NMFMultiplicativeDistanceUpdate}\index{N\+M\+F\+Multiplicative\+Distance\+Update@{N\+M\+F\+Multiplicative\+Distance\+Update}}


The multiplicative distance update rules for matrices W and H.  


\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\textbf{ N\+M\+F\+Multiplicative\+Distance\+Update} ()
\item 
{\footnotesize template$<$typename Mat\+Type $>$ }\\void \textbf{ Initialize} (const Mat\+Type \&, const size\+\_\+t)
\begin{DoxyCompactList}\small\item\em Initialize the factorization. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Archive $>$ }\\void \textbf{ serialize} (Archive \&, const uint32\+\_\+t)
\begin{DoxyCompactList}\small\item\em Serialize the object (in this case, there is nothing to serialize). \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename Mat\+Type $>$ }\\static void \textbf{ H\+Update} (const Mat\+Type \&V, const arma\+::mat \&W, arma\+::mat \&H)
\begin{DoxyCompactList}\small\item\em The update rule for the encoding matrix H. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Mat\+Type $>$ }\\static void \textbf{ W\+Update} (const Mat\+Type \&V, arma\+::mat \&W, const arma\+::mat \&H)
\begin{DoxyCompactList}\small\item\em The update rule for the basis matrix W. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
The multiplicative distance update rules for matrices W and H. 

This follows a method described in the following paper\+:


\begin{DoxyCode}
@inproceedings\{lee2001algorithms,
  title=\{Algorithms \textcolor{keywordflow}{for} non-negative matrix factorization\},
  author=\{Lee, D.D. and Seung, H.S.\},
  booktitle=\{Advances in Neural Information Processing Systems 13
      (NIPS 2000)\},
  pages=\{556--562\},
  year=\{2001\}
\}
\end{DoxyCode}


This is a multiplicative rule that ensures that the Frobenius norm $ \sqrt{\sum_i \sum_j(V-WH)^2} $ is non-\/increasing between subsequent iterations. Both of the update rules for W and H are defined in this file. 

Definition at line 39 of file nmf\+\_\+mult\+\_\+dist.\+hpp.



\subsection{Constructor \& Destructor Documentation}
\mbox{\label{classmlpack_1_1amf_1_1NMFMultiplicativeDistanceUpdate_ab617f348654db931f85c1c60066d8f4d}} 
\index{mlpack\+::amf\+::\+N\+M\+F\+Multiplicative\+Distance\+Update@{mlpack\+::amf\+::\+N\+M\+F\+Multiplicative\+Distance\+Update}!N\+M\+F\+Multiplicative\+Distance\+Update@{N\+M\+F\+Multiplicative\+Distance\+Update}}
\index{N\+M\+F\+Multiplicative\+Distance\+Update@{N\+M\+F\+Multiplicative\+Distance\+Update}!mlpack\+::amf\+::\+N\+M\+F\+Multiplicative\+Distance\+Update@{mlpack\+::amf\+::\+N\+M\+F\+Multiplicative\+Distance\+Update}}
\subsubsection{N\+M\+F\+Multiplicative\+Distance\+Update()}
{\footnotesize\ttfamily \textbf{ N\+M\+F\+Multiplicative\+Distance\+Update} (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line 43 of file nmf\+\_\+mult\+\_\+dist.\+hpp.



\subsection{Member Function Documentation}
\mbox{\label{classmlpack_1_1amf_1_1NMFMultiplicativeDistanceUpdate_ad2a433d7e149001f0f44caa8967d20a6}} 
\index{mlpack\+::amf\+::\+N\+M\+F\+Multiplicative\+Distance\+Update@{mlpack\+::amf\+::\+N\+M\+F\+Multiplicative\+Distance\+Update}!H\+Update@{H\+Update}}
\index{H\+Update@{H\+Update}!mlpack\+::amf\+::\+N\+M\+F\+Multiplicative\+Distance\+Update@{mlpack\+::amf\+::\+N\+M\+F\+Multiplicative\+Distance\+Update}}
\subsubsection{H\+Update()}
{\footnotesize\ttfamily static void H\+Update (\begin{DoxyParamCaption}\item[{const Mat\+Type \&}]{V,  }\item[{const arma\+::mat \&}]{W,  }\item[{arma\+::mat \&}]{H }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}



The update rule for the encoding matrix H. 

The formula used is

\[ H_{a\mu} \leftarrow H_{a\mu} \frac{(W^T V)_{a\mu}}{(W^T WH)_{a\mu}} \]

The function takes in all the matrices and only changes the value of the H matrix.


\begin{DoxyParams}{Parameters}
{\em V} & Input matrix to be factorized. \\
\hline
{\em W} & Basis matrix. \\
\hline
{\em H} & Encoding matrix to be updated. \\
\hline
\end{DoxyParams}


Definition at line 92 of file nmf\+\_\+mult\+\_\+dist.\+hpp.

\mbox{\label{classmlpack_1_1amf_1_1NMFMultiplicativeDistanceUpdate_aac5af164b10635addd7ff7bb934a4db3}} 
\index{mlpack\+::amf\+::\+N\+M\+F\+Multiplicative\+Distance\+Update@{mlpack\+::amf\+::\+N\+M\+F\+Multiplicative\+Distance\+Update}!Initialize@{Initialize}}
\index{Initialize@{Initialize}!mlpack\+::amf\+::\+N\+M\+F\+Multiplicative\+Distance\+Update@{mlpack\+::amf\+::\+N\+M\+F\+Multiplicative\+Distance\+Update}}
\subsubsection{Initialize()}
{\footnotesize\ttfamily void Initialize (\begin{DoxyParamCaption}\item[{const Mat\+Type \&}]{,  }\item[{const size\+\_\+t}]{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Initialize the factorization. 

These update rules hold no information, so the input parameters are ignored. 

Definition at line 50 of file nmf\+\_\+mult\+\_\+dist.\+hpp.

\mbox{\label{classmlpack_1_1amf_1_1NMFMultiplicativeDistanceUpdate_aa2ccb5a0533a6ba0abe6dfc1f98fbafb}} 
\index{mlpack\+::amf\+::\+N\+M\+F\+Multiplicative\+Distance\+Update@{mlpack\+::amf\+::\+N\+M\+F\+Multiplicative\+Distance\+Update}!serialize@{serialize}}
\index{serialize@{serialize}!mlpack\+::amf\+::\+N\+M\+F\+Multiplicative\+Distance\+Update@{mlpack\+::amf\+::\+N\+M\+F\+Multiplicative\+Distance\+Update}}
\subsubsection{serialize()}
{\footnotesize\ttfamily void serialize (\begin{DoxyParamCaption}\item[{Archive \&}]{,  }\item[{const uint32\+\_\+t}]{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Serialize the object (in this case, there is nothing to serialize). 



Definition at line 101 of file nmf\+\_\+mult\+\_\+dist.\+hpp.

\mbox{\label{classmlpack_1_1amf_1_1NMFMultiplicativeDistanceUpdate_a79b17bfdd69326a4f9f7d17c698ee6af}} 
\index{mlpack\+::amf\+::\+N\+M\+F\+Multiplicative\+Distance\+Update@{mlpack\+::amf\+::\+N\+M\+F\+Multiplicative\+Distance\+Update}!W\+Update@{W\+Update}}
\index{W\+Update@{W\+Update}!mlpack\+::amf\+::\+N\+M\+F\+Multiplicative\+Distance\+Update@{mlpack\+::amf\+::\+N\+M\+F\+Multiplicative\+Distance\+Update}}
\subsubsection{W\+Update()}
{\footnotesize\ttfamily static void W\+Update (\begin{DoxyParamCaption}\item[{const Mat\+Type \&}]{V,  }\item[{arma\+::mat \&}]{W,  }\item[{const arma\+::mat \&}]{H }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}



The update rule for the basis matrix W. 

The formula used isa

\[ W_{ia} \leftarrow W_{ia} \frac{(VH^T)_{ia}}{(WHH^T)_{ia}} \]

The function takes in all the matrices and only changes the value of the W matrix.


\begin{DoxyParams}{Parameters}
{\em V} & Input matrix to be factorized. \\
\hline
{\em W} & Basis matrix to be updated. \\
\hline
{\em H} & Encoding matrix. \\
\hline
\end{DoxyParams}


Definition at line 70 of file nmf\+\_\+mult\+\_\+dist.\+hpp.



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
/home/aakash/mlpack/src/mlpack/methods/amf/update\+\_\+rules/\textbf{ nmf\+\_\+mult\+\_\+dist.\+hpp}\end{DoxyCompactItemize}
