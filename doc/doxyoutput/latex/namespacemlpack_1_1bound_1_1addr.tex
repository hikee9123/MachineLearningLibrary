\section{mlpack\+:\+:bound\+:\+:addr Namespace Reference}
\label{namespacemlpack_1_1bound_1_1addr}\index{mlpack\+::bound\+::addr@{mlpack\+::bound\+::addr}}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename Address\+Type , typename Vec\+Type $>$ }\\void \textbf{ Address\+To\+Point} (Vec\+Type \&point, const Address\+Type \&address)
\begin{DoxyCompactList}\small\item\em Translate the address to the point. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Address\+Type1 , typename Address\+Type2 $>$ }\\int \textbf{ Compare\+Addresses} (const Address\+Type1 \&addr1, const Address\+Type2 \&addr2)
\begin{DoxyCompactList}\small\item\em Compare two addresses. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Address\+Type1 , typename Address\+Type2 , typename Address\+Type3 $>$ }\\bool \textbf{ Contains} (const Address\+Type1 \&address, const Address\+Type2 \&lo\+Bound, const Address\+Type3 \&hi\+Bound)
\begin{DoxyCompactList}\small\item\em Returns true if an address is contained between two other addresses. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Address\+Type , typename Vec\+Type $>$ }\\void \textbf{ Point\+To\+Address} (Address\+Type \&address, const Vec\+Type \&point)
\begin{DoxyCompactList}\small\item\em Calculate the address of a point. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Function Documentation}
\mbox{\label{namespacemlpack_1_1bound_1_1addr_a55e57f732bc2f6f587b58e59d6fb918a}} 
\index{mlpack\+::bound\+::addr@{mlpack\+::bound\+::addr}!Address\+To\+Point@{Address\+To\+Point}}
\index{Address\+To\+Point@{Address\+To\+Point}!mlpack\+::bound\+::addr@{mlpack\+::bound\+::addr}}
\subsubsection{Address\+To\+Point()}
{\footnotesize\ttfamily void mlpack\+::bound\+::addr\+::\+Address\+To\+Point (\begin{DoxyParamCaption}\item[{Vec\+Type \&}]{point,  }\item[{const Address\+Type \&}]{address }\end{DoxyParamCaption})}



Translate the address to the point. 

Be careful, the point and the address variables should be equal-\/sized and the type of the address should correspond to the type of the vector.

The function makes the backward transform to the function above.


\begin{DoxyParams}{Parameters}
{\em address} & An address to translate. \\
\hline
{\em point} & The point that corresponds to the address. \\
\hline
\end{DoxyParams}


Definition at line 153 of file address.\+hpp.

\mbox{\label{namespacemlpack_1_1bound_1_1addr_ad39b49870fa074ad011a4d4c0ee93665}} 
\index{mlpack\+::bound\+::addr@{mlpack\+::bound\+::addr}!Compare\+Addresses@{Compare\+Addresses}}
\index{Compare\+Addresses@{Compare\+Addresses}!mlpack\+::bound\+::addr@{mlpack\+::bound\+::addr}}
\subsubsection{Compare\+Addresses()}
{\footnotesize\ttfamily int mlpack\+::bound\+::addr\+::\+Compare\+Addresses (\begin{DoxyParamCaption}\item[{const Address\+Type1 \&}]{addr1,  }\item[{const Address\+Type2 \&}]{addr2 }\end{DoxyParamCaption})}



Compare two addresses. 

The function returns 1 if the first address is greater than the second one, -\/1 if the first address is less than the second one, otherwise the function returns 0. 

Definition at line 233 of file address.\+hpp.



Referenced by Contains().

\mbox{\label{namespacemlpack_1_1bound_1_1addr_a64110a8c86f23288f4fef77ff8ac63a4}} 
\index{mlpack\+::bound\+::addr@{mlpack\+::bound\+::addr}!Contains@{Contains}}
\index{Contains@{Contains}!mlpack\+::bound\+::addr@{mlpack\+::bound\+::addr}}
\subsubsection{Contains()}
{\footnotesize\ttfamily bool mlpack\+::bound\+::addr\+::\+Contains (\begin{DoxyParamCaption}\item[{const Address\+Type1 \&}]{address,  }\item[{const Address\+Type2 \&}]{lo\+Bound,  }\item[{const Address\+Type3 \&}]{hi\+Bound }\end{DoxyParamCaption})}



Returns true if an address is contained between two other addresses. 



Definition at line 256 of file address.\+hpp.



References Compare\+Addresses().



Referenced by H\+Rect\+Bound$<$ Metric\+Type $>$\+::\+Metric().

\mbox{\label{namespacemlpack_1_1bound_1_1addr_acfd59826c56bc489ec735101a942eb79}} 
\index{mlpack\+::bound\+::addr@{mlpack\+::bound\+::addr}!Point\+To\+Address@{Point\+To\+Address}}
\index{Point\+To\+Address@{Point\+To\+Address}!mlpack\+::bound\+::addr@{mlpack\+::bound\+::addr}}
\subsubsection{Point\+To\+Address()}
{\footnotesize\ttfamily void mlpack\+::bound\+::addr\+::\+Point\+To\+Address (\begin{DoxyParamCaption}\item[{Address\+Type \&}]{address,  }\item[{const Vec\+Type \&}]{point }\end{DoxyParamCaption})}



Calculate the address of a point. 

Be careful, the point and the address variables should be equal-\/sized and the type of the address should correspond to the type of the vector.

The function maps each floating point coordinate to an equal-\/sized unsigned integer datatype in such a way that the transform preserves the ordering (i.\+e. lower floating point values correspond to lower integers). Thus, the mapping saves the exponent and the mantissa of each floating point value consequently, furthermore the exponent is stored before the mantissa. In the case of negative numbers the resulting integer value should be inverted. In the multi-\/dimensional case, after we transform the representation, we have to interleave the bits of the new representation across all the elements in the address vector.


\begin{DoxyParams}{Parameters}
{\em address} & The resulting address. \\
\hline
{\em point} & The point that is being translated to the address.\\
\hline
\end{DoxyParams}
mlpack is free software; you may redistribute it and/or modify it under the terms of the 3-\/clause B\+SD license. You should have received a copy of the 3-\/clause B\+SD license along with mlpack. If not, see {\tt http\+://www.\+opensource.\+org/licenses/\+B\+S\+D-\/3-\/\+Clause} for more information. 

Definition at line 57 of file address.\+hpp.

