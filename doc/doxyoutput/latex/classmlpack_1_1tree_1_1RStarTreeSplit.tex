\section{R\+Star\+Tree\+Split Class Reference}
\label{classmlpack_1_1tree_1_1RStarTreeSplit}\index{R\+Star\+Tree\+Split@{R\+Star\+Tree\+Split}}


A Rectangle Tree has new points inserted at the bottom.  


\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename Tree\+Type $>$ }\\static void \textbf{ Pick\+Leaf\+Split} (Tree\+Type $\ast$tree, size\+\_\+t \&best\+Axis, size\+\_\+t \&best\+Index)
\begin{DoxyCompactList}\small\item\em Given a node, return the best dimension and the best index to split on. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Tree\+Type $>$ }\\static size\+\_\+t \textbf{ Reinsert\+Points} (Tree\+Type $\ast$tree, std\+::vector$<$ bool $>$ \&relevels)
\begin{DoxyCompactList}\small\item\em Reinsert any points into the tree, if needed. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Tree\+Type $>$ }\\static void \textbf{ Split\+Leaf\+Node} (Tree\+Type $\ast$tree, std\+::vector$<$ bool $>$ \&relevels)
\begin{DoxyCompactList}\small\item\em Split a leaf node using the algorithm described in "The R$\ast$-\/tree\+: An Efficient and Robust Access method for Points and Rectangles. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Tree\+Type $>$ }\\static bool \textbf{ Split\+Non\+Leaf\+Node} (Tree\+Type $\ast$tree, std\+::vector$<$ bool $>$ \&relevels)
\begin{DoxyCompactList}\small\item\em Split a non-\/leaf node using the \char`\"{}default\char`\"{} algorithm. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
A Rectangle Tree has new points inserted at the bottom. 

When these nodes overflow, we split them, moving up the tree and splitting nodes as necessary. 

Definition at line 26 of file r\+\_\+star\+\_\+tree\+\_\+split.\+hpp.



\subsection{Member Function Documentation}
\mbox{\label{classmlpack_1_1tree_1_1RStarTreeSplit_aae7d976de7b1ce1a2dfe3ef1bbd6db42}} 
\index{mlpack\+::tree\+::\+R\+Star\+Tree\+Split@{mlpack\+::tree\+::\+R\+Star\+Tree\+Split}!Pick\+Leaf\+Split@{Pick\+Leaf\+Split}}
\index{Pick\+Leaf\+Split@{Pick\+Leaf\+Split}!mlpack\+::tree\+::\+R\+Star\+Tree\+Split@{mlpack\+::tree\+::\+R\+Star\+Tree\+Split}}
\subsubsection{Pick\+Leaf\+Split()}
{\footnotesize\ttfamily static void Pick\+Leaf\+Split (\begin{DoxyParamCaption}\item[{Tree\+Type $\ast$}]{tree,  }\item[{size\+\_\+t \&}]{best\+Axis,  }\item[{size\+\_\+t \&}]{best\+Index }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Given a node, return the best dimension and the best index to split on. 

\mbox{\label{classmlpack_1_1tree_1_1RStarTreeSplit_a1100e195f158ec58fb680edc0e57b5eb}} 
\index{mlpack\+::tree\+::\+R\+Star\+Tree\+Split@{mlpack\+::tree\+::\+R\+Star\+Tree\+Split}!Reinsert\+Points@{Reinsert\+Points}}
\index{Reinsert\+Points@{Reinsert\+Points}!mlpack\+::tree\+::\+R\+Star\+Tree\+Split@{mlpack\+::tree\+::\+R\+Star\+Tree\+Split}}
\subsubsection{Reinsert\+Points()}
{\footnotesize\ttfamily static size\+\_\+t Reinsert\+Points (\begin{DoxyParamCaption}\item[{Tree\+Type $\ast$}]{tree,  }\item[{std\+::vector$<$ bool $>$ \&}]{relevels }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Reinsert any points into the tree, if needed. 

This returns the number of points reinserted. \mbox{\label{classmlpack_1_1tree_1_1RStarTreeSplit_af73652d9536a1715364bbb0e4a9ba04e}} 
\index{mlpack\+::tree\+::\+R\+Star\+Tree\+Split@{mlpack\+::tree\+::\+R\+Star\+Tree\+Split}!Split\+Leaf\+Node@{Split\+Leaf\+Node}}
\index{Split\+Leaf\+Node@{Split\+Leaf\+Node}!mlpack\+::tree\+::\+R\+Star\+Tree\+Split@{mlpack\+::tree\+::\+R\+Star\+Tree\+Split}}
\subsubsection{Split\+Leaf\+Node()}
{\footnotesize\ttfamily static void Split\+Leaf\+Node (\begin{DoxyParamCaption}\item[{Tree\+Type $\ast$}]{tree,  }\item[{std\+::vector$<$ bool $>$ \&}]{relevels }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Split a leaf node using the algorithm described in "The R$\ast$-\/tree\+: An Efficient and Robust Access method for Points and Rectangles. 

" If necessary, this split will propagate upwards through the tree. \mbox{\label{classmlpack_1_1tree_1_1RStarTreeSplit_a73ff1eaa94449d763847fff1f537922f}} 
\index{mlpack\+::tree\+::\+R\+Star\+Tree\+Split@{mlpack\+::tree\+::\+R\+Star\+Tree\+Split}!Split\+Non\+Leaf\+Node@{Split\+Non\+Leaf\+Node}}
\index{Split\+Non\+Leaf\+Node@{Split\+Non\+Leaf\+Node}!mlpack\+::tree\+::\+R\+Star\+Tree\+Split@{mlpack\+::tree\+::\+R\+Star\+Tree\+Split}}
\subsubsection{Split\+Non\+Leaf\+Node()}
{\footnotesize\ttfamily static bool Split\+Non\+Leaf\+Node (\begin{DoxyParamCaption}\item[{Tree\+Type $\ast$}]{tree,  }\item[{std\+::vector$<$ bool $>$ \&}]{relevels }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Split a non-\/leaf node using the \char`\"{}default\char`\"{} algorithm. 

If this is a root node, the tree increases in depth. 

The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
/home/aakash/mlpack/src/mlpack/core/tree/rectangle\+\_\+tree/\textbf{ r\+\_\+star\+\_\+tree\+\_\+split.\+hpp}\end{DoxyCompactItemize}
