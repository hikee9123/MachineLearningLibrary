\section{Neighbor\+Search\+Rules$<$ Sort\+Policy, Metric\+Type, Tree\+Type $>$ Class Template Reference}
\label{classmlpack_1_1neighbor_1_1NeighborSearchRules}\index{Neighbor\+Search\+Rules$<$ Sort\+Policy, Metric\+Type, Tree\+Type $>$@{Neighbor\+Search\+Rules$<$ Sort\+Policy, Metric\+Type, Tree\+Type $>$}}


The \doxyref{Neighbor\+Search\+Rules}{p.}{classmlpack_1_1neighbor_1_1NeighborSearchRules} class is a template helper class used by \doxyref{Neighbor\+Search}{p.}{classmlpack_1_1neighbor_1_1NeighborSearch} class when performing distance-\/based neighbor searches.  


\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \textbf{ Candidate\+Cmp}
\begin{DoxyCompactList}\small\item\em Compare two candidates based on the distance. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
typedef \textbf{ tree\+::\+Traversal\+Info}$<$ Tree\+Type $>$ \textbf{ Traversal\+Info\+Type}
\begin{DoxyCompactList}\small\item\em Convenience typedef. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\textbf{ Neighbor\+Search\+Rules} (const typename Tree\+Type\+::\+Mat \&\textbf{ reference\+Set}, const typename Tree\+Type\+::\+Mat \&\textbf{ query\+Set}, const size\+\_\+t \textbf{ k}, Metric\+Type \&\textbf{ metric}, const double \textbf{ epsilon}=0, const bool \textbf{ same\+Set}=false)
\begin{DoxyCompactList}\small\item\em Construct the \doxyref{Neighbor\+Search\+Rules}{p.}{classmlpack_1_1neighbor_1_1NeighborSearchRules} object. \end{DoxyCompactList}\item 
double \textbf{ Base\+Case} (const size\+\_\+t query\+Index, const size\+\_\+t reference\+Index)
\begin{DoxyCompactList}\small\item\em Get the distance from the query point to the reference point. \end{DoxyCompactList}\item 
size\+\_\+t \textbf{ Base\+Cases} () const
\begin{DoxyCompactList}\small\item\em Get the number of base cases that have been performed. \end{DoxyCompactList}\item 
size\+\_\+t \& \textbf{ Base\+Cases} ()
\begin{DoxyCompactList}\small\item\em Modify the number of base cases that have been performed. \end{DoxyCompactList}\item 
size\+\_\+t \textbf{ Get\+Best\+Child} (const size\+\_\+t query\+Index, Tree\+Type \&reference\+Node)
\begin{DoxyCompactList}\small\item\em Get the child node with the best score. \end{DoxyCompactList}\item 
size\+\_\+t \textbf{ Get\+Best\+Child} (const Tree\+Type \&query\+Node, Tree\+Type \&reference\+Node)
\begin{DoxyCompactList}\small\item\em Get the child node with the best score. \end{DoxyCompactList}\item 
void \textbf{ Get\+Results} (arma\+::\+Mat$<$ size\+\_\+t $>$ \&neighbors, arma\+::mat \&distances)
\begin{DoxyCompactList}\small\item\em Store the list of candidates for each query point in the given matrices. \end{DoxyCompactList}\item 
size\+\_\+t \textbf{ Minimum\+Base\+Cases} () const
\begin{DoxyCompactList}\small\item\em Get the minimum number of base cases we need to perform to have acceptable results. \end{DoxyCompactList}\item 
double \textbf{ Rescore} (const size\+\_\+t query\+Index, Tree\+Type \&reference\+Node, const double old\+Score) const
\begin{DoxyCompactList}\small\item\em Re-\/evaluate the score for recursion order. \end{DoxyCompactList}\item 
double \textbf{ Rescore} (Tree\+Type \&query\+Node, Tree\+Type \&reference\+Node, const double old\+Score) const
\begin{DoxyCompactList}\small\item\em Re-\/evaluate the score for recursion order. \end{DoxyCompactList}\item 
double \textbf{ Score} (const size\+\_\+t query\+Index, Tree\+Type \&reference\+Node)
\begin{DoxyCompactList}\small\item\em Get the score for recursion order. \end{DoxyCompactList}\item 
double \textbf{ Score} (Tree\+Type \&query\+Node, Tree\+Type \&reference\+Node)
\begin{DoxyCompactList}\small\item\em Get the score for recursion order. \end{DoxyCompactList}\item 
size\+\_\+t \textbf{ Scores} () const
\begin{DoxyCompactList}\small\item\em Get the number of scores that have been performed. \end{DoxyCompactList}\item 
size\+\_\+t \& \textbf{ Scores} ()
\begin{DoxyCompactList}\small\item\em Modify the number of scores that have been performed. \end{DoxyCompactList}\item 
const \textbf{ Traversal\+Info\+Type} \& \textbf{ Traversal\+Info} () const
\begin{DoxyCompactList}\small\item\em Get the traversal info. \end{DoxyCompactList}\item 
\textbf{ Traversal\+Info\+Type} \& \textbf{ Traversal\+Info} ()
\begin{DoxyCompactList}\small\item\em Modify the traversal info. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Types}
\begin{DoxyCompactItemize}
\item 
typedef std\+::pair$<$ double, size\+\_\+t $>$ \textbf{ Candidate}
\begin{DoxyCompactList}\small\item\em Candidate represents a possible candidate neighbor (distance, index). \end{DoxyCompactList}\item 
typedef std\+::priority\+\_\+queue$<$ \textbf{ Candidate}, std\+::vector$<$ \textbf{ Candidate} $>$, \textbf{ Candidate\+Cmp} $>$ \textbf{ Candidate\+List}
\begin{DoxyCompactList}\small\item\em Use a priority queue to represent the list of candidate neighbors. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
double \textbf{ Calculate\+Bound} (Tree\+Type \&query\+Node) const
\begin{DoxyCompactList}\small\item\em Recalculate the bound for a given query node. \end{DoxyCompactList}\item 
void \textbf{ Insert\+Neighbor} (const size\+\_\+t query\+Index, const size\+\_\+t neighbor, const double distance)
\begin{DoxyCompactList}\small\item\em Helper function to insert a point into the list of candidate points. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
size\+\_\+t \textbf{ base\+Cases}
\begin{DoxyCompactList}\small\item\em The number of base cases that have been performed. \end{DoxyCompactList}\item 
std\+::vector$<$ \textbf{ Candidate\+List} $>$ \textbf{ candidates}
\begin{DoxyCompactList}\small\item\em Set of candidate neighbors for each point. \end{DoxyCompactList}\item 
const double \textbf{ epsilon}
\begin{DoxyCompactList}\small\item\em Relative error to be considered in approximate search. \end{DoxyCompactList}\item 
const size\+\_\+t \textbf{ k}
\begin{DoxyCompactList}\small\item\em Number of neighbors to search for. \end{DoxyCompactList}\item 
double \textbf{ last\+Base\+Case}
\begin{DoxyCompactList}\small\item\em The last base case result. \end{DoxyCompactList}\item 
size\+\_\+t \textbf{ last\+Query\+Index}
\begin{DoxyCompactList}\small\item\em The last query point \doxyref{Base\+Case()}{p.}{classmlpack_1_1neighbor_1_1NeighborSearchRules_abac50f780bb5e1bc12dd0d16d850cacc} was called with. \end{DoxyCompactList}\item 
size\+\_\+t \textbf{ last\+Reference\+Index}
\begin{DoxyCompactList}\small\item\em The last reference point \doxyref{Base\+Case()}{p.}{classmlpack_1_1neighbor_1_1NeighborSearchRules_abac50f780bb5e1bc12dd0d16d850cacc} was called with. \end{DoxyCompactList}\item 
Metric\+Type \& \textbf{ metric}
\begin{DoxyCompactList}\small\item\em The instantiated metric. \end{DoxyCompactList}\item 
const Tree\+Type\+::\+Mat \& \textbf{ query\+Set}
\begin{DoxyCompactList}\small\item\em The query set. \end{DoxyCompactList}\item 
const Tree\+Type\+::\+Mat \& \textbf{ reference\+Set}
\begin{DoxyCompactList}\small\item\em The reference set. \end{DoxyCompactList}\item 
bool \textbf{ same\+Set}
\begin{DoxyCompactList}\small\item\em Denotes whether or not the reference and query sets are the same. \end{DoxyCompactList}\item 
size\+\_\+t \textbf{ scores}
\begin{DoxyCompactList}\small\item\em The number of scores that have been performed. \end{DoxyCompactList}\item 
\textbf{ Traversal\+Info\+Type} \textbf{ traversal\+Info}
\begin{DoxyCompactList}\small\item\em Traversal info for the parent combination; this is updated by the traversal before each call to \doxyref{Score()}{p.}{classmlpack_1_1neighbor_1_1NeighborSearchRules_a53d373b7aeee359b0e686f823c602b1c}. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
\subsubsection*{template$<$typename Sort\+Policy, typename Metric\+Type, typename Tree\+Type$>$\newline
class mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules$<$ Sort\+Policy, Metric\+Type, Tree\+Type $>$}

The \doxyref{Neighbor\+Search\+Rules}{p.}{classmlpack_1_1neighbor_1_1NeighborSearchRules} class is a template helper class used by \doxyref{Neighbor\+Search}{p.}{classmlpack_1_1neighbor_1_1NeighborSearch} class when performing distance-\/based neighbor searches. 

For each point in the query dataset, it keeps track of the k neighbors in the reference dataset which have the \textquotesingle{}best\textquotesingle{} distance according to a given sorting policy.


\begin{DoxyTemplParams}{Template Parameters}
{\em Sort\+Policy} & The sort policy for distances. \\
\hline
{\em Metric\+Type} & The metric to use for computation. \\
\hline
{\em Tree\+Type} & The tree type to use; must adhere to the Tree\+Type A\+PI. \\
\hline
\end{DoxyTemplParams}


Definition at line 35 of file neighbor\+\_\+search\+\_\+rules.\+hpp.



\subsection{Member Typedef Documentation}
\mbox{\label{classmlpack_1_1neighbor_1_1NeighborSearchRules_a25f2752ae2dd3aa1e6b36257252e9c63}} 
\index{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules@{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules}!Candidate@{Candidate}}
\index{Candidate@{Candidate}!mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules@{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules}}
\subsubsection{Candidate}
{\footnotesize\ttfamily typedef std\+::pair$<$double, size\+\_\+t$>$ \textbf{ Candidate}\hspace{0.3cm}{\ttfamily [protected]}}



Candidate represents a possible candidate neighbor (distance, index). 



Definition at line 172 of file neighbor\+\_\+search\+\_\+rules.\+hpp.

\mbox{\label{classmlpack_1_1neighbor_1_1NeighborSearchRules_a971deda91e33f8ac7c017c8caab84593}} 
\index{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules@{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules}!Candidate\+List@{Candidate\+List}}
\index{Candidate\+List@{Candidate\+List}!mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules@{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules}}
\subsubsection{Candidate\+List}
{\footnotesize\ttfamily typedef std\+::priority\+\_\+queue$<$\textbf{ Candidate}, std\+::vector$<$\textbf{ Candidate}$>$, \textbf{ Candidate\+Cmp}$>$ \textbf{ Candidate\+List}\hspace{0.3cm}{\ttfamily [protected]}}



Use a priority queue to represent the list of candidate neighbors. 



Definition at line 184 of file neighbor\+\_\+search\+\_\+rules.\+hpp.

\mbox{\label{classmlpack_1_1neighbor_1_1NeighborSearchRules_ab5f079db10d0a6813eefeb1115e894cb}} 
\index{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules@{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules}!Traversal\+Info\+Type@{Traversal\+Info\+Type}}
\index{Traversal\+Info\+Type@{Traversal\+Info\+Type}!mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules@{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules}}
\subsubsection{Traversal\+Info\+Type}
{\footnotesize\ttfamily typedef \textbf{ tree\+::\+Traversal\+Info}$<$Tree\+Type$>$ \textbf{ Traversal\+Info\+Type}}



Convenience typedef. 



Definition at line 153 of file neighbor\+\_\+search\+\_\+rules.\+hpp.



\subsection{Constructor \& Destructor Documentation}
\mbox{\label{classmlpack_1_1neighbor_1_1NeighborSearchRules_a7557d10b0de13c95132f2f73697a4e17}} 
\index{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules@{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules}!Neighbor\+Search\+Rules@{Neighbor\+Search\+Rules}}
\index{Neighbor\+Search\+Rules@{Neighbor\+Search\+Rules}!mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules@{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules}}
\subsubsection{Neighbor\+Search\+Rules()}
{\footnotesize\ttfamily \textbf{ Neighbor\+Search\+Rules} (\begin{DoxyParamCaption}\item[{const typename Tree\+Type\+::\+Mat \&}]{reference\+Set,  }\item[{const typename Tree\+Type\+::\+Mat \&}]{query\+Set,  }\item[{const size\+\_\+t}]{k,  }\item[{Metric\+Type \&}]{metric,  }\item[{const double}]{epsilon = {\ttfamily 0},  }\item[{const bool}]{same\+Set = {\ttfamily false} }\end{DoxyParamCaption})}



Construct the \doxyref{Neighbor\+Search\+Rules}{p.}{classmlpack_1_1neighbor_1_1NeighborSearchRules} object. 

This is usually done from within the \doxyref{Neighbor\+Search}{p.}{classmlpack_1_1neighbor_1_1NeighborSearch} class at search time.


\begin{DoxyParams}{Parameters}
{\em reference\+Set} & Set of reference data. \\
\hline
{\em query\+Set} & Set of query data. \\
\hline
{\em k} & Number of neighbors to search for. \\
\hline
{\em metric} & Instantiated metric. \\
\hline
{\em epsilon} & Relative approximate error. \\
\hline
{\em same\+Set} & If true, the query and reference set are taken to be the same, and a query point will not return itself in the results. \\
\hline
\end{DoxyParams}


\subsection{Member Function Documentation}
\mbox{\label{classmlpack_1_1neighbor_1_1NeighborSearchRules_abac50f780bb5e1bc12dd0d16d850cacc}} 
\index{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules@{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules}!Base\+Case@{Base\+Case}}
\index{Base\+Case@{Base\+Case}!mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules@{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules}}
\subsubsection{Base\+Case()}
{\footnotesize\ttfamily double Base\+Case (\begin{DoxyParamCaption}\item[{const size\+\_\+t}]{query\+Index,  }\item[{const size\+\_\+t}]{reference\+Index }\end{DoxyParamCaption})}



Get the distance from the query point to the reference point. 

This will update the list of candidates with the new point if appropriate and will track the number of base cases (number of points evaluated).


\begin{DoxyParams}{Parameters}
{\em query\+Index} & Index of query point. \\
\hline
{\em reference\+Index} & Index of reference point. \\
\hline
\end{DoxyParams}
\mbox{\label{classmlpack_1_1neighbor_1_1NeighborSearchRules_a3f4bd5d0aa64ea090796725f7755287d}} 
\index{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules@{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules}!Base\+Cases@{Base\+Cases}}
\index{Base\+Cases@{Base\+Cases}!mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules@{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules}}
\subsubsection{Base\+Cases()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily size\+\_\+t Base\+Cases (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Get the number of base cases that have been performed. 



Definition at line 143 of file neighbor\+\_\+search\+\_\+rules.\+hpp.



References Neighbor\+Search\+Rules$<$ Sort\+Policy, Metric\+Type, Tree\+Type $>$\+::base\+Cases.

\mbox{\label{classmlpack_1_1neighbor_1_1NeighborSearchRules_ab93e60b3671ebddbe95a890f1e1b2768}} 
\index{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules@{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules}!Base\+Cases@{Base\+Cases}}
\index{Base\+Cases@{Base\+Cases}!mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules@{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules}}
\subsubsection{Base\+Cases()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily size\+\_\+t\& Base\+Cases (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Modify the number of base cases that have been performed. 



Definition at line 145 of file neighbor\+\_\+search\+\_\+rules.\+hpp.



References Neighbor\+Search\+Rules$<$ Sort\+Policy, Metric\+Type, Tree\+Type $>$\+::base\+Cases.

\mbox{\label{classmlpack_1_1neighbor_1_1NeighborSearchRules_aa8ed73a529bc1e6bd8c49c30f7e93462}} 
\index{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules@{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules}!Calculate\+Bound@{Calculate\+Bound}}
\index{Calculate\+Bound@{Calculate\+Bound}!mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules@{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules}}
\subsubsection{Calculate\+Bound()}
{\footnotesize\ttfamily double Calculate\+Bound (\begin{DoxyParamCaption}\item[{Tree\+Type \&}]{query\+Node }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [protected]}}



Recalculate the bound for a given query node. 

\mbox{\label{classmlpack_1_1neighbor_1_1NeighborSearchRules_a2c457831ca0a541db042ec68a235a8d5}} 
\index{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules@{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules}!Get\+Best\+Child@{Get\+Best\+Child}}
\index{Get\+Best\+Child@{Get\+Best\+Child}!mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules@{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules}}
\subsubsection{Get\+Best\+Child()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily size\+\_\+t Get\+Best\+Child (\begin{DoxyParamCaption}\item[{const size\+\_\+t}]{query\+Index,  }\item[{Tree\+Type \&}]{reference\+Node }\end{DoxyParamCaption})}



Get the child node with the best score. 


\begin{DoxyParams}{Parameters}
{\em query\+Index} & Index of query point. \\
\hline
{\em reference\+Node} & Candidate node to be recursed into. \\
\hline
\end{DoxyParams}
\mbox{\label{classmlpack_1_1neighbor_1_1NeighborSearchRules_a9e005f9b8655b905dd040604dd47fac9}} 
\index{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules@{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules}!Get\+Best\+Child@{Get\+Best\+Child}}
\index{Get\+Best\+Child@{Get\+Best\+Child}!mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules@{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules}}
\subsubsection{Get\+Best\+Child()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily size\+\_\+t Get\+Best\+Child (\begin{DoxyParamCaption}\item[{const Tree\+Type \&}]{query\+Node,  }\item[{Tree\+Type \&}]{reference\+Node }\end{DoxyParamCaption})}



Get the child node with the best score. 


\begin{DoxyParams}{Parameters}
{\em query\+Node} & Node to be considered. \\
\hline
{\em reference\+Node} & Candidate node to be recursed into. \\
\hline
\end{DoxyParams}
\mbox{\label{classmlpack_1_1neighbor_1_1NeighborSearchRules_add24e5e55e4b8555dbd941b137a44491}} 
\index{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules@{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules}!Get\+Results@{Get\+Results}}
\index{Get\+Results@{Get\+Results}!mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules@{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules}}
\subsubsection{Get\+Results()}
{\footnotesize\ttfamily void Get\+Results (\begin{DoxyParamCaption}\item[{arma\+::\+Mat$<$ size\+\_\+t $>$ \&}]{neighbors,  }\item[{arma\+::mat \&}]{distances }\end{DoxyParamCaption})}



Store the list of candidates for each query point in the given matrices. 


\begin{DoxyParams}{Parameters}
{\em neighbors} & Matrix storing lists of neighbors for each query point. \\
\hline
{\em distances} & Matrix storing distances of neighbors for each query point. \\
\hline
\end{DoxyParams}
\mbox{\label{classmlpack_1_1neighbor_1_1NeighborSearchRules_a64b3c9d35e4c5a3932c3b2b390c3ad04}} 
\index{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules@{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules}!Insert\+Neighbor@{Insert\+Neighbor}}
\index{Insert\+Neighbor@{Insert\+Neighbor}!mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules@{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules}}
\subsubsection{Insert\+Neighbor()}
{\footnotesize\ttfamily void Insert\+Neighbor (\begin{DoxyParamCaption}\item[{const size\+\_\+t}]{query\+Index,  }\item[{const size\+\_\+t}]{neighbor,  }\item[{const double}]{distance }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Helper function to insert a point into the list of candidate points. 


\begin{DoxyParams}{Parameters}
{\em query\+Index} & Index of point whose neighbors we are inserting into. \\
\hline
{\em neighbor} & Index of reference point which is being inserted. \\
\hline
{\em distance} & Distance from query point to reference point. \\
\hline
\end{DoxyParams}
\mbox{\label{classmlpack_1_1neighbor_1_1NeighborSearchRules_a469f61784f9cce8f2574c23823405768}} 
\index{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules@{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules}!Minimum\+Base\+Cases@{Minimum\+Base\+Cases}}
\index{Minimum\+Base\+Cases@{Minimum\+Base\+Cases}!mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules@{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules}}
\subsubsection{Minimum\+Base\+Cases()}
{\footnotesize\ttfamily size\+\_\+t Minimum\+Base\+Cases (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Get the minimum number of base cases we need to perform to have acceptable results. 

This is only needed in defeatist search mode. 

Definition at line 162 of file neighbor\+\_\+search\+\_\+rules.\+hpp.



References Neighbor\+Search\+Rules$<$ Sort\+Policy, Metric\+Type, Tree\+Type $>$\+::k.

\mbox{\label{classmlpack_1_1neighbor_1_1NeighborSearchRules_ae0ad46f30e80aadc5bc476d46886540f}} 
\index{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules@{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules}!Rescore@{Rescore}}
\index{Rescore@{Rescore}!mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules@{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules}}
\subsubsection{Rescore()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily double Rescore (\begin{DoxyParamCaption}\item[{const size\+\_\+t}]{query\+Index,  }\item[{Tree\+Type \&}]{reference\+Node,  }\item[{const double}]{old\+Score }\end{DoxyParamCaption}) const}



Re-\/evaluate the score for recursion order. 

A low score indicates priority for recursion, while D\+B\+L\+\_\+\+M\+AX indicates that the node should not be recursed into at all (it should be pruned). This is used when the score has already been calculated, but another recursion may have modified the bounds for pruning. So the old score is checked against the new pruning bound.


\begin{DoxyParams}{Parameters}
{\em query\+Index} & Index of query point. \\
\hline
{\em reference\+Node} & Candidate node to be recursed into. \\
\hline
{\em old\+Score} & Old score produced by \doxyref{Score()}{p.}{classmlpack_1_1neighbor_1_1NeighborSearchRules_a53d373b7aeee359b0e686f823c602b1c} (or \doxyref{Rescore()}{p.}{classmlpack_1_1neighbor_1_1NeighborSearchRules_ae0ad46f30e80aadc5bc476d46886540f}). \\
\hline
\end{DoxyParams}
\mbox{\label{classmlpack_1_1neighbor_1_1NeighborSearchRules_a536e5a7cbce35b9be7443775d32e11f5}} 
\index{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules@{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules}!Rescore@{Rescore}}
\index{Rescore@{Rescore}!mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules@{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules}}
\subsubsection{Rescore()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily double Rescore (\begin{DoxyParamCaption}\item[{Tree\+Type \&}]{query\+Node,  }\item[{Tree\+Type \&}]{reference\+Node,  }\item[{const double}]{old\+Score }\end{DoxyParamCaption}) const}



Re-\/evaluate the score for recursion order. 

A low score indicates priority for recursion, while D\+B\+L\+\_\+\+M\+AX indicates that the node should not be recursed into at all (it should be pruned). This is used when the score has already been calculated, but another recursion may have modified the bounds for pruning. So the old score is checked against the new pruning bound.


\begin{DoxyParams}{Parameters}
{\em query\+Node} & Candidate query node to recurse into. \\
\hline
{\em reference\+Node} & Candidate reference node to recurse into. \\
\hline
{\em old\+Score} & Old score produced by Socre() (or \doxyref{Rescore()}{p.}{classmlpack_1_1neighbor_1_1NeighborSearchRules_ae0ad46f30e80aadc5bc476d46886540f}). \\
\hline
\end{DoxyParams}
\mbox{\label{classmlpack_1_1neighbor_1_1NeighborSearchRules_a53d373b7aeee359b0e686f823c602b1c}} 
\index{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules@{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules}!Score@{Score}}
\index{Score@{Score}!mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules@{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules}}
\subsubsection{Score()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily double Score (\begin{DoxyParamCaption}\item[{const size\+\_\+t}]{query\+Index,  }\item[{Tree\+Type \&}]{reference\+Node }\end{DoxyParamCaption})}



Get the score for recursion order. 

A low score indicates priority for recursion, while D\+B\+L\+\_\+\+M\+AX indicates that the node should not be recursed into at all (it should be pruned).


\begin{DoxyParams}{Parameters}
{\em query\+Index} & Index of query point. \\
\hline
{\em reference\+Node} & Candidate node to be recursed into. \\
\hline
\end{DoxyParams}
\mbox{\label{classmlpack_1_1neighbor_1_1NeighborSearchRules_a05b142945ef94221b628a75961f48b02}} 
\index{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules@{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules}!Score@{Score}}
\index{Score@{Score}!mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules@{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules}}
\subsubsection{Score()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily double Score (\begin{DoxyParamCaption}\item[{Tree\+Type \&}]{query\+Node,  }\item[{Tree\+Type \&}]{reference\+Node }\end{DoxyParamCaption})}



Get the score for recursion order. 

A low score indicates priority for recursionm while D\+B\+L\+\_\+\+M\+AX indicates that the node should not be recursed into at all (it should be pruned).


\begin{DoxyParams}{Parameters}
{\em query\+Node} & Candidate query node to recurse into. \\
\hline
{\em reference\+Node} & Candidate reference node to recurse into. \\
\hline
\end{DoxyParams}
\mbox{\label{classmlpack_1_1neighbor_1_1NeighborSearchRules_a4d1e40c0bf406280a237ca1b487e3c62}} 
\index{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules@{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules}!Scores@{Scores}}
\index{Scores@{Scores}!mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules@{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules}}
\subsubsection{Scores()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily size\+\_\+t Scores (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Get the number of scores that have been performed. 



Definition at line 148 of file neighbor\+\_\+search\+\_\+rules.\+hpp.



References Neighbor\+Search\+Rules$<$ Sort\+Policy, Metric\+Type, Tree\+Type $>$\+::scores.

\mbox{\label{classmlpack_1_1neighbor_1_1NeighborSearchRules_a8c3486626c1d3c0a10cdb27a8faa198f}} 
\index{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules@{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules}!Scores@{Scores}}
\index{Scores@{Scores}!mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules@{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules}}
\subsubsection{Scores()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily size\+\_\+t\& Scores (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Modify the number of scores that have been performed. 



Definition at line 150 of file neighbor\+\_\+search\+\_\+rules.\+hpp.



References Neighbor\+Search\+Rules$<$ Sort\+Policy, Metric\+Type, Tree\+Type $>$\+::scores.

\mbox{\label{classmlpack_1_1neighbor_1_1NeighborSearchRules_ab5c6f4ae7c3b71b808403a7b7454f26f}} 
\index{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules@{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules}!Traversal\+Info@{Traversal\+Info}}
\index{Traversal\+Info@{Traversal\+Info}!mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules@{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules}}
\subsubsection{Traversal\+Info()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily const \textbf{ Traversal\+Info\+Type}\& Traversal\+Info (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Get the traversal info. 



Definition at line 156 of file neighbor\+\_\+search\+\_\+rules.\+hpp.



References Neighbor\+Search\+Rules$<$ Sort\+Policy, Metric\+Type, Tree\+Type $>$\+::traversal\+Info.

\mbox{\label{classmlpack_1_1neighbor_1_1NeighborSearchRules_a4027bb90e756a4520d55978459c7f83e}} 
\index{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules@{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules}!Traversal\+Info@{Traversal\+Info}}
\index{Traversal\+Info@{Traversal\+Info}!mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules@{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules}}
\subsubsection{Traversal\+Info()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \textbf{ Traversal\+Info\+Type}\& Traversal\+Info (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Modify the traversal info. 



Definition at line 158 of file neighbor\+\_\+search\+\_\+rules.\+hpp.



References Neighbor\+Search\+Rules$<$ Sort\+Policy, Metric\+Type, Tree\+Type $>$\+::traversal\+Info.



\subsection{Member Data Documentation}
\mbox{\label{classmlpack_1_1neighbor_1_1NeighborSearchRules_a06e4c7b3f942c628e2b3584e7ba02cbf}} 
\index{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules@{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules}!base\+Cases@{base\+Cases}}
\index{base\+Cases@{base\+Cases}!mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules@{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules}}
\subsubsection{base\+Cases}
{\footnotesize\ttfamily size\+\_\+t base\+Cases\hspace{0.3cm}{\ttfamily [protected]}}



The number of base cases that have been performed. 



Definition at line 209 of file neighbor\+\_\+search\+\_\+rules.\+hpp.



Referenced by Neighbor\+Search\+Rules$<$ Sort\+Policy, Metric\+Type, Tree\+Type $>$\+::\+Base\+Cases().

\mbox{\label{classmlpack_1_1neighbor_1_1NeighborSearchRules_a2fd8d0cb021bd3b0175cff2fd44a4cda}} 
\index{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules@{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules}!candidates@{candidates}}
\index{candidates@{candidates}!mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules@{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules}}
\subsubsection{candidates}
{\footnotesize\ttfamily std\+::vector$<$\textbf{ Candidate\+List}$>$ candidates\hspace{0.3cm}{\ttfamily [protected]}}



Set of candidate neighbors for each point. 



Definition at line 187 of file neighbor\+\_\+search\+\_\+rules.\+hpp.

\mbox{\label{classmlpack_1_1neighbor_1_1NeighborSearchRules_ac29df3dcbefa1ce189e5990bde994025}} 
\index{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules@{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules}!epsilon@{epsilon}}
\index{epsilon@{epsilon}!mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules@{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules}}
\subsubsection{epsilon}
{\footnotesize\ttfamily const double epsilon\hspace{0.3cm}{\ttfamily [protected]}}



Relative error to be considered in approximate search. 



Definition at line 199 of file neighbor\+\_\+search\+\_\+rules.\+hpp.

\mbox{\label{classmlpack_1_1neighbor_1_1NeighborSearchRules_af004d46789d32b9155f2c0eb5b771181}} 
\index{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules@{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules}!k@{k}}
\index{k@{k}!mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules@{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules}}
\subsubsection{k}
{\footnotesize\ttfamily const size\+\_\+t k\hspace{0.3cm}{\ttfamily [protected]}}



Number of neighbors to search for. 



Definition at line 190 of file neighbor\+\_\+search\+\_\+rules.\+hpp.



Referenced by Neighbor\+Search\+Rules$<$ Sort\+Policy, Metric\+Type, Tree\+Type $>$\+::\+Minimum\+Base\+Cases().

\mbox{\label{classmlpack_1_1neighbor_1_1NeighborSearchRules_a5210d29f3192b5e01426740502013a0d}} 
\index{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules@{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules}!last\+Base\+Case@{last\+Base\+Case}}
\index{last\+Base\+Case@{last\+Base\+Case}!mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules@{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules}}
\subsubsection{last\+Base\+Case}
{\footnotesize\ttfamily double last\+Base\+Case\hspace{0.3cm}{\ttfamily [protected]}}



The last base case result. 



Definition at line 206 of file neighbor\+\_\+search\+\_\+rules.\+hpp.

\mbox{\label{classmlpack_1_1neighbor_1_1NeighborSearchRules_a89e87b0301224505aa09b8c85738a364}} 
\index{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules@{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules}!last\+Query\+Index@{last\+Query\+Index}}
\index{last\+Query\+Index@{last\+Query\+Index}!mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules@{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules}}
\subsubsection{last\+Query\+Index}
{\footnotesize\ttfamily size\+\_\+t last\+Query\+Index\hspace{0.3cm}{\ttfamily [protected]}}



The last query point \doxyref{Base\+Case()}{p.}{classmlpack_1_1neighbor_1_1NeighborSearchRules_abac50f780bb5e1bc12dd0d16d850cacc} was called with. 



Definition at line 202 of file neighbor\+\_\+search\+\_\+rules.\+hpp.

\mbox{\label{classmlpack_1_1neighbor_1_1NeighborSearchRules_ad83397af4d986c7afc78e3d1f31f9276}} 
\index{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules@{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules}!last\+Reference\+Index@{last\+Reference\+Index}}
\index{last\+Reference\+Index@{last\+Reference\+Index}!mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules@{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules}}
\subsubsection{last\+Reference\+Index}
{\footnotesize\ttfamily size\+\_\+t last\+Reference\+Index\hspace{0.3cm}{\ttfamily [protected]}}



The last reference point \doxyref{Base\+Case()}{p.}{classmlpack_1_1neighbor_1_1NeighborSearchRules_abac50f780bb5e1bc12dd0d16d850cacc} was called with. 



Definition at line 204 of file neighbor\+\_\+search\+\_\+rules.\+hpp.

\mbox{\label{classmlpack_1_1neighbor_1_1NeighborSearchRules_abc0ef94d224e16bddfe3ded53dfb5133}} 
\index{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules@{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules}!metric@{metric}}
\index{metric@{metric}!mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules@{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules}}
\subsubsection{metric}
{\footnotesize\ttfamily Metric\+Type\& metric\hspace{0.3cm}{\ttfamily [protected]}}



The instantiated metric. 



Definition at line 193 of file neighbor\+\_\+search\+\_\+rules.\+hpp.

\mbox{\label{classmlpack_1_1neighbor_1_1NeighborSearchRules_a39e4662e24522711a354d019c6d27366}} 
\index{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules@{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules}!query\+Set@{query\+Set}}
\index{query\+Set@{query\+Set}!mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules@{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules}}
\subsubsection{query\+Set}
{\footnotesize\ttfamily const Tree\+Type\+::\+Mat\& query\+Set\hspace{0.3cm}{\ttfamily [protected]}}



The query set. 



Definition at line 169 of file neighbor\+\_\+search\+\_\+rules.\+hpp.

\mbox{\label{classmlpack_1_1neighbor_1_1NeighborSearchRules_aebdb2895a33036194826de9631543c7e}} 
\index{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules@{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules}!reference\+Set@{reference\+Set}}
\index{reference\+Set@{reference\+Set}!mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules@{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules}}
\subsubsection{reference\+Set}
{\footnotesize\ttfamily const Tree\+Type\+::\+Mat\& reference\+Set\hspace{0.3cm}{\ttfamily [protected]}}



The reference set. 



Definition at line 166 of file neighbor\+\_\+search\+\_\+rules.\+hpp.

\mbox{\label{classmlpack_1_1neighbor_1_1NeighborSearchRules_a500d895c970c9ee5d0c77ff7b8508cfc}} 
\index{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules@{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules}!same\+Set@{same\+Set}}
\index{same\+Set@{same\+Set}!mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules@{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules}}
\subsubsection{same\+Set}
{\footnotesize\ttfamily bool same\+Set\hspace{0.3cm}{\ttfamily [protected]}}



Denotes whether or not the reference and query sets are the same. 



Definition at line 196 of file neighbor\+\_\+search\+\_\+rules.\+hpp.

\mbox{\label{classmlpack_1_1neighbor_1_1NeighborSearchRules_aecc3c9a30f1be1fe8b602374bde73e7b}} 
\index{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules@{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules}!scores@{scores}}
\index{scores@{scores}!mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules@{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules}}
\subsubsection{scores}
{\footnotesize\ttfamily size\+\_\+t scores\hspace{0.3cm}{\ttfamily [protected]}}



The number of scores that have been performed. 



Definition at line 211 of file neighbor\+\_\+search\+\_\+rules.\+hpp.



Referenced by Neighbor\+Search\+Rules$<$ Sort\+Policy, Metric\+Type, Tree\+Type $>$\+::\+Scores().

\mbox{\label{classmlpack_1_1neighbor_1_1NeighborSearchRules_aa987143b3965542c77c85c8212abedbe}} 
\index{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules@{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules}!traversal\+Info@{traversal\+Info}}
\index{traversal\+Info@{traversal\+Info}!mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules@{mlpack\+::neighbor\+::\+Neighbor\+Search\+Rules}}
\subsubsection{traversal\+Info}
{\footnotesize\ttfamily \textbf{ Traversal\+Info\+Type} traversal\+Info\hspace{0.3cm}{\ttfamily [protected]}}



Traversal info for the parent combination; this is updated by the traversal before each call to \doxyref{Score()}{p.}{classmlpack_1_1neighbor_1_1NeighborSearchRules_a53d373b7aeee359b0e686f823c602b1c}. 



Definition at line 215 of file neighbor\+\_\+search\+\_\+rules.\+hpp.



Referenced by Neighbor\+Search\+Rules$<$ Sort\+Policy, Metric\+Type, Tree\+Type $>$\+::\+Traversal\+Info().



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
/home/aakash/mlpack/src/mlpack/methods/neighbor\+\_\+search/\textbf{ neighbor\+\_\+search\+\_\+rules.\+hpp}\end{DoxyCompactItemize}
