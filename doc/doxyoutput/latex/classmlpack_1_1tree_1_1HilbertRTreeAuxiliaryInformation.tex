\section{Hilbert\+R\+Tree\+Auxiliary\+Information$<$ Tree\+Type, Hilbert\+Value\+Type $>$ Class Template Reference}
\label{classmlpack_1_1tree_1_1HilbertRTreeAuxiliaryInformation}\index{Hilbert\+R\+Tree\+Auxiliary\+Information$<$ Tree\+Type, Hilbert\+Value\+Type $>$@{Hilbert\+R\+Tree\+Auxiliary\+Information$<$ Tree\+Type, Hilbert\+Value\+Type $>$}}
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
typedef Tree\+Type\+::\+Elem\+Type \textbf{ Elem\+Type}
\begin{DoxyCompactList}\small\item\em The element type held by the tree. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\textbf{ Hilbert\+R\+Tree\+Auxiliary\+Information} ()
\begin{DoxyCompactList}\small\item\em Default constructor. \end{DoxyCompactList}\item 
\textbf{ Hilbert\+R\+Tree\+Auxiliary\+Information} (const Tree\+Type $\ast$node)
\begin{DoxyCompactList}\small\item\em Construct this as an auxiliary information for the given node. \end{DoxyCompactList}\item 
\textbf{ Hilbert\+R\+Tree\+Auxiliary\+Information} (const \textbf{ Hilbert\+R\+Tree\+Auxiliary\+Information} \&other, Tree\+Type $\ast$tree=N\+U\+LL, bool deep\+Copy=true)
\begin{DoxyCompactList}\small\item\em Create an auxiliary information object by copying from another object. \end{DoxyCompactList}\item 
\textbf{ Hilbert\+R\+Tree\+Auxiliary\+Information} (\textbf{ Hilbert\+R\+Tree\+Auxiliary\+Information} \&\&other)
\begin{DoxyCompactList}\small\item\em Create an auxiliary information object by moving from the other node. \end{DoxyCompactList}\item 
bool \textbf{ Handle\+Node\+Insertion} (Tree\+Type $\ast$node, Tree\+Type $\ast$node\+To\+Insert, bool insertion\+Level)
\begin{DoxyCompactList}\small\item\em The Hilbert R tree requires to insert nodes according to their Hilbert value. \end{DoxyCompactList}\item 
bool \textbf{ Handle\+Node\+Removal} (Tree\+Type $\ast$node, const size\+\_\+t node\+Index)
\begin{DoxyCompactList}\small\item\em The Hilbert R tree requires all nodes to be arranged according to their Hilbert value. \end{DoxyCompactList}\item 
bool \textbf{ Handle\+Point\+Deletion} (Tree\+Type $\ast$node, const size\+\_\+t local\+Index)
\begin{DoxyCompactList}\small\item\em The Hilbert R tree requires all points to be arranged according to their Hilbert value. \end{DoxyCompactList}\item 
bool \textbf{ Handle\+Point\+Insertion} (Tree\+Type $\ast$node, const size\+\_\+t point)
\begin{DoxyCompactList}\small\item\em The Hilbert R tree requires to insert points according to their Hilbert value. \end{DoxyCompactList}\item 
const Hilbert\+Value\+Type$<$ \textbf{ Elem\+Type} $>$ \& \textbf{ Hilbert\+Value} () const
\begin{DoxyCompactList}\small\item\em Return the largest Hilbert value of a point covered by the node. \end{DoxyCompactList}\item 
Hilbert\+Value\+Type$<$ \textbf{ Elem\+Type} $>$ \& \textbf{ Hilbert\+Value} ()
\begin{DoxyCompactList}\small\item\em Modify the largest Hilbert value of a point covered by the node. \end{DoxyCompactList}\item 
void \textbf{ Nullify\+Data} ()
\begin{DoxyCompactList}\small\item\em Clear memory. \end{DoxyCompactList}\item 
\textbf{ Hilbert\+R\+Tree\+Auxiliary\+Information} \& \textbf{ operator=} (const \textbf{ Hilbert\+R\+Tree\+Auxiliary\+Information} \&other)
\begin{DoxyCompactList}\small\item\em Copy the auxiliary information. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Archive $>$ }\\void \textbf{ serialize} (Archive \&ar, const uint32\+\_\+t)
\begin{DoxyCompactList}\small\item\em Serialize the information. \end{DoxyCompactList}\item 
bool \textbf{ Update\+Auxiliary\+Info} (Tree\+Type $\ast$node)
\begin{DoxyCompactList}\small\item\em Update the auxiliary information in the node. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static const std\+::vector$<$ Tree\+Type $\ast$ $>$ \textbf{ Children} (const Tree\+Type $\ast$tree)
\begin{DoxyCompactList}\small\item\em Return the children vector of the tree. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
\subsubsection*{template$<$typename Tree\+Type, template$<$ typename $>$ class Hilbert\+Value\+Type$>$\newline
class mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information$<$ Tree\+Type, Hilbert\+Value\+Type $>$}



Definition at line 22 of file hilbert\+\_\+r\+\_\+tree\+\_\+auxiliary\+\_\+information.\+hpp.



\subsection{Member Typedef Documentation}
\mbox{\label{classmlpack_1_1tree_1_1HilbertRTreeAuxiliaryInformation_a9c50fecd9c0085e7f7ac7f770fa739ae}} 
\index{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information@{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}!Elem\+Type@{Elem\+Type}}
\index{Elem\+Type@{Elem\+Type}!mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information@{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}}
\subsubsection{Elem\+Type}
{\footnotesize\ttfamily typedef Tree\+Type\+::\+Elem\+Type \textbf{ Elem\+Type}}



The element type held by the tree. 



Definition at line 26 of file hilbert\+\_\+r\+\_\+tree\+\_\+auxiliary\+\_\+information.\+hpp.



\subsection{Constructor \& Destructor Documentation}
\mbox{\label{classmlpack_1_1tree_1_1HilbertRTreeAuxiliaryInformation_a8b589cac80187871bc6676d8ea1de350}} 
\index{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information@{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}!Hilbert\+R\+Tree\+Auxiliary\+Information@{Hilbert\+R\+Tree\+Auxiliary\+Information}}
\index{Hilbert\+R\+Tree\+Auxiliary\+Information@{Hilbert\+R\+Tree\+Auxiliary\+Information}!mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information@{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}}
\subsubsection{Hilbert\+R\+Tree\+Auxiliary\+Information()\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily \textbf{ Hilbert\+R\+Tree\+Auxiliary\+Information} (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Default constructor. 

\mbox{\label{classmlpack_1_1tree_1_1HilbertRTreeAuxiliaryInformation_a0f91279c9323aacec517fc2c6f8aad6b}} 
\index{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information@{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}!Hilbert\+R\+Tree\+Auxiliary\+Information@{Hilbert\+R\+Tree\+Auxiliary\+Information}}
\index{Hilbert\+R\+Tree\+Auxiliary\+Information@{Hilbert\+R\+Tree\+Auxiliary\+Information}!mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information@{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}}
\subsubsection{Hilbert\+R\+Tree\+Auxiliary\+Information()\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily \textbf{ Hilbert\+R\+Tree\+Auxiliary\+Information} (\begin{DoxyParamCaption}\item[{const Tree\+Type $\ast$}]{node }\end{DoxyParamCaption})}



Construct this as an auxiliary information for the given node. 


\begin{DoxyParams}{Parameters}
{\em node} & The node that stores this auxiliary information. \\
\hline
\end{DoxyParams}
\mbox{\label{classmlpack_1_1tree_1_1HilbertRTreeAuxiliaryInformation_acbeb71d576dff20c4a6fb3f9575c9475}} 
\index{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information@{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}!Hilbert\+R\+Tree\+Auxiliary\+Information@{Hilbert\+R\+Tree\+Auxiliary\+Information}}
\index{Hilbert\+R\+Tree\+Auxiliary\+Information@{Hilbert\+R\+Tree\+Auxiliary\+Information}!mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information@{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}}
\subsubsection{Hilbert\+R\+Tree\+Auxiliary\+Information()\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily \textbf{ Hilbert\+R\+Tree\+Auxiliary\+Information} (\begin{DoxyParamCaption}\item[{const \textbf{ Hilbert\+R\+Tree\+Auxiliary\+Information}$<$ Tree\+Type, Hilbert\+Value\+Type $>$ \&}]{other,  }\item[{Tree\+Type $\ast$}]{tree = {\ttfamily NULL},  }\item[{bool}]{deep\+Copy = {\ttfamily true} }\end{DoxyParamCaption})}



Create an auxiliary information object by copying from another object. 


\begin{DoxyParams}{Parameters}
{\em other} & Another auxiliary information object from which the information will be copied. \\
\hline
{\em tree} & The node that holds the auxiliary information. \\
\hline
{\em deep\+Copy} & If false, the new object uses the same memory (not used here). \\
\hline
\end{DoxyParams}
\mbox{\label{classmlpack_1_1tree_1_1HilbertRTreeAuxiliaryInformation_a8b53daade2fdad2a45ceb7e19ee91aad}} 
\index{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information@{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}!Hilbert\+R\+Tree\+Auxiliary\+Information@{Hilbert\+R\+Tree\+Auxiliary\+Information}}
\index{Hilbert\+R\+Tree\+Auxiliary\+Information@{Hilbert\+R\+Tree\+Auxiliary\+Information}!mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information@{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}}
\subsubsection{Hilbert\+R\+Tree\+Auxiliary\+Information()\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily \textbf{ Hilbert\+R\+Tree\+Auxiliary\+Information} (\begin{DoxyParamCaption}\item[{\textbf{ Hilbert\+R\+Tree\+Auxiliary\+Information}$<$ Tree\+Type, Hilbert\+Value\+Type $>$ \&\&}]{other }\end{DoxyParamCaption})}



Create an auxiliary information object by moving from the other node. 


\begin{DoxyParams}{Parameters}
{\em other} & The object from which the information will be moved. \\
\hline
\end{DoxyParams}


\subsection{Member Function Documentation}
\mbox{\label{classmlpack_1_1tree_1_1HilbertRTreeAuxiliaryInformation_ae7985642e74393bc9e2e24abdfbffc02}} 
\index{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information@{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}!Children@{Children}}
\index{Children@{Children}!mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information@{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}}
\subsubsection{Children()}
{\footnotesize\ttfamily static const std\+::vector$<$Tree\+Type$\ast$$>$ Children (\begin{DoxyParamCaption}\item[{const Tree\+Type $\ast$}]{tree }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}



Return the children vector of the tree. 



Definition at line 124 of file hilbert\+\_\+r\+\_\+tree\+\_\+auxiliary\+\_\+information.\+hpp.

\mbox{\label{classmlpack_1_1tree_1_1HilbertRTreeAuxiliaryInformation_ab4c10141d54f673463d7aa8d6fdfadcb}} 
\index{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information@{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}!Handle\+Node\+Insertion@{Handle\+Node\+Insertion}}
\index{Handle\+Node\+Insertion@{Handle\+Node\+Insertion}!mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information@{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}}
\subsubsection{Handle\+Node\+Insertion()}
{\footnotesize\ttfamily bool Handle\+Node\+Insertion (\begin{DoxyParamCaption}\item[{Tree\+Type $\ast$}]{node,  }\item[{Tree\+Type $\ast$}]{node\+To\+Insert,  }\item[{bool}]{insertion\+Level }\end{DoxyParamCaption})}



The Hilbert R tree requires to insert nodes according to their Hilbert value. 

This method should take care of it. It returns false if it does nothing and true if it handles the insertion process.


\begin{DoxyParams}{Parameters}
{\em node} & The node in which the node\+To\+Insert is being inserted. \\
\hline
{\em node\+To\+Insert} & The node being inserted. \\
\hline
{\em insertion\+Level} & The level of the tree at which the node\+To\+Insert should be inserted. \\
\hline
\end{DoxyParams}
\mbox{\label{classmlpack_1_1tree_1_1HilbertRTreeAuxiliaryInformation_a3d9a96ff07d6707363cb0ed70ca2522f}} 
\index{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information@{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}!Handle\+Node\+Removal@{Handle\+Node\+Removal}}
\index{Handle\+Node\+Removal@{Handle\+Node\+Removal}!mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information@{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}}
\subsubsection{Handle\+Node\+Removal()}
{\footnotesize\ttfamily bool Handle\+Node\+Removal (\begin{DoxyParamCaption}\item[{Tree\+Type $\ast$}]{node,  }\item[{const size\+\_\+t}]{node\+Index }\end{DoxyParamCaption})}



The Hilbert R tree requires all nodes to be arranged according to their Hilbert value. 

This method should take care of saving this property after the deletion process. It returns false if it does nothing and true if it handles the deletion process.


\begin{DoxyParams}{Parameters}
{\em node} & The node from which the node is being deleted. \\
\hline
{\em node\+Index} & The index of the node being deleted. \\
\hline
\end{DoxyParams}
\mbox{\label{classmlpack_1_1tree_1_1HilbertRTreeAuxiliaryInformation_a58597b934c75ead9344fc5c75c753e10}} 
\index{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information@{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}!Handle\+Point\+Deletion@{Handle\+Point\+Deletion}}
\index{Handle\+Point\+Deletion@{Handle\+Point\+Deletion}!mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information@{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}}
\subsubsection{Handle\+Point\+Deletion()}
{\footnotesize\ttfamily bool Handle\+Point\+Deletion (\begin{DoxyParamCaption}\item[{Tree\+Type $\ast$}]{node,  }\item[{const size\+\_\+t}]{local\+Index }\end{DoxyParamCaption})}



The Hilbert R tree requires all points to be arranged according to their Hilbert value. 

This method should take care of saving this property after the deletion process. It returns false if it does nothing and true if it handles the deletion process.


\begin{DoxyParams}{Parameters}
{\em node} & The node from which the point is being deleted. \\
\hline
{\em local\+Index} & The index of the point being deleted. \\
\hline
\end{DoxyParams}
\mbox{\label{classmlpack_1_1tree_1_1HilbertRTreeAuxiliaryInformation_ac39067caca6160fc68464a2ac3896616}} 
\index{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information@{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}!Handle\+Point\+Insertion@{Handle\+Point\+Insertion}}
\index{Handle\+Point\+Insertion@{Handle\+Point\+Insertion}!mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information@{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}}
\subsubsection{Handle\+Point\+Insertion()}
{\footnotesize\ttfamily bool Handle\+Point\+Insertion (\begin{DoxyParamCaption}\item[{Tree\+Type $\ast$}]{node,  }\item[{const size\+\_\+t}]{point }\end{DoxyParamCaption})}



The Hilbert R tree requires to insert points according to their Hilbert value. 

This method should take care of it. It returns false if it does nothing and true if it handles the insertion process.


\begin{DoxyParams}{Parameters}
{\em node} & The node in which the point is being inserted. \\
\hline
{\em point} & The number of the point being inserted. \\
\hline
\end{DoxyParams}
\mbox{\label{classmlpack_1_1tree_1_1HilbertRTreeAuxiliaryInformation_a7e7444bd9435cbd1dc45cc0295788207}} 
\index{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information@{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}!Hilbert\+Value@{Hilbert\+Value}}
\index{Hilbert\+Value@{Hilbert\+Value}!mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information@{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}}
\subsubsection{Hilbert\+Value()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily const Hilbert\+Value\+Type$<$\textbf{ Elem\+Type}$>$\& Hilbert\+Value (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Return the largest Hilbert value of a point covered by the node. 



Definition at line 133 of file hilbert\+\_\+r\+\_\+tree\+\_\+auxiliary\+\_\+information.\+hpp.

\mbox{\label{classmlpack_1_1tree_1_1HilbertRTreeAuxiliaryInformation_a058d72ca9323013928bf7152a5bbdcc2}} 
\index{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information@{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}!Hilbert\+Value@{Hilbert\+Value}}
\index{Hilbert\+Value@{Hilbert\+Value}!mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information@{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}}
\subsubsection{Hilbert\+Value()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily Hilbert\+Value\+Type$<$\textbf{ Elem\+Type}$>$\& Hilbert\+Value (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Modify the largest Hilbert value of a point covered by the node. 



Definition at line 136 of file hilbert\+\_\+r\+\_\+tree\+\_\+auxiliary\+\_\+information.\+hpp.



References Hilbert\+R\+Tree\+Auxiliary\+Information$<$ Tree\+Type, Hilbert\+Value\+Type $>$\+::serialize().

\mbox{\label{classmlpack_1_1tree_1_1HilbertRTreeAuxiliaryInformation_a8dbe26c4727e347359f1da279659f0cd}} 
\index{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information@{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}!Nullify\+Data@{Nullify\+Data}}
\index{Nullify\+Data@{Nullify\+Data}!mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information@{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}}
\subsubsection{Nullify\+Data()}
{\footnotesize\ttfamily void Nullify\+Data (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Clear memory. 

\mbox{\label{classmlpack_1_1tree_1_1HilbertRTreeAuxiliaryInformation_a9db05a91f0d2c1806b030ac14a8e07a9}} 
\index{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information@{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}!operator=@{operator=}}
\index{operator=@{operator=}!mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information@{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}}
\subsubsection{operator=()}
{\footnotesize\ttfamily \textbf{ Hilbert\+R\+Tree\+Auxiliary\+Information}\& operator= (\begin{DoxyParamCaption}\item[{const \textbf{ Hilbert\+R\+Tree\+Auxiliary\+Information}$<$ Tree\+Type, Hilbert\+Value\+Type $>$ \&}]{other }\end{DoxyParamCaption})}



Copy the auxiliary information. 


\begin{DoxyParams}{Parameters}
{\em other} & The object from which the information will be moved. \\
\hline
\end{DoxyParams}
\mbox{\label{classmlpack_1_1tree_1_1HilbertRTreeAuxiliaryInformation_a65cba07328997659bec80b9879b15a51}} 
\index{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information@{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}!serialize@{serialize}}
\index{serialize@{serialize}!mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information@{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}}
\subsubsection{serialize()}
{\footnotesize\ttfamily void serialize (\begin{DoxyParamCaption}\item[{Archive \&}]{ar,  }\item[{const uint32\+\_\+t}]{ }\end{DoxyParamCaption})}



Serialize the information. 



Referenced by Hilbert\+R\+Tree\+Auxiliary\+Information$<$ Tree\+Type, Hilbert\+Value\+Type $>$\+::\+Hilbert\+Value().

\mbox{\label{classmlpack_1_1tree_1_1HilbertRTreeAuxiliaryInformation_a377d5bde0d85c152100b0e6f22d2cd2f}} 
\index{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information@{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}!Update\+Auxiliary\+Info@{Update\+Auxiliary\+Info}}
\index{Update\+Auxiliary\+Info@{Update\+Auxiliary\+Info}!mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information@{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}}
\subsubsection{Update\+Auxiliary\+Info()}
{\footnotesize\ttfamily bool Update\+Auxiliary\+Info (\begin{DoxyParamCaption}\item[{Tree\+Type $\ast$}]{node }\end{DoxyParamCaption})}



Update the auxiliary information in the node. 

The method returns true if the update should be propagated downward.


\begin{DoxyParams}{Parameters}
{\em node} & The node in which the auxiliary information being update. \\
\hline
\end{DoxyParams}


The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
/home/aakash/mlpack/src/mlpack/core/tree/rectangle\+\_\+tree/\textbf{ hilbert\+\_\+r\+\_\+tree\+\_\+auxiliary\+\_\+information.\+hpp}\end{DoxyCompactItemize}
