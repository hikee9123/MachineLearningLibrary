\section{L\+S\+H\+Search$<$ Sort\+Policy, Mat\+Type $>$ Class Template Reference}
\label{classmlpack_1_1neighbor_1_1LSHSearch}\index{L\+S\+H\+Search$<$ Sort\+Policy, Mat\+Type $>$@{L\+S\+H\+Search$<$ Sort\+Policy, Mat\+Type $>$}}


The \doxyref{L\+S\+H\+Search}{p.}{classmlpack_1_1neighbor_1_1LSHSearch} class; this class builds a hash on the reference set and uses this hash to compute the distance-\/approximate nearest-\/neighbors of the given queries.  


\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\textbf{ L\+S\+H\+Search} (Mat\+Type reference\+Set, const arma\+::cube \&projections, const double hash\+Width=0.\+0, const size\+\_\+t second\+Hash\+Size=99901, const size\+\_\+t bucket\+Size=500)
\begin{DoxyCompactList}\small\item\em This function initializes the L\+SH class. \end{DoxyCompactList}\item 
\textbf{ L\+S\+H\+Search} (Mat\+Type reference\+Set, const size\+\_\+t num\+Proj, const size\+\_\+t num\+Tables, const double hash\+Width=0.\+0, const size\+\_\+t second\+Hash\+Size=99901, const size\+\_\+t bucket\+Size=500)
\begin{DoxyCompactList}\small\item\em This function initializes the L\+SH class. \end{DoxyCompactList}\item 
\textbf{ L\+S\+H\+Search} ()
\begin{DoxyCompactList}\small\item\em Create an untrained L\+SH model. \end{DoxyCompactList}\item 
\textbf{ L\+S\+H\+Search} (const \textbf{ L\+S\+H\+Search} \&other)
\begin{DoxyCompactList}\small\item\em Copy the given L\+SH model. \end{DoxyCompactList}\item 
\textbf{ L\+S\+H\+Search} (\textbf{ L\+S\+H\+Search} \&\&other)
\begin{DoxyCompactList}\small\item\em Take ownership of the given L\+SH model. \end{DoxyCompactList}\item 
size\+\_\+t \textbf{ Bucket\+Size} () const
\begin{DoxyCompactList}\small\item\em Get the bucket size of the second hash. \end{DoxyCompactList}\item 
size\+\_\+t \textbf{ Distance\+Evaluations} () const
\begin{DoxyCompactList}\small\item\em Return the number of distance evaluations performed. \end{DoxyCompactList}\item 
size\+\_\+t \& \textbf{ Distance\+Evaluations} ()
\begin{DoxyCompactList}\small\item\em Modify the number of distance evaluations performed. \end{DoxyCompactList}\item 
size\+\_\+t \textbf{ Num\+Projections} () const
\begin{DoxyCompactList}\small\item\em Get the number of projections. \end{DoxyCompactList}\item 
const arma\+::mat \& \textbf{ Offsets} () const
\begin{DoxyCompactList}\small\item\em Get the offsets \textquotesingle{}b\textquotesingle{} for each of the projections. (One \textquotesingle{}b\textquotesingle{} per column.) \end{DoxyCompactList}\item 
\textbf{ L\+S\+H\+Search} \& \textbf{ operator=} (const \textbf{ L\+S\+H\+Search} \&other)
\begin{DoxyCompactList}\small\item\em Copy the given L\+SH model. \end{DoxyCompactList}\item 
\textbf{ L\+S\+H\+Search} \& \textbf{ operator=} (\textbf{ L\+S\+H\+Search} \&\&other)
\begin{DoxyCompactList}\small\item\em Take ownership of the given L\+SH model. \end{DoxyCompactList}\item 
const arma\+::cube \& \textbf{ Projections} ()
\begin{DoxyCompactList}\small\item\em Get the projection tables. \end{DoxyCompactList}\item 
void \textbf{ Projections} (const arma\+::cube \&proj\+Tables)
\begin{DoxyCompactList}\small\item\em Change the projection tables (this retrains the L\+SH model). \end{DoxyCompactList}\item 
const Mat\+Type \& \textbf{ Reference\+Set} () const
\begin{DoxyCompactList}\small\item\em Return the reference dataset. \end{DoxyCompactList}\item 
void \textbf{ Search} (const Mat\+Type \&query\+Set, const size\+\_\+t k, arma\+::\+Mat$<$ size\+\_\+t $>$ \&resulting\+Neighbors, arma\+::mat \&distances, const size\+\_\+t num\+Tables\+To\+Search=0, const size\+\_\+t T=0)
\begin{DoxyCompactList}\small\item\em Compute the nearest neighbors of the points in the given query set and store the output in the given matrices. \end{DoxyCompactList}\item 
void \textbf{ Search} (const size\+\_\+t k, arma\+::\+Mat$<$ size\+\_\+t $>$ \&resulting\+Neighbors, arma\+::mat \&distances, const size\+\_\+t num\+Tables\+To\+Search=0, size\+\_\+t T=0)
\begin{DoxyCompactList}\small\item\em Compute the nearest neighbors and store the output in the given matrices. \end{DoxyCompactList}\item 
const std\+::vector$<$ arma\+::\+Col$<$ size\+\_\+t $>$ $>$ \& \textbf{ Second\+Hash\+Table} () const
\begin{DoxyCompactList}\small\item\em Get the second hash table. \end{DoxyCompactList}\item 
const arma\+::vec \& \textbf{ Second\+Hash\+Weights} () const
\begin{DoxyCompactList}\small\item\em Get the weights of the second hash. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Archive $>$ }\\void \textbf{ serialize} (Archive \&ar, const uint32\+\_\+t version)
\begin{DoxyCompactList}\small\item\em Serialize the L\+SH model. \end{DoxyCompactList}\item 
void \textbf{ Train} (Mat\+Type reference\+Set, const size\+\_\+t num\+Proj, const size\+\_\+t num\+Tables, const double hash\+Width=0.\+0, const size\+\_\+t second\+Hash\+Size=99901, const size\+\_\+t bucket\+Size=500, const arma\+::cube \&projection=arma\+::cube())
\begin{DoxyCompactList}\small\item\em Train the L\+SH model on the given dataset. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static double \textbf{ Compute\+Recall} (const arma\+::\+Mat$<$ size\+\_\+t $>$ \&found\+Neighbors, const arma\+::\+Mat$<$ size\+\_\+t $>$ \&real\+Neighbors)
\begin{DoxyCompactList}\small\item\em Compute the recall (\% of neighbors found) given the neighbors returned by \doxyref{L\+S\+H\+Search\+::\+Search}{p.}{classmlpack_1_1neighbor_1_1LSHSearch_a5cfd4af94030baa2f96d3765d94bfb67} and a \char`\"{}ground truth\char`\"{} set of neighbors. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
\subsubsection*{template$<$typename Sort\+Policy = Nearest\+Neighbor\+Sort, typename Mat\+Type = arma\+::mat$>$\newline
class mlpack\+::neighbor\+::\+L\+S\+H\+Search$<$ Sort\+Policy, Mat\+Type $>$}

The \doxyref{L\+S\+H\+Search}{p.}{classmlpack_1_1neighbor_1_1LSHSearch} class; this class builds a hash on the reference set and uses this hash to compute the distance-\/approximate nearest-\/neighbors of the given queries. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Sort\+Policy} & The sort policy for distances; see Nearest\+Neighbor\+Sort. \\
\hline
{\em Mat\+Type} & Type of matrix to use to store the data. \\
\hline
\end{DoxyTemplParams}


Definition at line 72 of file lsh\+\_\+search.\+hpp.



\subsection{Constructor \& Destructor Documentation}
\mbox{\label{classmlpack_1_1neighbor_1_1LSHSearch_a4cfb6dba5b3700cd827a6a2f2c9da539}} 
\index{mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}!L\+S\+H\+Search@{L\+S\+H\+Search}}
\index{L\+S\+H\+Search@{L\+S\+H\+Search}!mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}}
\subsubsection{L\+S\+H\+Search()\hspace{0.1cm}{\footnotesize\ttfamily [1/5]}}
{\footnotesize\ttfamily \textbf{ L\+S\+H\+Search} (\begin{DoxyParamCaption}\item[{Mat\+Type}]{reference\+Set,  }\item[{const arma\+::cube \&}]{projections,  }\item[{const double}]{hash\+Width = {\ttfamily 0.0},  }\item[{const size\+\_\+t}]{second\+Hash\+Size = {\ttfamily 99901},  }\item[{const size\+\_\+t}]{bucket\+Size = {\ttfamily 500} }\end{DoxyParamCaption})}



This function initializes the L\+SH class. 

It builds the hash on the reference set with 2-\/stable distributions. See the individual functions performing the hashing for details on how the hashing is done. In order to avoid copying the reference set, it is suggested to pass that parameter with std\+::move().


\begin{DoxyParams}{Parameters}
{\em reference\+Set} & Set of reference points and the set of queries. \\
\hline
{\em projections} & Cube of projection tables. For a cube of size (a, b, c) we set num\+Proj = a, num\+Tables = c. b is the reference set dimensionality. \\
\hline
{\em hash\+Width} & The width of hash for every table. If 0 (the default) is provided, then the hash width is automatically obtained by computing the average pairwise distance of 25 pairs. This should be a reasonable upper bound on the nearest-\/neighbor distance in general. \\
\hline
{\em second\+Hash\+Size} & The size of the second hash table. This should be a large prime number. \\
\hline
{\em bucket\+Size} & The size of the bucket in the second hash table. This is the maximum number of points that can be hashed into single bucket. A value of 0 indicates that there is no limit (so the second hash table can be arbitrarily large---be careful!). \\
\hline
\end{DoxyParams}
\mbox{\label{classmlpack_1_1neighbor_1_1LSHSearch_a8a0c00e059fcbba30170b84f55d16e4e}} 
\index{mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}!L\+S\+H\+Search@{L\+S\+H\+Search}}
\index{L\+S\+H\+Search@{L\+S\+H\+Search}!mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}}
\subsubsection{L\+S\+H\+Search()\hspace{0.1cm}{\footnotesize\ttfamily [2/5]}}
{\footnotesize\ttfamily \textbf{ L\+S\+H\+Search} (\begin{DoxyParamCaption}\item[{Mat\+Type}]{reference\+Set,  }\item[{const size\+\_\+t}]{num\+Proj,  }\item[{const size\+\_\+t}]{num\+Tables,  }\item[{const double}]{hash\+Width = {\ttfamily 0.0},  }\item[{const size\+\_\+t}]{second\+Hash\+Size = {\ttfamily 99901},  }\item[{const size\+\_\+t}]{bucket\+Size = {\ttfamily 500} }\end{DoxyParamCaption})}



This function initializes the L\+SH class. 

It builds the hash one the reference set using the provided projections. See the individual functions performing the hashing for details on how the hashing is done. In order to avoid copying the reference set, consider passing the set with std\+::move().


\begin{DoxyParams}{Parameters}
{\em reference\+Set} & Set of reference points and the set of queries. \\
\hline
{\em num\+Proj} & Number of projections in each hash table (anything between 10-\/50 might be a decent choice). \\
\hline
{\em num\+Tables} & Total number of hash tables (anything between 10-\/20 should suffice). \\
\hline
{\em hash\+Width} & The width of hash for every table. If 0 (the default) is provided, then the hash width is automatically obtained by computing the average pairwise distance of 25 pairs. This should be a reasonable upper bound on the nearest-\/neighbor distance in general. \\
\hline
{\em second\+Hash\+Size} & The size of the second hash table. This should be a large prime number. \\
\hline
{\em bucket\+Size} & The size of the bucket in the second hash table. This is the maximum number of points that can be hashed into single bucket. A value of 0 indicates that there is no limit (so the second hash table can be arbitrarily large---be careful!). \\
\hline
\end{DoxyParams}
\mbox{\label{classmlpack_1_1neighbor_1_1LSHSearch_a3f0dfc59a1df743a8e957e86f7b4d5cb}} 
\index{mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}!L\+S\+H\+Search@{L\+S\+H\+Search}}
\index{L\+S\+H\+Search@{L\+S\+H\+Search}!mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}}
\subsubsection{L\+S\+H\+Search()\hspace{0.1cm}{\footnotesize\ttfamily [3/5]}}
{\footnotesize\ttfamily \textbf{ L\+S\+H\+Search} (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Create an untrained L\+SH model. 

Be sure to call \doxyref{Train()}{p.}{classmlpack_1_1neighbor_1_1LSHSearch_aab63c514ca5f72f3dccf3edfa239b4a3} before calling \doxyref{Search()}{p.}{classmlpack_1_1neighbor_1_1LSHSearch_a5cfd4af94030baa2f96d3765d94bfb67}; otherwise, an exception will be thrown when \doxyref{Search()}{p.}{classmlpack_1_1neighbor_1_1LSHSearch_a5cfd4af94030baa2f96d3765d94bfb67} is called. \mbox{\label{classmlpack_1_1neighbor_1_1LSHSearch_a7e18777df2330a993d90ca38052e811b}} 
\index{mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}!L\+S\+H\+Search@{L\+S\+H\+Search}}
\index{L\+S\+H\+Search@{L\+S\+H\+Search}!mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}}
\subsubsection{L\+S\+H\+Search()\hspace{0.1cm}{\footnotesize\ttfamily [4/5]}}
{\footnotesize\ttfamily \textbf{ L\+S\+H\+Search} (\begin{DoxyParamCaption}\item[{const \textbf{ L\+S\+H\+Search}$<$ Sort\+Policy, Mat\+Type $>$ \&}]{other }\end{DoxyParamCaption})}



Copy the given L\+SH model. 


\begin{DoxyParams}{Parameters}
{\em other} & Other L\+SH model to copy. \\
\hline
\end{DoxyParams}
\mbox{\label{classmlpack_1_1neighbor_1_1LSHSearch_a38e414198da33966c5685761e203ced6}} 
\index{mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}!L\+S\+H\+Search@{L\+S\+H\+Search}}
\index{L\+S\+H\+Search@{L\+S\+H\+Search}!mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}}
\subsubsection{L\+S\+H\+Search()\hspace{0.1cm}{\footnotesize\ttfamily [5/5]}}
{\footnotesize\ttfamily \textbf{ L\+S\+H\+Search} (\begin{DoxyParamCaption}\item[{\textbf{ L\+S\+H\+Search}$<$ Sort\+Policy, Mat\+Type $>$ \&\&}]{other }\end{DoxyParamCaption})}



Take ownership of the given L\+SH model. 


\begin{DoxyParams}{Parameters}
{\em other} & Other L\+SH model to take ownership of. \\
\hline
\end{DoxyParams}


\subsection{Member Function Documentation}
\mbox{\label{classmlpack_1_1neighbor_1_1LSHSearch_a02905662835f4c07653df0773e0db6f3}} 
\index{mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}!Bucket\+Size@{Bucket\+Size}}
\index{Bucket\+Size@{Bucket\+Size}!mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}}
\subsubsection{Bucket\+Size()}
{\footnotesize\ttfamily size\+\_\+t Bucket\+Size (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Get the bucket size of the second hash. 



Definition at line 291 of file lsh\+\_\+search.\+hpp.

\mbox{\label{classmlpack_1_1neighbor_1_1LSHSearch_a5e22f2820bf8ef0005b10d9f8d2c73b5}} 
\index{mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}!Compute\+Recall@{Compute\+Recall}}
\index{Compute\+Recall@{Compute\+Recall}!mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}}
\subsubsection{Compute\+Recall()}
{\footnotesize\ttfamily static double Compute\+Recall (\begin{DoxyParamCaption}\item[{const arma\+::\+Mat$<$ size\+\_\+t $>$ \&}]{found\+Neighbors,  }\item[{const arma\+::\+Mat$<$ size\+\_\+t $>$ \&}]{real\+Neighbors }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Compute the recall (\% of neighbors found) given the neighbors returned by \doxyref{L\+S\+H\+Search\+::\+Search}{p.}{classmlpack_1_1neighbor_1_1LSHSearch_a5cfd4af94030baa2f96d3765d94bfb67} and a \char`\"{}ground truth\char`\"{} set of neighbors. 

The recall returned will be in the range [0, 1].


\begin{DoxyParams}{Parameters}
{\em found\+Neighbors} & Set of neighbors to compute recall of. \\
\hline
{\em real\+Neighbors} & Set of \char`\"{}ground truth\char`\"{} neighbors to compute recall against. \\
\hline
\end{DoxyParams}
\mbox{\label{classmlpack_1_1neighbor_1_1LSHSearch_afafe9a518f2b8fb1643809a51af2dacf}} 
\index{mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}!Distance\+Evaluations@{Distance\+Evaluations}}
\index{Distance\+Evaluations@{Distance\+Evaluations}!mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}}
\subsubsection{Distance\+Evaluations()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily size\+\_\+t Distance\+Evaluations (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Return the number of distance evaluations performed. 



Definition at line 274 of file lsh\+\_\+search.\+hpp.

\mbox{\label{classmlpack_1_1neighbor_1_1LSHSearch_af9fadea5b764d312c040a70e5d6951ce}} 
\index{mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}!Distance\+Evaluations@{Distance\+Evaluations}}
\index{Distance\+Evaluations@{Distance\+Evaluations}!mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}}
\subsubsection{Distance\+Evaluations()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily size\+\_\+t\& Distance\+Evaluations (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Modify the number of distance evaluations performed. 



Definition at line 276 of file lsh\+\_\+search.\+hpp.

\mbox{\label{classmlpack_1_1neighbor_1_1LSHSearch_a1781bad06c46fac9a519e8cbc66c7758}} 
\index{mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}!Num\+Projections@{Num\+Projections}}
\index{Num\+Projections@{Num\+Projections}!mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}}
\subsubsection{Num\+Projections()}
{\footnotesize\ttfamily size\+\_\+t Num\+Projections (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Get the number of projections. 



Definition at line 282 of file lsh\+\_\+search.\+hpp.

\mbox{\label{classmlpack_1_1neighbor_1_1LSHSearch_a84fb2bebd168520b625e4d451f336398}} 
\index{mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}!Offsets@{Offsets}}
\index{Offsets@{Offsets}!mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}}
\subsubsection{Offsets()}
{\footnotesize\ttfamily const arma\+::mat\& Offsets (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Get the offsets \textquotesingle{}b\textquotesingle{} for each of the projections. (One \textquotesingle{}b\textquotesingle{} per column.) 



Definition at line 285 of file lsh\+\_\+search.\+hpp.

\mbox{\label{classmlpack_1_1neighbor_1_1LSHSearch_af87212c7b6ef0dbd59bff8cf6e86a4cb}} 
\index{mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}!operator=@{operator=}}
\index{operator=@{operator=}!mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}}
\subsubsection{operator=()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \textbf{ L\+S\+H\+Search}\& operator= (\begin{DoxyParamCaption}\item[{const \textbf{ L\+S\+H\+Search}$<$ Sort\+Policy, Mat\+Type $>$ \&}]{other }\end{DoxyParamCaption})}



Copy the given L\+SH model. 


\begin{DoxyParams}{Parameters}
{\em other} & Other L\+SH model to copy. \\
\hline
\end{DoxyParams}
\mbox{\label{classmlpack_1_1neighbor_1_1LSHSearch_a0d05ace1d0fd6395f7b1df3c20f55af9}} 
\index{mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}!operator=@{operator=}}
\index{operator=@{operator=}!mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}}
\subsubsection{operator=()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \textbf{ L\+S\+H\+Search}\& operator= (\begin{DoxyParamCaption}\item[{\textbf{ L\+S\+H\+Search}$<$ Sort\+Policy, Mat\+Type $>$ \&\&}]{other }\end{DoxyParamCaption})}



Take ownership of the given L\+SH model. 


\begin{DoxyParams}{Parameters}
{\em other} & Other L\+SH model to take ownership of. \\
\hline
\end{DoxyParams}
\mbox{\label{classmlpack_1_1neighbor_1_1LSHSearch_a63e14758f25866a71ca24ac6d5046232}} 
\index{mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}!Projections@{Projections}}
\index{Projections@{Projections}!mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}}
\subsubsection{Projections()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily const arma\+::cube\& Projections (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Get the projection tables. 



Definition at line 298 of file lsh\+\_\+search.\+hpp.

\mbox{\label{classmlpack_1_1neighbor_1_1LSHSearch_ab5c03969d08d7534de9a07d863e1019d}} 
\index{mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}!Projections@{Projections}}
\index{Projections@{Projections}!mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}}
\subsubsection{Projections()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void Projections (\begin{DoxyParamCaption}\item[{const arma\+::cube \&}]{proj\+Tables }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Change the projection tables (this retrains the L\+SH model). 



Definition at line 301 of file lsh\+\_\+search.\+hpp.



References L\+S\+H\+Search$<$ Sort\+Policy, Mat\+Type $>$\+::\+Train().

\mbox{\label{classmlpack_1_1neighbor_1_1LSHSearch_a0a975940b302b4efec85bbe2d8b36251}} 
\index{mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}!Reference\+Set@{Reference\+Set}}
\index{Reference\+Set@{Reference\+Set}!mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}}
\subsubsection{Reference\+Set()}
{\footnotesize\ttfamily const Mat\+Type\& Reference\+Set (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Return the reference dataset. 



Definition at line 279 of file lsh\+\_\+search.\+hpp.

\mbox{\label{classmlpack_1_1neighbor_1_1LSHSearch_a5cfd4af94030baa2f96d3765d94bfb67}} 
\index{mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}!Search@{Search}}
\index{Search@{Search}!mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}}
\subsubsection{Search()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void Search (\begin{DoxyParamCaption}\item[{const Mat\+Type \&}]{query\+Set,  }\item[{const size\+\_\+t}]{k,  }\item[{arma\+::\+Mat$<$ size\+\_\+t $>$ \&}]{resulting\+Neighbors,  }\item[{arma\+::mat \&}]{distances,  }\item[{const size\+\_\+t}]{num\+Tables\+To\+Search = {\ttfamily 0},  }\item[{const size\+\_\+t}]{T = {\ttfamily 0} }\end{DoxyParamCaption})}



Compute the nearest neighbors of the points in the given query set and store the output in the given matrices. 

The matrices will be set to the size of n columns by k rows, where n is the number of points in the query dataset and k is the number of neighbors being searched for.


\begin{DoxyParams}{Parameters}
{\em query\+Set} & Set of query points. \\
\hline
{\em k} & Number of neighbors to search for. \\
\hline
{\em resulting\+Neighbors} & Matrix storing lists of neighbors for each query point. \\
\hline
{\em distances} & Matrix storing distances of neighbors for each query point. \\
\hline
{\em num\+Tables\+To\+Search} & This parameter allows the user to have control over the number of hash tables to be searched. This allows the user to pick the number of tables it can afford for the time available without having to build hashing for every table size. By default, this is set to zero in which case all tables are considered. \\
\hline
{\em T} & The number of additional probing bins to examine with multiprobe L\+SH. If T = 0, classic single-\/probe L\+SH is run (default). \\
\hline
\end{DoxyParams}
\mbox{\label{classmlpack_1_1neighbor_1_1LSHSearch_aefffa95464b5cb9d6aabfc1fbe7b420d}} 
\index{mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}!Search@{Search}}
\index{Search@{Search}!mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}}
\subsubsection{Search()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void Search (\begin{DoxyParamCaption}\item[{const size\+\_\+t}]{k,  }\item[{arma\+::\+Mat$<$ size\+\_\+t $>$ \&}]{resulting\+Neighbors,  }\item[{arma\+::mat \&}]{distances,  }\item[{const size\+\_\+t}]{num\+Tables\+To\+Search = {\ttfamily 0},  }\item[{size\+\_\+t}]{T = {\ttfamily 0} }\end{DoxyParamCaption})}



Compute the nearest neighbors and store the output in the given matrices. 

The matrices will be set to the size of n columns by k rows, where n is the number of points in the query dataset and k is the number of neighbors being searched for.


\begin{DoxyParams}{Parameters}
{\em k} & Number of neighbors to search for. \\
\hline
{\em resulting\+Neighbors} & Matrix storing lists of neighbors for each query point. \\
\hline
{\em distances} & Matrix storing distances of neighbors for each query point. \\
\hline
{\em num\+Tables\+To\+Search} & This parameter allows the user to have control over the number of hash tables to be searched. This allows the user to pick the number of tables it can afford for the time available without having to build hashing for every table size. By default, this is set to zero in which case all tables are considered. \\
\hline
{\em T} & Number of probing bins. \\
\hline
\end{DoxyParams}
\mbox{\label{classmlpack_1_1neighbor_1_1LSHSearch_ac4bdf7cfa1f81b5fc9db761f9505c2a7}} 
\index{mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}!Second\+Hash\+Table@{Second\+Hash\+Table}}
\index{Second\+Hash\+Table@{Second\+Hash\+Table}!mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}}
\subsubsection{Second\+Hash\+Table()}
{\footnotesize\ttfamily const std\+::vector$<$arma\+::\+Col$<$size\+\_\+t$>$ $>$\& Second\+Hash\+Table (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Get the second hash table. 



Definition at line 294 of file lsh\+\_\+search.\+hpp.

\mbox{\label{classmlpack_1_1neighbor_1_1LSHSearch_aadec61275f680335c8f795c21ee35b41}} 
\index{mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}!Second\+Hash\+Weights@{Second\+Hash\+Weights}}
\index{Second\+Hash\+Weights@{Second\+Hash\+Weights}!mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}}
\subsubsection{Second\+Hash\+Weights()}
{\footnotesize\ttfamily const arma\+::vec\& Second\+Hash\+Weights (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Get the weights of the second hash. 



Definition at line 288 of file lsh\+\_\+search.\+hpp.

\mbox{\label{classmlpack_1_1neighbor_1_1LSHSearch_a72d63b74c8166dff8e1a9006905ad9ca}} 
\index{mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}!serialize@{serialize}}
\index{serialize@{serialize}!mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}}
\subsubsection{serialize()}
{\footnotesize\ttfamily void serialize (\begin{DoxyParamCaption}\item[{Archive \&}]{ar,  }\item[{const uint32\+\_\+t}]{version }\end{DoxyParamCaption})}



Serialize the L\+SH model. 


\begin{DoxyParams}{Parameters}
{\em ar} & Archive to serialize to. \\
\hline
{\em version} & serialize class version to provide backward compatibility \\
\hline
\end{DoxyParams}
\mbox{\label{classmlpack_1_1neighbor_1_1LSHSearch_aab63c514ca5f72f3dccf3edfa239b4a3}} 
\index{mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}!Train@{Train}}
\index{Train@{Train}!mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}}
\subsubsection{Train()}
{\footnotesize\ttfamily void Train (\begin{DoxyParamCaption}\item[{Mat\+Type}]{reference\+Set,  }\item[{const size\+\_\+t}]{num\+Proj,  }\item[{const size\+\_\+t}]{num\+Tables,  }\item[{const double}]{hash\+Width = {\ttfamily 0.0},  }\item[{const size\+\_\+t}]{second\+Hash\+Size = {\ttfamily 99901},  }\item[{const size\+\_\+t}]{bucket\+Size = {\ttfamily 500},  }\item[{const arma\+::cube \&}]{projection = {\ttfamily arma\+:\+:cube()} }\end{DoxyParamCaption})}



Train the L\+SH model on the given dataset. 

If a correctly-\/sized projection cube is not provided, this means building new hash tables. Otherwise, we use the projections provided by the user. In order to avoid copying the reference set, consider passing that parameter with std\+::move().


\begin{DoxyParams}{Parameters}
{\em reference\+Set} & Set of reference points and the set of queries. \\
\hline
{\em num\+Proj} & Number of projections in each hash table (anything between 10-\/50 might be a decent choice). \\
\hline
{\em num\+Tables} & Total number of hash tables (anything between 10-\/20 should suffice). \\
\hline
{\em hash\+Width} & The width of hash for every table. If 0 (the default) is provided, then the hash width is automatically obtained by computing the average pairwise distance of 25 pairs. This should be a reasonable upper bound on the nearest-\/neighbor distance in general. \\
\hline
{\em second\+Hash\+Size} & The size of the second hash table. This should be a large prime number. \\
\hline
{\em bucket\+Size} & The size of the bucket in the second hash table. This is the maximum number of points that can be hashed into single bucket. A value of 0 indicates that there is no limit (so the second hash table can be arbitrarily large---be careful!). \\
\hline
{\em projection} & Cube of projection tables. For a cube of size (a, b, c) we set num\+Proj = a, num\+Tables = c. b is the reference set dimensionality. \\
\hline
\end{DoxyParams}


Referenced by L\+S\+H\+Search$<$ Sort\+Policy, Mat\+Type $>$\+::\+Projections().



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
/home/aakash/mlpack/src/mlpack/methods/lsh/\textbf{ lsh\+\_\+search.\+hpp}\end{DoxyCompactItemize}
