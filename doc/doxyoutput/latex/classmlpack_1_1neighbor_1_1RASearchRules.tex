\section{R\+A\+Search\+Rules$<$ Sort\+Policy, Metric\+Type, Tree\+Type $>$ Class Template Reference}
\label{classmlpack_1_1neighbor_1_1RASearchRules}\index{R\+A\+Search\+Rules$<$ Sort\+Policy, Metric\+Type, Tree\+Type $>$@{R\+A\+Search\+Rules$<$ Sort\+Policy, Metric\+Type, Tree\+Type $>$}}


The \doxyref{R\+A\+Search\+Rules}{p.}{classmlpack_1_1neighbor_1_1RASearchRules} class is a template helper class used by \doxyref{R\+A\+Search}{p.}{classmlpack_1_1neighbor_1_1RASearch} class when performing rank-\/approximate search via random-\/sampling.  


\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
typedef \textbf{ tree\+::\+Traversal\+Info}$<$ Tree\+Type $>$ \textbf{ Traversal\+Info\+Type}
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\textbf{ R\+A\+Search\+Rules} (const arma\+::mat \&reference\+Set, const arma\+::mat \&query\+Set, const size\+\_\+t k, Metric\+Type \&metric, const double tau=5, const double alpha=0.\+95, const bool naive=false, const bool sample\+At\+Leaves=false, const bool first\+Leaf\+Exact=false, const size\+\_\+t single\+Sample\+Limit=20, const bool same\+Set=false)
\begin{DoxyCompactList}\small\item\em Construct the \doxyref{R\+A\+Search\+Rules}{p.}{classmlpack_1_1neighbor_1_1RASearchRules} object. \end{DoxyCompactList}\item 
double \textbf{ Base\+Case} (const size\+\_\+t query\+Index, const size\+\_\+t reference\+Index)
\begin{DoxyCompactList}\small\item\em Get the distance from the query point to the reference point. \end{DoxyCompactList}\item 
void \textbf{ Get\+Results} (arma\+::\+Mat$<$ size\+\_\+t $>$ \&neighbors, arma\+::mat \&distances)
\begin{DoxyCompactList}\small\item\em Store the list of candidates for each query point in the given matrices. \end{DoxyCompactList}\item 
size\+\_\+t \textbf{ Minimum\+Base\+Cases} () const
\begin{DoxyCompactList}\small\item\em Get the minimum number of base cases that must be performed for each query point for an acceptable result. \end{DoxyCompactList}\item 
size\+\_\+t \textbf{ Num\+Dist\+Computations} ()
\item 
size\+\_\+t \textbf{ Num\+Effective\+Samples} ()
\item 
double \textbf{ Rescore} (const size\+\_\+t query\+Index, Tree\+Type \&reference\+Node, const double old\+Score)
\begin{DoxyCompactList}\small\item\em Re-\/evaluate the score for recursion order. \end{DoxyCompactList}\item 
double \textbf{ Rescore} (Tree\+Type \&query\+Node, Tree\+Type \&reference\+Node, const double old\+Score)
\begin{DoxyCompactList}\small\item\em Re-\/evaluate the score for recursion order. \end{DoxyCompactList}\item 
double \textbf{ Score} (const size\+\_\+t query\+Index, Tree\+Type \&reference\+Node)
\begin{DoxyCompactList}\small\item\em Get the score for recursion order. \end{DoxyCompactList}\item 
double \textbf{ Score} (const size\+\_\+t query\+Index, Tree\+Type \&reference\+Node, const double base\+Case\+Result)
\begin{DoxyCompactList}\small\item\em Get the score for recursion order. \end{DoxyCompactList}\item 
double \textbf{ Score} (Tree\+Type \&query\+Node, Tree\+Type \&reference\+Node)
\begin{DoxyCompactList}\small\item\em Get the score for recursion order. \end{DoxyCompactList}\item 
double \textbf{ Score} (Tree\+Type \&query\+Node, Tree\+Type \&reference\+Node, const double base\+Case\+Result)
\begin{DoxyCompactList}\small\item\em Get the score for recursion order, passing the base case result (in the situation where it may be needed to calculate the recursion order). \end{DoxyCompactList}\item 
const \textbf{ Traversal\+Info\+Type} \& \textbf{ Traversal\+Info} () const
\item 
\textbf{ Traversal\+Info\+Type} \& \textbf{ Traversal\+Info} ()
\end{DoxyCompactItemize}


\subsection{Detailed Description}
\subsubsection*{template$<$typename Sort\+Policy, typename Metric\+Type, typename Tree\+Type$>$\newline
class mlpack\+::neighbor\+::\+R\+A\+Search\+Rules$<$ Sort\+Policy, Metric\+Type, Tree\+Type $>$}

The \doxyref{R\+A\+Search\+Rules}{p.}{classmlpack_1_1neighbor_1_1RASearchRules} class is a template helper class used by \doxyref{R\+A\+Search}{p.}{classmlpack_1_1neighbor_1_1RASearch} class when performing rank-\/approximate search via random-\/sampling. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Sort\+Policy} & The sort policy for distances. \\
\hline
{\em Metric\+Type} & The metric to use for computation. \\
\hline
{\em Tree\+Type} & The tree type to use; must adhere to the Tree\+Type A\+PI. \\
\hline
\end{DoxyTemplParams}


Definition at line 33 of file ra\+\_\+search\+\_\+rules.\+hpp.



\subsection{Member Typedef Documentation}
\mbox{\label{classmlpack_1_1neighbor_1_1RASearchRules_ab5f079db10d0a6813eefeb1115e894cb}} 
\index{mlpack\+::neighbor\+::\+R\+A\+Search\+Rules@{mlpack\+::neighbor\+::\+R\+A\+Search\+Rules}!Traversal\+Info\+Type@{Traversal\+Info\+Type}}
\index{Traversal\+Info\+Type@{Traversal\+Info\+Type}!mlpack\+::neighbor\+::\+R\+A\+Search\+Rules@{mlpack\+::neighbor\+::\+R\+A\+Search\+Rules}}
\subsubsection{Traversal\+Info\+Type}
{\footnotesize\ttfamily typedef \textbf{ tree\+::\+Traversal\+Info}$<$Tree\+Type$>$ \textbf{ Traversal\+Info\+Type}}



Definition at line 239 of file ra\+\_\+search\+\_\+rules.\+hpp.



\subsection{Constructor \& Destructor Documentation}
\mbox{\label{classmlpack_1_1neighbor_1_1RASearchRules_aa215aa687871d891ee298e5be340cd32}} 
\index{mlpack\+::neighbor\+::\+R\+A\+Search\+Rules@{mlpack\+::neighbor\+::\+R\+A\+Search\+Rules}!R\+A\+Search\+Rules@{R\+A\+Search\+Rules}}
\index{R\+A\+Search\+Rules@{R\+A\+Search\+Rules}!mlpack\+::neighbor\+::\+R\+A\+Search\+Rules@{mlpack\+::neighbor\+::\+R\+A\+Search\+Rules}}
\subsubsection{R\+A\+Search\+Rules()}
{\footnotesize\ttfamily \textbf{ R\+A\+Search\+Rules} (\begin{DoxyParamCaption}\item[{const arma\+::mat \&}]{reference\+Set,  }\item[{const arma\+::mat \&}]{query\+Set,  }\item[{const size\+\_\+t}]{k,  }\item[{Metric\+Type \&}]{metric,  }\item[{const double}]{tau = {\ttfamily 5},  }\item[{const double}]{alpha = {\ttfamily 0.95},  }\item[{const bool}]{naive = {\ttfamily false},  }\item[{const bool}]{sample\+At\+Leaves = {\ttfamily false},  }\item[{const bool}]{first\+Leaf\+Exact = {\ttfamily false},  }\item[{const size\+\_\+t}]{single\+Sample\+Limit = {\ttfamily 20},  }\item[{const bool}]{same\+Set = {\ttfamily false} }\end{DoxyParamCaption})}



Construct the \doxyref{R\+A\+Search\+Rules}{p.}{classmlpack_1_1neighbor_1_1RASearchRules} object. 

This is usually done from within the \doxyref{R\+A\+Search}{p.}{classmlpack_1_1neighbor_1_1RASearch} class at search time.


\begin{DoxyParams}{Parameters}
{\em reference\+Set} & Set of reference data. \\
\hline
{\em query\+Set} & Set of query data. \\
\hline
{\em k} & Number of neighbors to search for. \\
\hline
{\em metric} & Instantiated metric. \\
\hline
{\em tau} & The rank-\/approximation in percentile of the data. \\
\hline
{\em alpha} & The desired success probability. \\
\hline
{\em naive} & If true, the rank-\/approximate search will be performed by directly sampling the whole set instead of using the stratified sampling on the tree. \\
\hline
{\em sample\+At\+Leaves} & Sample at leaves for faster but less accurate computation. \\
\hline
{\em first\+Leaf\+Exact} & Traverse to the first leaf without approximation. \\
\hline
{\em single\+Sample\+Limit} & The limit on the largest node that can be approximated by sampling. \\
\hline
{\em same\+Set} & If true, the query and reference set are taken to be the same, and a query point will not return itself in the results. \\
\hline
\end{DoxyParams}


\subsection{Member Function Documentation}
\mbox{\label{classmlpack_1_1neighbor_1_1RASearchRules_abac50f780bb5e1bc12dd0d16d850cacc}} 
\index{mlpack\+::neighbor\+::\+R\+A\+Search\+Rules@{mlpack\+::neighbor\+::\+R\+A\+Search\+Rules}!Base\+Case@{Base\+Case}}
\index{Base\+Case@{Base\+Case}!mlpack\+::neighbor\+::\+R\+A\+Search\+Rules@{mlpack\+::neighbor\+::\+R\+A\+Search\+Rules}}
\subsubsection{Base\+Case()}
{\footnotesize\ttfamily double Base\+Case (\begin{DoxyParamCaption}\item[{const size\+\_\+t}]{query\+Index,  }\item[{const size\+\_\+t}]{reference\+Index }\end{DoxyParamCaption})}



Get the distance from the query point to the reference point. 

This will update the list of candidates with the new point if appropriate.


\begin{DoxyParams}{Parameters}
{\em query\+Index} & Index of query point. \\
\hline
{\em reference\+Index} & Index of reference point. \\
\hline
\end{DoxyParams}
\mbox{\label{classmlpack_1_1neighbor_1_1RASearchRules_add24e5e55e4b8555dbd941b137a44491}} 
\index{mlpack\+::neighbor\+::\+R\+A\+Search\+Rules@{mlpack\+::neighbor\+::\+R\+A\+Search\+Rules}!Get\+Results@{Get\+Results}}
\index{Get\+Results@{Get\+Results}!mlpack\+::neighbor\+::\+R\+A\+Search\+Rules@{mlpack\+::neighbor\+::\+R\+A\+Search\+Rules}}
\subsubsection{Get\+Results()}
{\footnotesize\ttfamily void Get\+Results (\begin{DoxyParamCaption}\item[{arma\+::\+Mat$<$ size\+\_\+t $>$ \&}]{neighbors,  }\item[{arma\+::mat \&}]{distances }\end{DoxyParamCaption})}



Store the list of candidates for each query point in the given matrices. 


\begin{DoxyParams}{Parameters}
{\em neighbors} & Matrix storing lists of neighbors for each query point. \\
\hline
{\em distances} & Matrix storing distances of neighbors for each query point. \\
\hline
\end{DoxyParams}
\mbox{\label{classmlpack_1_1neighbor_1_1RASearchRules_a469f61784f9cce8f2574c23823405768}} 
\index{mlpack\+::neighbor\+::\+R\+A\+Search\+Rules@{mlpack\+::neighbor\+::\+R\+A\+Search\+Rules}!Minimum\+Base\+Cases@{Minimum\+Base\+Cases}}
\index{Minimum\+Base\+Cases@{Minimum\+Base\+Cases}!mlpack\+::neighbor\+::\+R\+A\+Search\+Rules@{mlpack\+::neighbor\+::\+R\+A\+Search\+Rules}}
\subsubsection{Minimum\+Base\+Cases()}
{\footnotesize\ttfamily size\+\_\+t Minimum\+Base\+Cases (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Get the minimum number of base cases that must be performed for each query point for an acceptable result. 

This is only needed in defeatist search mode. 

Definition at line 247 of file ra\+\_\+search\+\_\+rules.\+hpp.



References R\+A\+Search\+Rules$<$ Sort\+Policy, Metric\+Type, Tree\+Type $>$\+::\+Score().

\mbox{\label{classmlpack_1_1neighbor_1_1RASearchRules_a04b73c5ab1e330598f52d8eeb307b93e}} 
\index{mlpack\+::neighbor\+::\+R\+A\+Search\+Rules@{mlpack\+::neighbor\+::\+R\+A\+Search\+Rules}!Num\+Dist\+Computations@{Num\+Dist\+Computations}}
\index{Num\+Dist\+Computations@{Num\+Dist\+Computations}!mlpack\+::neighbor\+::\+R\+A\+Search\+Rules@{mlpack\+::neighbor\+::\+R\+A\+Search\+Rules}}
\subsubsection{Num\+Dist\+Computations()}
{\footnotesize\ttfamily size\+\_\+t Num\+Dist\+Computations (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line 230 of file ra\+\_\+search\+\_\+rules.\+hpp.

\mbox{\label{classmlpack_1_1neighbor_1_1RASearchRules_af9de23bafc455c99bc6d96a00386b025}} 
\index{mlpack\+::neighbor\+::\+R\+A\+Search\+Rules@{mlpack\+::neighbor\+::\+R\+A\+Search\+Rules}!Num\+Effective\+Samples@{Num\+Effective\+Samples}}
\index{Num\+Effective\+Samples@{Num\+Effective\+Samples}!mlpack\+::neighbor\+::\+R\+A\+Search\+Rules@{mlpack\+::neighbor\+::\+R\+A\+Search\+Rules}}
\subsubsection{Num\+Effective\+Samples()}
{\footnotesize\ttfamily size\+\_\+t Num\+Effective\+Samples (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line 231 of file ra\+\_\+search\+\_\+rules.\+hpp.

\mbox{\label{classmlpack_1_1neighbor_1_1RASearchRules_a6f97dd07745e07a2d7ff3d4a42347e48}} 
\index{mlpack\+::neighbor\+::\+R\+A\+Search\+Rules@{mlpack\+::neighbor\+::\+R\+A\+Search\+Rules}!Rescore@{Rescore}}
\index{Rescore@{Rescore}!mlpack\+::neighbor\+::\+R\+A\+Search\+Rules@{mlpack\+::neighbor\+::\+R\+A\+Search\+Rules}}
\subsubsection{Rescore()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily double Rescore (\begin{DoxyParamCaption}\item[{const size\+\_\+t}]{query\+Index,  }\item[{Tree\+Type \&}]{reference\+Node,  }\item[{const double}]{old\+Score }\end{DoxyParamCaption})}



Re-\/evaluate the score for recursion order. 

A low score indicates priority for recursion, while D\+B\+L\+\_\+\+M\+AX indicates that the node should not be recursed into at all (it should be pruned). This is used when the score has already been calculated, but another recursion may have modified the bounds for pruning. So the old score is checked against the new pruning bound.

For rank-\/approximation, it also checks if the number of samples left for a query to satisfy the rank constraint is small enough at this point of the algorithm, then this node is approximated by sampling and given a new score of \textquotesingle{}D\+B\+L\+\_\+\+M\+AX\textquotesingle{}.


\begin{DoxyParams}{Parameters}
{\em query\+Index} & Index of query point. \\
\hline
{\em reference\+Node} & Candidate node to be recursed into. \\
\hline
{\em old\+Score} & Old score produced by \doxyref{Score()}{p.}{classmlpack_1_1neighbor_1_1RASearchRules_a53d373b7aeee359b0e686f823c602b1c} (or \doxyref{Rescore()}{p.}{classmlpack_1_1neighbor_1_1RASearchRules_a6f97dd07745e07a2d7ff3d4a42347e48}). \\
\hline
\end{DoxyParams}
\mbox{\label{classmlpack_1_1neighbor_1_1RASearchRules_a355b654f0c696bfe4f7be6d98c96d1ee}} 
\index{mlpack\+::neighbor\+::\+R\+A\+Search\+Rules@{mlpack\+::neighbor\+::\+R\+A\+Search\+Rules}!Rescore@{Rescore}}
\index{Rescore@{Rescore}!mlpack\+::neighbor\+::\+R\+A\+Search\+Rules@{mlpack\+::neighbor\+::\+R\+A\+Search\+Rules}}
\subsubsection{Rescore()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily double Rescore (\begin{DoxyParamCaption}\item[{Tree\+Type \&}]{query\+Node,  }\item[{Tree\+Type \&}]{reference\+Node,  }\item[{const double}]{old\+Score }\end{DoxyParamCaption})}



Re-\/evaluate the score for recursion order. 

A low score indicates priority for recursion, while D\+B\+L\+\_\+\+M\+AX indicates that the node should not be recursed into at all (it should be pruned). This is used when the score has already been calculated, but another recursion may have modified the bounds for pruning. So the old score is checked against the new pruning bound.

For the rank-\/approximation, we check if the reference\+Node can be approximated by sampling. If it can be, enough samples are made for every query in the query\+Node. No further query-\/tree traversal is performed.

The \textquotesingle{}Num\+Samples\+Made\textquotesingle{} query stat is propagated up the tree. And then if pruning occurs (by distance or by sampling), the \textquotesingle{}Num\+Samples\+Made\textquotesingle{} stat is not propagated down the tree. If no pruning occurs, the stat is propagated down the tree.


\begin{DoxyParams}{Parameters}
{\em query\+Node} & Candidate query node to recurse into. \\
\hline
{\em reference\+Node} & Candidate reference node to recurse into. \\
\hline
{\em old\+Score} & Old score produced by Socre() (or \doxyref{Rescore()}{p.}{classmlpack_1_1neighbor_1_1RASearchRules_a6f97dd07745e07a2d7ff3d4a42347e48}). \\
\hline
\end{DoxyParams}
\mbox{\label{classmlpack_1_1neighbor_1_1RASearchRules_a53d373b7aeee359b0e686f823c602b1c}} 
\index{mlpack\+::neighbor\+::\+R\+A\+Search\+Rules@{mlpack\+::neighbor\+::\+R\+A\+Search\+Rules}!Score@{Score}}
\index{Score@{Score}!mlpack\+::neighbor\+::\+R\+A\+Search\+Rules@{mlpack\+::neighbor\+::\+R\+A\+Search\+Rules}}
\subsubsection{Score()\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily double Score (\begin{DoxyParamCaption}\item[{const size\+\_\+t}]{query\+Index,  }\item[{Tree\+Type \&}]{reference\+Node }\end{DoxyParamCaption})}



Get the score for recursion order. 

A low score indicates priority for recursion, while D\+B\+L\+\_\+\+M\+AX indicates that the node should not be recursed into at all (it should be pruned).

For rank-\/approximation, the scoring function first checks if pruning by distance is possible. If yes, then the node is given the score of \textquotesingle{}D\+B\+L\+\_\+\+M\+AX\textquotesingle{} and the expected number of samples from that node are added to the number of samples made for the query.

If no, then the function tries to see if the node can be pruned by approximation. If number of samples required from this node is small enough, then that number of samples are acquired from this node and the score is set to be \textquotesingle{}D\+B\+L\+\_\+\+M\+AX\textquotesingle{}.

If the pruning by approximation is not possible either, the algorithm continues with the usual tree-\/traversal.


\begin{DoxyParams}{Parameters}
{\em query\+Index} & Index of query point. \\
\hline
{\em reference\+Node} & Candidate node to be recursed into. \\
\hline
\end{DoxyParams}


Referenced by R\+A\+Search\+Rules$<$ Sort\+Policy, Metric\+Type, Tree\+Type $>$\+::\+Minimum\+Base\+Cases().

\mbox{\label{classmlpack_1_1neighbor_1_1RASearchRules_a5ebec48c6a7d410c1792a778f0a99d1f}} 
\index{mlpack\+::neighbor\+::\+R\+A\+Search\+Rules@{mlpack\+::neighbor\+::\+R\+A\+Search\+Rules}!Score@{Score}}
\index{Score@{Score}!mlpack\+::neighbor\+::\+R\+A\+Search\+Rules@{mlpack\+::neighbor\+::\+R\+A\+Search\+Rules}}
\subsubsection{Score()\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily double Score (\begin{DoxyParamCaption}\item[{const size\+\_\+t}]{query\+Index,  }\item[{Tree\+Type \&}]{reference\+Node,  }\item[{const double}]{base\+Case\+Result }\end{DoxyParamCaption})}



Get the score for recursion order. 

A low score indicates priority for recursion, while D\+B\+L\+\_\+\+M\+AX indicates that the node should not be recursed into at all (it should be pruned).

For rank-\/approximation, the scoring function first checks if pruning by distance is possible. If yes, then the node is given the score of \textquotesingle{}D\+B\+L\+\_\+\+M\+AX\textquotesingle{} and the expected number of samples from that node are added to the number of samples made for the query.

If no, then the function tries to see if the node can be pruned by approximation. If number of samples required from this node is small enough, then that number of samples are acquired from this node and the score is set to be \textquotesingle{}D\+B\+L\+\_\+\+M\+AX\textquotesingle{}.

If the pruning by approximation is not possible either, the algorithm continues with the usual tree-\/traversal.


\begin{DoxyParams}{Parameters}
{\em query\+Index} & Index of query point. \\
\hline
{\em reference\+Node} & Candidate node to be recursed into. \\
\hline
{\em base\+Case\+Result} & Result of Base\+Case(query\+Index, reference\+Node). \\
\hline
\end{DoxyParams}
\mbox{\label{classmlpack_1_1neighbor_1_1RASearchRules_a05b142945ef94221b628a75961f48b02}} 
\index{mlpack\+::neighbor\+::\+R\+A\+Search\+Rules@{mlpack\+::neighbor\+::\+R\+A\+Search\+Rules}!Score@{Score}}
\index{Score@{Score}!mlpack\+::neighbor\+::\+R\+A\+Search\+Rules@{mlpack\+::neighbor\+::\+R\+A\+Search\+Rules}}
\subsubsection{Score()\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily double Score (\begin{DoxyParamCaption}\item[{Tree\+Type \&}]{query\+Node,  }\item[{Tree\+Type \&}]{reference\+Node }\end{DoxyParamCaption})}



Get the score for recursion order. 

A low score indicates priority for recursionm while D\+B\+L\+\_\+\+M\+AX indicates that the node should not be recursed into at all (it should be pruned).

For the rank-\/approximation, we check if the reference\+Node can be approximated by sampling. If it can be, enough samples are made for every query in the query\+Node. No further query-\/tree traversal is performed.

The \textquotesingle{}Num\+Samples\+Made\textquotesingle{} query stat is propagated up the tree. And then if pruning occurs (by distance or by sampling), the \textquotesingle{}Num\+Samples\+Made\textquotesingle{} stat is not propagated down the tree. If no pruning occurs, the stat is propagated down the tree.


\begin{DoxyParams}{Parameters}
{\em query\+Node} & Candidate query node to recurse into. \\
\hline
{\em reference\+Node} & Candidate reference node to recurse into. \\
\hline
\end{DoxyParams}
\mbox{\label{classmlpack_1_1neighbor_1_1RASearchRules_add6ee1729c77fa8df187140ec2086b58}} 
\index{mlpack\+::neighbor\+::\+R\+A\+Search\+Rules@{mlpack\+::neighbor\+::\+R\+A\+Search\+Rules}!Score@{Score}}
\index{Score@{Score}!mlpack\+::neighbor\+::\+R\+A\+Search\+Rules@{mlpack\+::neighbor\+::\+R\+A\+Search\+Rules}}
\subsubsection{Score()\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily double Score (\begin{DoxyParamCaption}\item[{Tree\+Type \&}]{query\+Node,  }\item[{Tree\+Type \&}]{reference\+Node,  }\item[{const double}]{base\+Case\+Result }\end{DoxyParamCaption})}



Get the score for recursion order, passing the base case result (in the situation where it may be needed to calculate the recursion order). 

A low score indicates priority for recursion, while D\+B\+L\+\_\+\+M\+AX indicates that the node should not be recursed into at all (it should be pruned).

For the rank-\/approximation, we check if the reference\+Node can be approximated by sampling. If it can be, enough samples are made for every query in the query\+Node. No further query-\/tree traversal is performed.

The \textquotesingle{}Num\+Samples\+Made\textquotesingle{} query stat is propagated up the tree. And then if pruning occurs (by distance or by sampling), the \textquotesingle{}Num\+Samples\+Made\textquotesingle{} stat is not propagated down the tree. If no pruning occurs, the stat is propagated down the tree.


\begin{DoxyParams}{Parameters}
{\em query\+Node} & Candidate query node to recurse into. \\
\hline
{\em reference\+Node} & Candidate reference node to recurse into. \\
\hline
{\em base\+Case\+Result} & Result of Base\+Case(query\+Index, reference\+Node). \\
\hline
\end{DoxyParams}
\mbox{\label{classmlpack_1_1neighbor_1_1RASearchRules_ab5c6f4ae7c3b71b808403a7b7454f26f}} 
\index{mlpack\+::neighbor\+::\+R\+A\+Search\+Rules@{mlpack\+::neighbor\+::\+R\+A\+Search\+Rules}!Traversal\+Info@{Traversal\+Info}}
\index{Traversal\+Info@{Traversal\+Info}!mlpack\+::neighbor\+::\+R\+A\+Search\+Rules@{mlpack\+::neighbor\+::\+R\+A\+Search\+Rules}}
\subsubsection{Traversal\+Info()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily const \textbf{ Traversal\+Info\+Type}\& Traversal\+Info (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line 241 of file ra\+\_\+search\+\_\+rules.\+hpp.

\mbox{\label{classmlpack_1_1neighbor_1_1RASearchRules_a4027bb90e756a4520d55978459c7f83e}} 
\index{mlpack\+::neighbor\+::\+R\+A\+Search\+Rules@{mlpack\+::neighbor\+::\+R\+A\+Search\+Rules}!Traversal\+Info@{Traversal\+Info}}
\index{Traversal\+Info@{Traversal\+Info}!mlpack\+::neighbor\+::\+R\+A\+Search\+Rules@{mlpack\+::neighbor\+::\+R\+A\+Search\+Rules}}
\subsubsection{Traversal\+Info()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \textbf{ Traversal\+Info\+Type}\& Traversal\+Info (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line 242 of file ra\+\_\+search\+\_\+rules.\+hpp.



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
/home/aakash/mlpack/src/mlpack/methods/rann/\textbf{ ra\+\_\+search\+\_\+rules.\+hpp}\end{DoxyCompactItemize}
