\section{D\+Tree$<$ Mat\+Type, Tag\+Type $>$ Class Template Reference}
\label{classmlpack_1_1det_1_1DTree}\index{D\+Tree$<$ Mat\+Type, Tag\+Type $>$@{D\+Tree$<$ Mat\+Type, Tag\+Type $>$}}


A density estimation tree is similar to both a decision tree and a space partitioning tree (like a kd-\/tree).  


\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
typedef Mat\+Type\+::elem\+\_\+type \textbf{ Elem\+Type}
\begin{DoxyCompactList}\small\item\em The actual, underlying type we\textquotesingle{}re working with. \end{DoxyCompactList}\item 
typedef arma\+::\+Col$<$ \textbf{ Elem\+Type} $>$ \textbf{ Stat\+Type}
\begin{DoxyCompactList}\small\item\em The statistic type we are holding. \end{DoxyCompactList}\item 
typedef Mat\+Type\+::vec\+\_\+type \textbf{ Vec\+Type}
\begin{DoxyCompactList}\small\item\em The type of vector we are using. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\textbf{ D\+Tree} ()
\begin{DoxyCompactList}\small\item\em Create an empty density estimation tree. \end{DoxyCompactList}\item 
\textbf{ D\+Tree} (const \textbf{ D\+Tree} \&obj)
\begin{DoxyCompactList}\small\item\em Create a tree that is the copy of the given tree. \end{DoxyCompactList}\item 
\textbf{ D\+Tree} (\textbf{ D\+Tree} \&\&obj)
\begin{DoxyCompactList}\small\item\em Create a tree by taking ownership of another tree (move constructor). \end{DoxyCompactList}\item 
\textbf{ D\+Tree} (const \textbf{ Stat\+Type} \&max\+Vals, const \textbf{ Stat\+Type} \&min\+Vals, const size\+\_\+t total\+Points)
\begin{DoxyCompactList}\small\item\em Create a density estimation tree with the given bounds and the given number of total points. \end{DoxyCompactList}\item 
\textbf{ D\+Tree} (Mat\+Type \&data)
\begin{DoxyCompactList}\small\item\em Create a density estimation tree on the given data. \end{DoxyCompactList}\item 
\textbf{ D\+Tree} (const \textbf{ Stat\+Type} \&max\+Vals, const \textbf{ Stat\+Type} \&min\+Vals, const size\+\_\+t start, const size\+\_\+t end, const double log\+Neg\+Error)
\begin{DoxyCompactList}\small\item\em Create a child node of a density estimation tree given the bounding box specified by max\+Vals and min\+Vals, using the size given in start and end and the specified error. \end{DoxyCompactList}\item 
\textbf{ D\+Tree} (const \textbf{ Stat\+Type} \&max\+Vals, const \textbf{ Stat\+Type} \&min\+Vals, const size\+\_\+t total\+Points, const size\+\_\+t start, const size\+\_\+t end)
\begin{DoxyCompactList}\small\item\em Create a child node of a density estimation tree given the bounding box specified by max\+Vals and min\+Vals, using the size given in start and end, and calculating the error with the total number of points given. \end{DoxyCompactList}\item 
\textbf{ $\sim$\+D\+Tree} ()
\begin{DoxyCompactList}\small\item\em Clean up memory allocated by the tree. \end{DoxyCompactList}\item 
double \textbf{ Alpha\+Upper} () const
\begin{DoxyCompactList}\small\item\em Return the upper part of the alpha sum. \end{DoxyCompactList}\item 
Tag\+Type \textbf{ Bucket\+Tag} () const
\begin{DoxyCompactList}\small\item\em Return the current bucket\textquotesingle{}s ID, if leaf, or -\/1 otherwise. \end{DoxyCompactList}\item 
\textbf{ D\+Tree} \& \textbf{ Child} (const size\+\_\+t child) const
\begin{DoxyCompactList}\small\item\em Return the specified child (0 will be left, 1 will be right). \end{DoxyCompactList}\item 
\textbf{ D\+Tree} $\ast$\& \textbf{ Child\+Ptr} (const size\+\_\+t child)
\item 
double \textbf{ Compute\+Value} (const \textbf{ Vec\+Type} \&query) const
\begin{DoxyCompactList}\small\item\em Compute the logarithm of the density estimate of a given query point. \end{DoxyCompactList}\item 
void \textbf{ Compute\+Variable\+Importance} (arma\+::vec \&importances) const
\begin{DoxyCompactList}\small\item\em Compute the variable importance of each dimension in the learned tree. \end{DoxyCompactList}\item 
size\+\_\+t \textbf{ End} () const
\begin{DoxyCompactList}\small\item\em Return the first index of a point not contained in this node. \end{DoxyCompactList}\item 
Tag\+Type \textbf{ Find\+Bucket} (const \textbf{ Vec\+Type} \&query) const
\begin{DoxyCompactList}\small\item\em Return the tag of the leaf containing the query. \end{DoxyCompactList}\item 
double \textbf{ Grow} (Mat\+Type \&data, arma\+::\+Col$<$ size\+\_\+t $>$ \&old\+From\+New, const bool use\+Vol\+Reg=false, const size\+\_\+t max\+Leaf\+Size=10, const size\+\_\+t min\+Leaf\+Size=5)
\begin{DoxyCompactList}\small\item\em Greedily expand the tree. \end{DoxyCompactList}\item 
\textbf{ D\+Tree} $\ast$ \textbf{ Left} () const
\begin{DoxyCompactList}\small\item\em Return the left child. \end{DoxyCompactList}\item 
double \textbf{ Log\+Negative\+Error} (const size\+\_\+t total\+Points) const
\begin{DoxyCompactList}\small\item\em Compute the log-\/negative-\/error for this point, given the total number of points in the dataset. \end{DoxyCompactList}\item 
double \textbf{ Log\+Neg\+Error} () const
\begin{DoxyCompactList}\small\item\em Return the log negative error of this node. \end{DoxyCompactList}\item 
double \textbf{ Log\+Volume} () const
\begin{DoxyCompactList}\small\item\em Return the inverse of the volume of this node. \end{DoxyCompactList}\item 
const \textbf{ Stat\+Type} \& \textbf{ Max\+Vals} () const
\begin{DoxyCompactList}\small\item\em Return the maximum values. \end{DoxyCompactList}\item 
const \textbf{ Stat\+Type} \& \textbf{ Min\+Vals} () const
\begin{DoxyCompactList}\small\item\em Return the minimum values. \end{DoxyCompactList}\item 
size\+\_\+t \textbf{ Num\+Children} () const
\begin{DoxyCompactList}\small\item\em Return the number of children in this node. \end{DoxyCompactList}\item 
\textbf{ D\+Tree} \& \textbf{ operator=} (const \textbf{ D\+Tree} \&obj)
\begin{DoxyCompactList}\small\item\em Copy the given tree. \end{DoxyCompactList}\item 
\textbf{ D\+Tree} \& \textbf{ operator=} (\textbf{ D\+Tree} \&\&obj)
\begin{DoxyCompactList}\small\item\em Take ownership of the given tree (move operator). \end{DoxyCompactList}\item 
double \textbf{ Prune\+And\+Update} (const double old\+Alpha, const size\+\_\+t points, const bool use\+Vol\+Reg=false)
\begin{DoxyCompactList}\small\item\em Perform alpha pruning on a tree. \end{DoxyCompactList}\item 
double \textbf{ Ratio} () const
\begin{DoxyCompactList}\small\item\em Return the ratio of points in this node to the points in the whole dataset. \end{DoxyCompactList}\item 
\textbf{ D\+Tree} $\ast$ \textbf{ Right} () const
\begin{DoxyCompactList}\small\item\em Return the right child. \end{DoxyCompactList}\item 
bool \textbf{ Root} () const
\begin{DoxyCompactList}\small\item\em Return whether or not this is the root of the tree. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Archive $>$ }\\void \textbf{ serialize} (Archive \&ar, const uint32\+\_\+t)
\begin{DoxyCompactList}\small\item\em Serialize the density estimation tree. \end{DoxyCompactList}\item 
size\+\_\+t \textbf{ Split\+Dim} () const
\begin{DoxyCompactList}\small\item\em Return the split dimension of this node. \end{DoxyCompactList}\item 
\textbf{ Elem\+Type} \textbf{ Split\+Value} () const
\begin{DoxyCompactList}\small\item\em Return the split value of this node. \end{DoxyCompactList}\item 
size\+\_\+t \textbf{ Start} () const
\begin{DoxyCompactList}\small\item\em Return the starting index of points contained in this node. \end{DoxyCompactList}\item 
size\+\_\+t \textbf{ Subtree\+Leaves} () const
\begin{DoxyCompactList}\small\item\em Return the number of leaves which are descendants of this node. \end{DoxyCompactList}\item 
double \textbf{ Subtree\+Leaves\+Log\+Neg\+Error} () const
\begin{DoxyCompactList}\small\item\em Return the log negative error of all descendants of this node. \end{DoxyCompactList}\item 
Tag\+Type \textbf{ Tag\+Tree} (const Tag\+Type \&tag=0, bool every\+Node=false)
\begin{DoxyCompactList}\small\item\em Index the buckets for possible usage later; this results in every leaf in the tree having a specific tag (accessible with \doxyref{Bucket\+Tag()}{p.}{classmlpack_1_1det_1_1DTree_a2376602e2b6dec1df59d2fc967452870}). \end{DoxyCompactList}\item 
bool \textbf{ Within\+Range} (const \textbf{ Vec\+Type} \&query) const
\begin{DoxyCompactList}\small\item\em Return whether a query point is within the range of this node. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
\subsubsection*{template$<$typename Mat\+Type = arma\+::mat, typename Tag\+Type = int$>$\newline
class mlpack\+::det\+::\+D\+Tree$<$ Mat\+Type, Tag\+Type $>$}

A density estimation tree is similar to both a decision tree and a space partitioning tree (like a kd-\/tree). 

Each leaf represents a constant-\/density hyper-\/rectangle. The tree is constructed in such a way as to minimize the integrated square error between the probability distribution of the tree and the observed probability distribution of the data. Because the tree is similar to a decision tree, the density estimation tree can provide very fast density estimates for a given point.

For more information, see the following paper\+:


\begin{DoxyCode}
@incollection\{ram2011,
  author = \{Ram, Parikshit and Gray, Alexander G.\},
  title = \{Density estimation trees\},
  booktitle = \{\{Proceedings of the 17th ACM SIGKDD International Conference
      on Knowledge Discovery and Data Mining\}\},
  series = \{KDD \textcolor{stringliteral}{'11\},}
\textcolor{stringliteral}{  year = \{2011\},}
\textcolor{stringliteral}{  pages = \{627--635\}}
\textcolor{stringliteral}{\}}
\end{DoxyCode}
 

Definition at line 46 of file dtree.\+hpp.



\subsection{Member Typedef Documentation}
\mbox{\label{classmlpack_1_1det_1_1DTree_a227d0c7e23e98fcd6c81ecab357a791f}} 
\index{mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}!Elem\+Type@{Elem\+Type}}
\index{Elem\+Type@{Elem\+Type}!mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}}
\subsubsection{Elem\+Type}
{\footnotesize\ttfamily typedef Mat\+Type\+::elem\+\_\+type \textbf{ Elem\+Type}}



The actual, underlying type we\textquotesingle{}re working with. 



Definition at line 50 of file dtree.\+hpp.

\mbox{\label{classmlpack_1_1det_1_1DTree_a5932a1a525043a5f2679749a681dc51f}} 
\index{mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}!Stat\+Type@{Stat\+Type}}
\index{Stat\+Type@{Stat\+Type}!mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}}
\subsubsection{Stat\+Type}
{\footnotesize\ttfamily typedef arma\+::\+Col$<$\textbf{ Elem\+Type}$>$ \textbf{ Stat\+Type}}



The statistic type we are holding. 



Definition at line 54 of file dtree.\+hpp.

\mbox{\label{classmlpack_1_1det_1_1DTree_a528fde5f43fe390e444521297a503089}} 
\index{mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}!Vec\+Type@{Vec\+Type}}
\index{Vec\+Type@{Vec\+Type}!mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}}
\subsubsection{Vec\+Type}
{\footnotesize\ttfamily typedef Mat\+Type\+::vec\+\_\+type \textbf{ Vec\+Type}}



The type of vector we are using. 



Definition at line 52 of file dtree.\+hpp.



\subsection{Constructor \& Destructor Documentation}
\mbox{\label{classmlpack_1_1det_1_1DTree_aeb922a13b4645b611d04538638632b6e}} 
\index{mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}!D\+Tree@{D\+Tree}}
\index{D\+Tree@{D\+Tree}!mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}}
\subsubsection{D\+Tree()\hspace{0.1cm}{\footnotesize\ttfamily [1/7]}}
{\footnotesize\ttfamily \textbf{ D\+Tree} (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Create an empty density estimation tree. 

\mbox{\label{classmlpack_1_1det_1_1DTree_a202734b3555cef7a0fc346ba8abb719d}} 
\index{mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}!D\+Tree@{D\+Tree}}
\index{D\+Tree@{D\+Tree}!mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}}
\subsubsection{D\+Tree()\hspace{0.1cm}{\footnotesize\ttfamily [2/7]}}
{\footnotesize\ttfamily \textbf{ D\+Tree} (\begin{DoxyParamCaption}\item[{const \textbf{ D\+Tree}$<$ Mat\+Type, Tag\+Type $>$ \&}]{obj }\end{DoxyParamCaption})}



Create a tree that is the copy of the given tree. 


\begin{DoxyParams}{Parameters}
{\em obj} & Tree to copy. \\
\hline
\end{DoxyParams}
\mbox{\label{classmlpack_1_1det_1_1DTree_a2fa51451baba8caec9c5d91fc798203c}} 
\index{mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}!D\+Tree@{D\+Tree}}
\index{D\+Tree@{D\+Tree}!mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}}
\subsubsection{D\+Tree()\hspace{0.1cm}{\footnotesize\ttfamily [3/7]}}
{\footnotesize\ttfamily \textbf{ D\+Tree} (\begin{DoxyParamCaption}\item[{\textbf{ D\+Tree}$<$ Mat\+Type, Tag\+Type $>$ \&\&}]{obj }\end{DoxyParamCaption})}



Create a tree by taking ownership of another tree (move constructor). 


\begin{DoxyParams}{Parameters}
{\em obj} & Tree to take ownership of. \\
\hline
\end{DoxyParams}
\mbox{\label{classmlpack_1_1det_1_1DTree_add20405870ac7af34582f789b988a3ab}} 
\index{mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}!D\+Tree@{D\+Tree}}
\index{D\+Tree@{D\+Tree}!mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}}
\subsubsection{D\+Tree()\hspace{0.1cm}{\footnotesize\ttfamily [4/7]}}
{\footnotesize\ttfamily \textbf{ D\+Tree} (\begin{DoxyParamCaption}\item[{const \textbf{ Stat\+Type} \&}]{max\+Vals,  }\item[{const \textbf{ Stat\+Type} \&}]{min\+Vals,  }\item[{const size\+\_\+t}]{total\+Points }\end{DoxyParamCaption})}



Create a density estimation tree with the given bounds and the given number of total points. 

Children will not be created.


\begin{DoxyParams}{Parameters}
{\em max\+Vals} & Maximum values of the bounding box. \\
\hline
{\em min\+Vals} & Minimum values of the bounding box. \\
\hline
{\em total\+Points} & Total number of points in the dataset. \\
\hline
\end{DoxyParams}
\mbox{\label{classmlpack_1_1det_1_1DTree_af84844af66ccc68af167e35e1beab91f}} 
\index{mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}!D\+Tree@{D\+Tree}}
\index{D\+Tree@{D\+Tree}!mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}}
\subsubsection{D\+Tree()\hspace{0.1cm}{\footnotesize\ttfamily [5/7]}}
{\footnotesize\ttfamily \textbf{ D\+Tree} (\begin{DoxyParamCaption}\item[{Mat\+Type \&}]{data }\end{DoxyParamCaption})}



Create a density estimation tree on the given data. 

Children will be created following the procedure outlined in the paper. The data will be modified; it will be reordered similar to the way Binary\+Space\+Tree modifies datasets.


\begin{DoxyParams}{Parameters}
{\em data} & Dataset to build tree on. \\
\hline
\end{DoxyParams}
\mbox{\label{classmlpack_1_1det_1_1DTree_a0c03d5fb1f36b32039df0bd07c9facc4}} 
\index{mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}!D\+Tree@{D\+Tree}}
\index{D\+Tree@{D\+Tree}!mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}}
\subsubsection{D\+Tree()\hspace{0.1cm}{\footnotesize\ttfamily [6/7]}}
{\footnotesize\ttfamily \textbf{ D\+Tree} (\begin{DoxyParamCaption}\item[{const \textbf{ Stat\+Type} \&}]{max\+Vals,  }\item[{const \textbf{ Stat\+Type} \&}]{min\+Vals,  }\item[{const size\+\_\+t}]{start,  }\item[{const size\+\_\+t}]{end,  }\item[{const double}]{log\+Neg\+Error }\end{DoxyParamCaption})}



Create a child node of a density estimation tree given the bounding box specified by max\+Vals and min\+Vals, using the size given in start and end and the specified error. 

Children of this node will not be created recursively.


\begin{DoxyParams}{Parameters}
{\em max\+Vals} & Upper bound of bounding box. \\
\hline
{\em min\+Vals} & Lower bound of bounding box. \\
\hline
{\em start} & Start of points represented by this node in the data matrix. \\
\hline
{\em end} & End of points represented by this node in the data matrix. \\
\hline
{\em log\+Neg\+Error} & log-\/negative error of this node. \\
\hline
\end{DoxyParams}
\mbox{\label{classmlpack_1_1det_1_1DTree_a4dbae2510438c52132ee54812beaaffc}} 
\index{mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}!D\+Tree@{D\+Tree}}
\index{D\+Tree@{D\+Tree}!mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}}
\subsubsection{D\+Tree()\hspace{0.1cm}{\footnotesize\ttfamily [7/7]}}
{\footnotesize\ttfamily \textbf{ D\+Tree} (\begin{DoxyParamCaption}\item[{const \textbf{ Stat\+Type} \&}]{max\+Vals,  }\item[{const \textbf{ Stat\+Type} \&}]{min\+Vals,  }\item[{const size\+\_\+t}]{total\+Points,  }\item[{const size\+\_\+t}]{start,  }\item[{const size\+\_\+t}]{end }\end{DoxyParamCaption})}



Create a child node of a density estimation tree given the bounding box specified by max\+Vals and min\+Vals, using the size given in start and end, and calculating the error with the total number of points given. 

Children of this node will not be created recursively.


\begin{DoxyParams}{Parameters}
{\em max\+Vals} & Upper bound of bounding box. \\
\hline
{\em min\+Vals} & Lower bound of bounding box. \\
\hline
{\em total\+Points} & Total number of points. \\
\hline
{\em start} & Start of points represented by this node in the data matrix. \\
\hline
{\em end} & End of points represented by this node in the data matrix. \\
\hline
\end{DoxyParams}
\mbox{\label{classmlpack_1_1det_1_1DTree_afdcf08945ef6a9e395acc1cea13582b1}} 
\index{mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}!````~D\+Tree@{$\sim$\+D\+Tree}}
\index{````~D\+Tree@{$\sim$\+D\+Tree}!mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}}
\subsubsection{$\sim$\+D\+Tree()}
{\footnotesize\ttfamily $\sim$\textbf{ D\+Tree} (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Clean up memory allocated by the tree. 



\subsection{Member Function Documentation}
\mbox{\label{classmlpack_1_1det_1_1DTree_ac68e0c97d89449fb5b376c5efea143af}} 
\index{mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}!Alpha\+Upper@{Alpha\+Upper}}
\index{Alpha\+Upper@{Alpha\+Upper}!mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}}
\subsubsection{Alpha\+Upper()}
{\footnotesize\ttfamily double Alpha\+Upper (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Return the upper part of the alpha sum. 



Definition at line 307 of file dtree.\+hpp.

\mbox{\label{classmlpack_1_1det_1_1DTree_a2376602e2b6dec1df59d2fc967452870}} 
\index{mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}!Bucket\+Tag@{Bucket\+Tag}}
\index{Bucket\+Tag@{Bucket\+Tag}!mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}}
\subsubsection{Bucket\+Tag()}
{\footnotesize\ttfamily Tag\+Type Bucket\+Tag (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Return the current bucket\textquotesingle{}s ID, if leaf, or -\/1 otherwise. 



Definition at line 309 of file dtree.\+hpp.

\mbox{\label{classmlpack_1_1det_1_1DTree_a638d657170d691d9f1558a18510cd1a3}} 
\index{mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}!Child@{Child}}
\index{Child@{Child}!mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}}
\subsubsection{Child()}
{\footnotesize\ttfamily \textbf{ D\+Tree}\& Child (\begin{DoxyParamCaption}\item[{const size\+\_\+t}]{child }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Return the specified child (0 will be left, 1 will be right). 

If the index is greater than 1, this will return the right child.


\begin{DoxyParams}{Parameters}
{\em child} & Index of child to return. \\
\hline
\end{DoxyParams}


Definition at line 319 of file dtree.\+hpp.

\mbox{\label{classmlpack_1_1det_1_1DTree_a16587a63237ee25fe1fd3ab68e9b3386}} 
\index{mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}!Child\+Ptr@{Child\+Ptr}}
\index{Child\+Ptr@{Child\+Ptr}!mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}}
\subsubsection{Child\+Ptr()}
{\footnotesize\ttfamily \textbf{ D\+Tree}$\ast$\& Child\+Ptr (\begin{DoxyParamCaption}\item[{const size\+\_\+t}]{child }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line 321 of file dtree.\+hpp.

\mbox{\label{classmlpack_1_1det_1_1DTree_a460008bb2c0ae3a0f30ed8dc5584064c}} 
\index{mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}!Compute\+Value@{Compute\+Value}}
\index{Compute\+Value@{Compute\+Value}!mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}}
\subsubsection{Compute\+Value()}
{\footnotesize\ttfamily double Compute\+Value (\begin{DoxyParamCaption}\item[{const \textbf{ Vec\+Type} \&}]{query }\end{DoxyParamCaption}) const}



Compute the logarithm of the density estimate of a given query point. 


\begin{DoxyParams}{Parameters}
{\em query} & Point to estimate density of. \\
\hline
\end{DoxyParams}
\mbox{\label{classmlpack_1_1det_1_1DTree_a1adcb64ec2d66b8299df1271a1ed1cac}} 
\index{mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}!Compute\+Variable\+Importance@{Compute\+Variable\+Importance}}
\index{Compute\+Variable\+Importance@{Compute\+Variable\+Importance}!mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}}
\subsubsection{Compute\+Variable\+Importance()}
{\footnotesize\ttfamily void Compute\+Variable\+Importance (\begin{DoxyParamCaption}\item[{arma\+::vec \&}]{importances }\end{DoxyParamCaption}) const}



Compute the variable importance of each dimension in the learned tree. 


\begin{DoxyParams}{Parameters}
{\em importances} & Vector to store the calculated importances in. \\
\hline
\end{DoxyParams}
\mbox{\label{classmlpack_1_1det_1_1DTree_a8d5a763647411c8a0f06e031c4611a0f}} 
\index{mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}!End@{End}}
\index{End@{End}!mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}}
\subsubsection{End()}
{\footnotesize\ttfamily size\+\_\+t End (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Return the first index of a point not contained in this node. 



Definition at line 284 of file dtree.\+hpp.

\mbox{\label{classmlpack_1_1det_1_1DTree_aca51d21d7b498e518a14668c1158df37}} 
\index{mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}!Find\+Bucket@{Find\+Bucket}}
\index{Find\+Bucket@{Find\+Bucket}!mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}}
\subsubsection{Find\+Bucket()}
{\footnotesize\ttfamily Tag\+Type Find\+Bucket (\begin{DoxyParamCaption}\item[{const \textbf{ Vec\+Type} \&}]{query }\end{DoxyParamCaption}) const}



Return the tag of the leaf containing the query. 

This is useful for generating class memberships.


\begin{DoxyParams}{Parameters}
{\em query} & Query to search for. \\
\hline
\end{DoxyParams}
\mbox{\label{classmlpack_1_1det_1_1DTree_a25cf9236f42d3a49303271e7809dd222}} 
\index{mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}!Grow@{Grow}}
\index{Grow@{Grow}!mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}}
\subsubsection{Grow()}
{\footnotesize\ttfamily double Grow (\begin{DoxyParamCaption}\item[{Mat\+Type \&}]{data,  }\item[{arma\+::\+Col$<$ size\+\_\+t $>$ \&}]{old\+From\+New,  }\item[{const bool}]{use\+Vol\+Reg = {\ttfamily false},  }\item[{const size\+\_\+t}]{max\+Leaf\+Size = {\ttfamily 10},  }\item[{const size\+\_\+t}]{min\+Leaf\+Size = {\ttfamily 5} }\end{DoxyParamCaption})}



Greedily expand the tree. 

The points in the dataset will be reordered during tree growth.


\begin{DoxyParams}{Parameters}
{\em data} & Dataset to build tree on. \\
\hline
{\em old\+From\+New} & Mappings from old points to new points. \\
\hline
{\em use\+Vol\+Reg} & If true, volume regularization is used. \\
\hline
{\em max\+Leaf\+Size} & Maximum size of a leaf. \\
\hline
{\em min\+Leaf\+Size} & Minimum size of a leaf. \\
\hline
\end{DoxyParams}
\mbox{\label{classmlpack_1_1det_1_1DTree_a79cce69b3ecde079bd57239a87c64c19}} 
\index{mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}!Left@{Left}}
\index{Left@{Left}!mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}}
\subsubsection{Left()}
{\footnotesize\ttfamily \textbf{ D\+Tree}$\ast$ Left (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Return the left child. 



Definition at line 301 of file dtree.\+hpp.

\mbox{\label{classmlpack_1_1det_1_1DTree_a0bc8836adf076875ac64f2e74cef34bb}} 
\index{mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}!Log\+Negative\+Error@{Log\+Negative\+Error}}
\index{Log\+Negative\+Error@{Log\+Negative\+Error}!mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}}
\subsubsection{Log\+Negative\+Error()}
{\footnotesize\ttfamily double Log\+Negative\+Error (\begin{DoxyParamCaption}\item[{const size\+\_\+t}]{total\+Points }\end{DoxyParamCaption}) const}



Compute the log-\/negative-\/error for this point, given the total number of points in the dataset. 


\begin{DoxyParams}{Parameters}
{\em total\+Points} & Total number of points in the dataset. \\
\hline
\end{DoxyParams}
\mbox{\label{classmlpack_1_1det_1_1DTree_a38a7244bcf0177609f89719fab505337}} 
\index{mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}!Log\+Neg\+Error@{Log\+Neg\+Error}}
\index{Log\+Neg\+Error@{Log\+Neg\+Error}!mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}}
\subsubsection{Log\+Neg\+Error()}
{\footnotesize\ttfamily double Log\+Neg\+Error (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Return the log negative error of this node. 



Definition at line 290 of file dtree.\+hpp.

\mbox{\label{classmlpack_1_1det_1_1DTree_a7b35659c3302722bb6ecb80dccba9cb6}} 
\index{mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}!Log\+Volume@{Log\+Volume}}
\index{Log\+Volume@{Log\+Volume}!mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}}
\subsubsection{Log\+Volume()}
{\footnotesize\ttfamily double Log\+Volume (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Return the inverse of the volume of this node. 



Definition at line 299 of file dtree.\+hpp.

\mbox{\label{classmlpack_1_1det_1_1DTree_a8b237dd32e6d7606276b495e55c323e4}} 
\index{mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}!Max\+Vals@{Max\+Vals}}
\index{Max\+Vals@{Max\+Vals}!mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}}
\subsubsection{Max\+Vals()}
{\footnotesize\ttfamily const \textbf{ Stat\+Type}\& Max\+Vals (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Return the maximum values. 



Definition at line 324 of file dtree.\+hpp.

\mbox{\label{classmlpack_1_1det_1_1DTree_a936a9325f501d7eae72eda0b13359e92}} 
\index{mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}!Min\+Vals@{Min\+Vals}}
\index{Min\+Vals@{Min\+Vals}!mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}}
\subsubsection{Min\+Vals()}
{\footnotesize\ttfamily const \textbf{ Stat\+Type}\& Min\+Vals (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Return the minimum values. 



Definition at line 327 of file dtree.\+hpp.



References D\+Tree$<$ Mat\+Type, Tag\+Type $>$\+::serialize().

\mbox{\label{classmlpack_1_1det_1_1DTree_a1f7ec083be66d58a3e02e12956bf005e}} 
\index{mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}!Num\+Children@{Num\+Children}}
\index{Num\+Children@{Num\+Children}!mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}}
\subsubsection{Num\+Children()}
{\footnotesize\ttfamily size\+\_\+t Num\+Children (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Return the number of children in this node. 



Definition at line 311 of file dtree.\+hpp.

\mbox{\label{classmlpack_1_1det_1_1DTree_a35c6e5aef1d33499c875e794245e834d}} 
\index{mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}!operator=@{operator=}}
\index{operator=@{operator=}!mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}}
\subsubsection{operator=()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \textbf{ D\+Tree}\& operator= (\begin{DoxyParamCaption}\item[{const \textbf{ D\+Tree}$<$ Mat\+Type, Tag\+Type $>$ \&}]{obj }\end{DoxyParamCaption})}



Copy the given tree. 


\begin{DoxyParams}{Parameters}
{\em obj} & Tree to copy. \\
\hline
\end{DoxyParams}
\mbox{\label{classmlpack_1_1det_1_1DTree_a44a35572d5d5bbdc6286d0b45e2e4220}} 
\index{mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}!operator=@{operator=}}
\index{operator=@{operator=}!mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}}
\subsubsection{operator=()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \textbf{ D\+Tree}\& operator= (\begin{DoxyParamCaption}\item[{\textbf{ D\+Tree}$<$ Mat\+Type, Tag\+Type $>$ \&\&}]{obj }\end{DoxyParamCaption})}



Take ownership of the given tree (move operator). 


\begin{DoxyParams}{Parameters}
{\em obj} & Tree to take ownership of. \\
\hline
\end{DoxyParams}
\mbox{\label{classmlpack_1_1det_1_1DTree_ac6a3d2b5cdf33af3808b659e45750203}} 
\index{mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}!Prune\+And\+Update@{Prune\+And\+Update}}
\index{Prune\+And\+Update@{Prune\+And\+Update}!mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}}
\subsubsection{Prune\+And\+Update()}
{\footnotesize\ttfamily double Prune\+And\+Update (\begin{DoxyParamCaption}\item[{const double}]{old\+Alpha,  }\item[{const size\+\_\+t}]{points,  }\item[{const bool}]{use\+Vol\+Reg = {\ttfamily false} }\end{DoxyParamCaption})}



Perform alpha pruning on a tree. 

Returns the new value of alpha.


\begin{DoxyParams}{Parameters}
{\em old\+Alpha} & Old value of alpha. \\
\hline
{\em points} & Total number of points in dataset. \\
\hline
{\em use\+Vol\+Reg} & If true, volume regularization is used. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
New value of alpha. 
\end{DoxyReturn}
\mbox{\label{classmlpack_1_1det_1_1DTree_a0052f2d1427761ea25fb01a05d966a40}} 
\index{mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}!Ratio@{Ratio}}
\index{Ratio@{Ratio}!mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}}
\subsubsection{Ratio()}
{\footnotesize\ttfamily double Ratio (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Return the ratio of points in this node to the points in the whole dataset. 



Definition at line 297 of file dtree.\+hpp.

\mbox{\label{classmlpack_1_1det_1_1DTree_a307f2b17aaa261c5ad13c9ede094da2a}} 
\index{mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}!Right@{Right}}
\index{Right@{Right}!mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}}
\subsubsection{Right()}
{\footnotesize\ttfamily \textbf{ D\+Tree}$\ast$ Right (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Return the right child. 



Definition at line 303 of file dtree.\+hpp.

\mbox{\label{classmlpack_1_1det_1_1DTree_ae294c1fd88f903e9d9869d8cface6b39}} 
\index{mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}!Root@{Root}}
\index{Root@{Root}!mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}}
\subsubsection{Root()}
{\footnotesize\ttfamily bool Root (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Return whether or not this is the root of the tree. 



Definition at line 305 of file dtree.\+hpp.

\mbox{\label{classmlpack_1_1det_1_1DTree_a65cba07328997659bec80b9879b15a51}} 
\index{mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}!serialize@{serialize}}
\index{serialize@{serialize}!mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}}
\subsubsection{serialize()}
{\footnotesize\ttfamily void serialize (\begin{DoxyParamCaption}\item[{Archive \&}]{ar,  }\item[{const uint32\+\_\+t}]{ }\end{DoxyParamCaption})}



Serialize the density estimation tree. 



Referenced by D\+Tree$<$ Mat\+Type, Tag\+Type $>$\+::\+Min\+Vals().

\mbox{\label{classmlpack_1_1det_1_1DTree_a46ee4cbf7c7a198da7b47edb54fb39ad}} 
\index{mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}!Split\+Dim@{Split\+Dim}}
\index{Split\+Dim@{Split\+Dim}!mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}}
\subsubsection{Split\+Dim()}
{\footnotesize\ttfamily size\+\_\+t Split\+Dim (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Return the split dimension of this node. 



Definition at line 286 of file dtree.\+hpp.

\mbox{\label{classmlpack_1_1det_1_1DTree_a36af2c64784fb9719046edd8fcba57c8}} 
\index{mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}!Split\+Value@{Split\+Value}}
\index{Split\+Value@{Split\+Value}!mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}}
\subsubsection{Split\+Value()}
{\footnotesize\ttfamily \textbf{ Elem\+Type} Split\+Value (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Return the split value of this node. 



Definition at line 288 of file dtree.\+hpp.

\mbox{\label{classmlpack_1_1det_1_1DTree_af08dc5cd1920c643d789d89f8386d24e}} 
\index{mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}!Start@{Start}}
\index{Start@{Start}!mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}}
\subsubsection{Start()}
{\footnotesize\ttfamily size\+\_\+t Start (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Return the starting index of points contained in this node. 



Definition at line 282 of file dtree.\+hpp.

\mbox{\label{classmlpack_1_1det_1_1DTree_a2328d45aa8b19c2aa22b4cf0f3ec9c02}} 
\index{mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}!Subtree\+Leaves@{Subtree\+Leaves}}
\index{Subtree\+Leaves@{Subtree\+Leaves}!mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}}
\subsubsection{Subtree\+Leaves()}
{\footnotesize\ttfamily size\+\_\+t Subtree\+Leaves (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Return the number of leaves which are descendants of this node. 



Definition at line 294 of file dtree.\+hpp.

\mbox{\label{classmlpack_1_1det_1_1DTree_ace34bbc6045e759256ddb44ceb7e457c}} 
\index{mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}!Subtree\+Leaves\+Log\+Neg\+Error@{Subtree\+Leaves\+Log\+Neg\+Error}}
\index{Subtree\+Leaves\+Log\+Neg\+Error@{Subtree\+Leaves\+Log\+Neg\+Error}!mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}}
\subsubsection{Subtree\+Leaves\+Log\+Neg\+Error()}
{\footnotesize\ttfamily double Subtree\+Leaves\+Log\+Neg\+Error (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Return the log negative error of all descendants of this node. 



Definition at line 292 of file dtree.\+hpp.

\mbox{\label{classmlpack_1_1det_1_1DTree_aefc8f6cc31c99760ada618ed3b3976f8}} 
\index{mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}!Tag\+Tree@{Tag\+Tree}}
\index{Tag\+Tree@{Tag\+Tree}!mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}}
\subsubsection{Tag\+Tree()}
{\footnotesize\ttfamily Tag\+Type Tag\+Tree (\begin{DoxyParamCaption}\item[{const Tag\+Type \&}]{tag = {\ttfamily 0},  }\item[{bool}]{every\+Node = {\ttfamily false} }\end{DoxyParamCaption})}



Index the buckets for possible usage later; this results in every leaf in the tree having a specific tag (accessible with \doxyref{Bucket\+Tag()}{p.}{classmlpack_1_1det_1_1DTree_a2376602e2b6dec1df59d2fc967452870}). 

This function calls itself recursively. The tag is incremented with {\ttfamily operator++()}, so any {\ttfamily Tag\+Type} overriding it will do.


\begin{DoxyParams}{Parameters}
{\em tag} & Tag for the next leaf; leave at 0 for the initial call. \\
\hline
{\em every\+Node} & Whether to increment on every node, not just leaves. \\
\hline
\end{DoxyParams}
\mbox{\label{classmlpack_1_1det_1_1DTree_a79f2c56cc6146455d078590734bee5f7}} 
\index{mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}!Within\+Range@{Within\+Range}}
\index{Within\+Range@{Within\+Range}!mlpack\+::det\+::\+D\+Tree@{mlpack\+::det\+::\+D\+Tree}}
\subsubsection{Within\+Range()}
{\footnotesize\ttfamily bool Within\+Range (\begin{DoxyParamCaption}\item[{const \textbf{ Vec\+Type} \&}]{query }\end{DoxyParamCaption}) const}



Return whether a query point is within the range of this node. 



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
/home/aakash/mlpack/src/mlpack/methods/det/\textbf{ dtree.\+hpp}\end{DoxyCompactItemize}
