\section{Example\+Kernel Class Reference}
\label{classmlpack_1_1kernel_1_1ExampleKernel}\index{Example\+Kernel@{Example\+Kernel}}


An example kernel function.  


\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\textbf{ Example\+Kernel} ()
\begin{DoxyCompactList}\small\item\em The default constructor, which takes no parameters. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Archive $>$ }\\void \textbf{ serialize} (Archive \&, const uint32\+\_\+t)
\begin{DoxyCompactList}\small\item\em Serializes the kernel. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename Vec\+TypeA , typename Vec\+TypeB $>$ }\\static double \textbf{ Convolution\+Integral} (const Vec\+TypeA \&, const Vec\+TypeB \&)
\begin{DoxyCompactList}\small\item\em Obtains the convolution integral [integral K($\vert$$\vert$x-\/a$\vert$$\vert$)K($\vert$$\vert$b-\/x$\vert$$\vert$)dx] for the two vectors. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Vec\+TypeA , typename Vec\+TypeB $>$ }\\static double \textbf{ Evaluate} (const Vec\+TypeA \&, const Vec\+TypeB \&)
\begin{DoxyCompactList}\small\item\em Evaluates the kernel function for two given vectors. \end{DoxyCompactList}\item 
static double \textbf{ Normalizer} ()
\begin{DoxyCompactList}\small\item\em Obtains the normalizing volume for the kernel with dimension \$dimension\$. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
An example kernel function. 

This is not a useful kernel, but it implements the two functions necessary to satisfy the Kernel policy (so that a class can be used whenever an mlpack method calls for a {\ttfamily typename Kernel} template parameter.

All that is necessary is a constructor and an {\ttfamily \doxyref{Evaluate()}{p.}{classmlpack_1_1kernel_1_1ExampleKernel_adb822097969089daac573baeb5c9b184}} function. More methods could be added; for instance, one useful idea is a constructor which takes parameters for a kernel (for instance, the width of the Gaussian for a Gaussian kernel). However, mlpack methods cannot count on these various constructors existing, which is why most methods allow passing an already-\/instantiated kernel object (and by default the method will construct the kernel with the default constructor). So, for instance,


\begin{DoxyCode}
GaussianKernel k(5.0);
KernelPCA<GaussianKernel> kpca(dataset, k);
\end{DoxyCode}


will set up kernel P\+CA using a Gaussian kernel with a width of 5.\+0, but


\begin{DoxyCode}
KernelPCA<GaussianKernel> kpca(dataset);
\end{DoxyCode}


will create the kernel with the default constructor. It is important (but not strictly mandatory) that your default constructor still gives a working kernel.

\begin{DoxyNote}{Note}
Not all kernels require state. For instance, the regular dot product needs no parameters. In that case, no local variables are necessary and {\ttfamily \doxyref{Evaluate()}{p.}{classmlpack_1_1kernel_1_1ExampleKernel_adb822097969089daac573baeb5c9b184}} can (and should) be declared static. However, for greater generalization, mlpack methods expect all kernels to require state and hence must store instantiated kernel functions; this is why a default constructor is necessary. 
\end{DoxyNote}


Definition at line 76 of file example\+\_\+kernel.\+hpp.



\subsection{Constructor \& Destructor Documentation}
\mbox{\label{classmlpack_1_1kernel_1_1ExampleKernel_ae749bed5678e12147a188ec9eab90ace}} 
\index{mlpack\+::kernel\+::\+Example\+Kernel@{mlpack\+::kernel\+::\+Example\+Kernel}!Example\+Kernel@{Example\+Kernel}}
\index{Example\+Kernel@{Example\+Kernel}!mlpack\+::kernel\+::\+Example\+Kernel@{mlpack\+::kernel\+::\+Example\+Kernel}}
\subsubsection{Example\+Kernel()}
{\footnotesize\ttfamily \textbf{ Example\+Kernel} (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



The default constructor, which takes no parameters. 

Because our simple example kernel has no internal parameters that need to be stored, the constructor does not need to do anything. For a more complex example, see the \doxyref{Gaussian\+Kernel}{p.}{classmlpack_1_1kernel_1_1GaussianKernel}, which stores an internal parameter. 

Definition at line 85 of file example\+\_\+kernel.\+hpp.



\subsection{Member Function Documentation}
\mbox{\label{classmlpack_1_1kernel_1_1ExampleKernel_a74f0cef3d02d0bba7327397f500d942c}} 
\index{mlpack\+::kernel\+::\+Example\+Kernel@{mlpack\+::kernel\+::\+Example\+Kernel}!Convolution\+Integral@{Convolution\+Integral}}
\index{Convolution\+Integral@{Convolution\+Integral}!mlpack\+::kernel\+::\+Example\+Kernel@{mlpack\+::kernel\+::\+Example\+Kernel}}
\subsubsection{Convolution\+Integral()}
{\footnotesize\ttfamily static double Convolution\+Integral (\begin{DoxyParamCaption}\item[{const Vec\+TypeA \&}]{,  }\item[{const Vec\+TypeB \&}]{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}



Obtains the convolution integral [integral K($\vert$$\vert$x-\/a$\vert$$\vert$)K($\vert$$\vert$b-\/x$\vert$$\vert$)dx] for the two vectors. 

In this case, because our simple example kernel has no internal parameters, we can declare the function static. For a more complex example which cannot be declared static, see the \doxyref{Gaussian\+Kernel}{p.}{classmlpack_1_1kernel_1_1GaussianKernel}, which stores an internal parameter.


\begin{DoxyTemplParams}{Template Parameters}
{\em Vec\+TypeA} & Type of first vector (arma\+::vec, arma\+::sp\+\_\+vec should be expected). \\
\hline
{\em Vec\+TypeB} & Type of second vector (arma\+::vec, arma\+::sp\+\_\+vec). \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em $\ast$} & (a) First vector. \\
\hline
{\em $\ast$} & (b) Second vector. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the convolution integral value. 
\end{DoxyReturn}


Definition at line 126 of file example\+\_\+kernel.\+hpp.

\mbox{\label{classmlpack_1_1kernel_1_1ExampleKernel_adb822097969089daac573baeb5c9b184}} 
\index{mlpack\+::kernel\+::\+Example\+Kernel@{mlpack\+::kernel\+::\+Example\+Kernel}!Evaluate@{Evaluate}}
\index{Evaluate@{Evaluate}!mlpack\+::kernel\+::\+Example\+Kernel@{mlpack\+::kernel\+::\+Example\+Kernel}}
\subsubsection{Evaluate()}
{\footnotesize\ttfamily static double Evaluate (\begin{DoxyParamCaption}\item[{const Vec\+TypeA \&}]{,  }\item[{const Vec\+TypeB \&}]{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}



Evaluates the kernel function for two given vectors. 

In this case, because our simple example kernel has no internal parameters, we can declare the function static. For a more complex example which cannot be declared static, see the \doxyref{Gaussian\+Kernel}{p.}{classmlpack_1_1kernel_1_1GaussianKernel}, which stores an internal parameter.


\begin{DoxyTemplParams}{Template Parameters}
{\em Vec\+TypeA} & Type of first vector (arma\+::vec, arma\+::sp\+\_\+vec should be expected). \\
\hline
{\em Vec\+TypeB} & Type of second vector (arma\+::vec, arma\+::sp\+\_\+vec). \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em $\ast$} & (a) First vector. \\
\hline
{\em $\ast$} & (b) Second vector. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
K(a, b). 
\end{DoxyReturn}


Definition at line 101 of file example\+\_\+kernel.\+hpp.

\mbox{\label{classmlpack_1_1kernel_1_1ExampleKernel_a451ae0fa79b59e479c6393647a6713d8}} 
\index{mlpack\+::kernel\+::\+Example\+Kernel@{mlpack\+::kernel\+::\+Example\+Kernel}!Normalizer@{Normalizer}}
\index{Normalizer@{Normalizer}!mlpack\+::kernel\+::\+Example\+Kernel@{mlpack\+::kernel\+::\+Example\+Kernel}}
\subsubsection{Normalizer()}
{\footnotesize\ttfamily static double Normalizer (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}



Obtains the normalizing volume for the kernel with dimension \$dimension\$. 

In this case, because our simple example kernel has no internal parameters, we can declare the function static. For a more complex example which cannot be declared static, see the \doxyref{Gaussian\+Kernel}{p.}{classmlpack_1_1kernel_1_1GaussianKernel}, which stores an internal parameter.

\begin{DoxyReturn}{Returns}
the normalization constant. 
\end{DoxyReturn}


Definition at line 138 of file example\+\_\+kernel.\+hpp.

\mbox{\label{classmlpack_1_1kernel_1_1ExampleKernel_aa2ccb5a0533a6ba0abe6dfc1f98fbafb}} 
\index{mlpack\+::kernel\+::\+Example\+Kernel@{mlpack\+::kernel\+::\+Example\+Kernel}!serialize@{serialize}}
\index{serialize@{serialize}!mlpack\+::kernel\+::\+Example\+Kernel@{mlpack\+::kernel\+::\+Example\+Kernel}}
\subsubsection{serialize()}
{\footnotesize\ttfamily void serialize (\begin{DoxyParamCaption}\item[{Archive \&}]{,  }\item[{const uint32\+\_\+t}]{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Serializes the kernel. 

In this case, the kernel has no members, so we do not need to do anything at all. 

Definition at line 109 of file example\+\_\+kernel.\+hpp.



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
/home/aakash/mlpack/src/mlpack/core/kernels/\textbf{ example\+\_\+kernel.\+hpp}\end{DoxyCompactItemize}
