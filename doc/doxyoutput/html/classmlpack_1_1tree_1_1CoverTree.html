<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>mlpack: CoverTree&lt; MetricType, StatisticType, MatType, RootPointPolicy &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra-stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">mlpack
   &#160;<span id="projectnumber">3.4.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlpack.html">mlpack</a></li><li class="navelem"><a class="el" href="namespacemlpack_1_1tree.html">tree</a></li><li class="navelem"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html">CoverTree</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classmlpack_1_1tree_1_1CoverTree-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">CoverTree&lt; MetricType, StatisticType, MatType, RootPointPolicy &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A cover tree is a tree specifically designed to speed up nearest-neighbor computation in high-dimensional spaces.  
 <a href="classmlpack_1_1tree_1_1CoverTree.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1CoverTree_1_1DualTreeTraverser.html">DualTreeTraverser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dual-tree cover tree traverser; see dual_tree_traverser.hpp.  <a href="classmlpack_1_1tree_1_1CoverTree_1_1DualTreeTraverser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1CoverTree_1_1SingleTreeTraverser.html">SingleTreeTraverser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A single-tree cover tree traverser; see single_tree_traverser.hpp for implementation.  <a href="classmlpack_1_1tree_1_1CoverTree_1_1SingleTreeTraverser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aac99a3dcf43d40656d7043cab1693311"><td class="memTemplParams" colspan="2">template&lt;typename RuleType &gt; </td></tr>
<tr class="memitem:aac99a3dcf43d40656d7043cab1693311"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#aac99a3dcf43d40656d7043cab1693311">BreadthFirstDualTreeTraverser</a> = <a class="el" href="classmlpack_1_1tree_1_1CoverTree_1_1DualTreeTraverser.html">DualTreeTraverser</a>&lt; RuleType &gt;</td></tr>
<tr class="separator:aac99a3dcf43d40656d7043cab1693311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227d0c7e23e98fcd6c81ecab357a791f"><td class="memItemLeft" align="right" valign="top">typedef MatType::elem_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a></td></tr>
<tr class="memdesc:a227d0c7e23e98fcd6c81ecab357a791f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type held by the matrix type.  <a href="#a227d0c7e23e98fcd6c81ecab357a791f">More...</a><br /></td></tr>
<tr class="separator:a227d0c7e23e98fcd6c81ecab357a791f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57758caa2e58c3fe05d1284eeabae523"><td class="memItemLeft" align="right" valign="top">typedef MatType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a57758caa2e58c3fe05d1284eeabae523">Mat</a></td></tr>
<tr class="memdesc:a57758caa2e58c3fe05d1284eeabae523"><td class="mdescLeft">&#160;</td><td class="mdescRight">So that other classes can access the matrix type.  <a href="#a57758caa2e58c3fe05d1284eeabae523">More...</a><br /></td></tr>
<tr class="separator:a57758caa2e58c3fe05d1284eeabae523"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3f43b81626f944c2ef781042e52c1750"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a3f43b81626f944c2ef781042e52c1750">CoverTree</a> (const MatType &amp;dataset, const <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a> base=2.0, MetricType *metric=NULL)</td></tr>
<tr class="memdesc:a3f43b81626f944c2ef781042e52c1750"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the cover tree with the given dataset and given base.  <a href="#a3f43b81626f944c2ef781042e52c1750">More...</a><br /></td></tr>
<tr class="separator:a3f43b81626f944c2ef781042e52c1750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11c6565c66e76da821210ecc040959ea"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a11c6565c66e76da821210ecc040959ea">CoverTree</a> (const MatType &amp;dataset, MetricType &amp;metric, const <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a> base=2.0)</td></tr>
<tr class="memdesc:a11c6565c66e76da821210ecc040959ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the cover tree with the given dataset and the given instantiated metric.  <a href="#a11c6565c66e76da821210ecc040959ea">More...</a><br /></td></tr>
<tr class="separator:a11c6565c66e76da821210ecc040959ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0073539371ad10a42720fa2d29f67aa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#ab0073539371ad10a42720fa2d29f67aa">CoverTree</a> (MatType &amp;&amp;dataset, const <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a> base=2.0)</td></tr>
<tr class="memdesc:ab0073539371ad10a42720fa2d29f67aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the cover tree with the given dataset, taking ownership of the dataset.  <a href="#ab0073539371ad10a42720fa2d29f67aa">More...</a><br /></td></tr>
<tr class="separator:ab0073539371ad10a42720fa2d29f67aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacb7278d9ace042e3484c12f0a82e4a3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#aacb7278d9ace042e3484c12f0a82e4a3">CoverTree</a> (MatType &amp;&amp;dataset, MetricType &amp;metric, const <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a> base=2.0)</td></tr>
<tr class="memdesc:aacb7278d9ace042e3484c12f0a82e4a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the cover tree with the given dataset and the given instantiated metric, taking ownership of the dataset.  <a href="#aacb7278d9ace042e3484c12f0a82e4a3">More...</a><br /></td></tr>
<tr class="separator:aacb7278d9ace042e3484c12f0a82e4a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2386b0029af0f79ba6b7990b72760bab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a2386b0029af0f79ba6b7990b72760bab">CoverTree</a> (const MatType &amp;dataset, const <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a> base, const size_t pointIndex, const int scale, <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html">CoverTree</a> *parent, const <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a> parentDistance, arma::Col&lt; size_t &gt; &amp;indices, arma::vec &amp;distances, size_t nearSetSize, size_t &amp;farSetSize, size_t &amp;usedSetSize, MetricType &amp;metric=NULL)</td></tr>
<tr class="memdesc:a2386b0029af0f79ba6b7990b72760bab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a child cover tree node.  <a href="#a2386b0029af0f79ba6b7990b72760bab">More...</a><br /></td></tr>
<tr class="separator:a2386b0029af0f79ba6b7990b72760bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d63518e019d8907dc87f51eccad0075"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a5d63518e019d8907dc87f51eccad0075">CoverTree</a> (const MatType &amp;dataset, const <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a> base, const size_t pointIndex, const int scale, <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html">CoverTree</a> *parent, const <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a> parentDistance, const <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a> furthestDescendantDistance, MetricType *metric=NULL)</td></tr>
<tr class="memdesc:a5d63518e019d8907dc87f51eccad0075"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manually construct a cover tree node; no tree assembly is done in this constructor, and children must be added manually (use <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a90f33ff64c79eae26cecb0da580edff5" title="Modify the children manually (maybe not a great idea). ">Children()</a>).  <a href="#a5d63518e019d8907dc87f51eccad0075">More...</a><br /></td></tr>
<tr class="separator:a5d63518e019d8907dc87f51eccad0075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3777403406c60ded153be4d63064a543"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a3777403406c60ded153be4d63064a543">CoverTree</a> (const <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html">CoverTree</a> &amp;other)</td></tr>
<tr class="memdesc:a3777403406c60ded153be4d63064a543"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a cover tree from another tree.  <a href="#a3777403406c60ded153be4d63064a543">More...</a><br /></td></tr>
<tr class="separator:a3777403406c60ded153be4d63064a543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd036d5c6e4ed6f889f1771bfc9b5b54"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#abd036d5c6e4ed6f889f1771bfc9b5b54">CoverTree</a> (<a class="el" href="classmlpack_1_1tree_1_1CoverTree.html">CoverTree</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:abd036d5c6e4ed6f889f1771bfc9b5b54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor for a Cover Tree, possess all the members of the given tree.  <a href="#abd036d5c6e4ed6f889f1771bfc9b5b54">More...</a><br /></td></tr>
<tr class="separator:abd036d5c6e4ed6f889f1771bfc9b5b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae18326cd02f05872a99e837e5f0081c5"><td class="memTemplParams" colspan="2">template&lt;typename Archive &gt; </td></tr>
<tr class="memitem:ae18326cd02f05872a99e837e5f0081c5"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#ae18326cd02f05872a99e837e5f0081c5">CoverTree</a> (Archive &amp;ar, const typename <a class="el" href="namespacestd.html#a93e9cb7fadbcfaa2afb5b94058b8e34c">std::enable_if_t</a>&lt; <a class="el" href="namespacecereal.html#ad79f9b690399d7e8aad9e7fc9ef3b797">cereal::is_loading</a>&lt; Archive &gt;()&gt; *=0)</td></tr>
<tr class="memdesc:ae18326cd02f05872a99e837e5f0081c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a cover tree from a cereal archive.  <a href="#ae18326cd02f05872a99e837e5f0081c5">More...</a><br /></td></tr>
<tr class="separator:ae18326cd02f05872a99e837e5f0081c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addb637c59f0e955dd9dd5bcd683fa686"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#addb637c59f0e955dd9dd5bcd683fa686">~CoverTree</a> ()</td></tr>
<tr class="memdesc:addb637c59f0e955dd9dd5bcd683fa686"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete this cover tree node and its children.  <a href="#addb637c59f0e955dd9dd5bcd683fa686">More...</a><br /></td></tr>
<tr class="separator:addb637c59f0e955dd9dd5bcd683fa686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51045cdd7ef57652ef25ff6deffe493a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a51045cdd7ef57652ef25ff6deffe493a">Base</a> () const</td></tr>
<tr class="memdesc:a51045cdd7ef57652ef25ff6deffe493a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the base.  <a href="#a51045cdd7ef57652ef25ff6deffe493a">More...</a><br /></td></tr>
<tr class="separator:a51045cdd7ef57652ef25ff6deffe493a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af32485882a0cdffe3f00333784c149eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#af32485882a0cdffe3f00333784c149eb">Base</a> ()</td></tr>
<tr class="memdesc:af32485882a0cdffe3f00333784c149eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the base; don't do this, you'll break everything.  <a href="#af32485882a0cdffe3f00333784c149eb">More...</a><br /></td></tr>
<tr class="separator:af32485882a0cdffe3f00333784c149eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa800439660375c0253008cafa648da78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#aa800439660375c0253008cafa648da78">Center</a> (arma::vec &amp;center) const</td></tr>
<tr class="memdesc:aa800439660375c0253008cafa648da78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the center of the node and store it in the given vector.  <a href="#aa800439660375c0253008cafa648da78">More...</a><br /></td></tr>
<tr class="separator:aa800439660375c0253008cafa648da78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb93f04eb20ed732ec48b6e07128186b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html">CoverTree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#adb93f04eb20ed732ec48b6e07128186b">Child</a> (const size_t index) const</td></tr>
<tr class="memdesc:adb93f04eb20ed732ec48b6e07128186b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a particular child node.  <a href="#adb93f04eb20ed732ec48b6e07128186b">More...</a><br /></td></tr>
<tr class="separator:adb93f04eb20ed732ec48b6e07128186b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa7a363aeb37212be36fc9f66506ccc7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html">CoverTree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#afa7a363aeb37212be36fc9f66506ccc7">Child</a> (const size_t index)</td></tr>
<tr class="memdesc:afa7a363aeb37212be36fc9f66506ccc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify a particular child node.  <a href="#afa7a363aeb37212be36fc9f66506ccc7">More...</a><br /></td></tr>
<tr class="separator:afa7a363aeb37212be36fc9f66506ccc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0284ae2b6f380c4f342c7b6a7b9a2e51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html">CoverTree</a> *&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a0284ae2b6f380c4f342c7b6a7b9a2e51">ChildPtr</a> (const size_t index)</td></tr>
<tr class="separator:a0284ae2b6f380c4f342c7b6a7b9a2e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac581755aea3bdeaa509dda3ae36d83ba"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html">CoverTree</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#ac581755aea3bdeaa509dda3ae36d83ba">Children</a> () const</td></tr>
<tr class="memdesc:ac581755aea3bdeaa509dda3ae36d83ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the children.  <a href="#ac581755aea3bdeaa509dda3ae36d83ba">More...</a><br /></td></tr>
<tr class="separator:ac581755aea3bdeaa509dda3ae36d83ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90f33ff64c79eae26cecb0da580edff5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html">CoverTree</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a90f33ff64c79eae26cecb0da580edff5">Children</a> ()</td></tr>
<tr class="memdesc:a90f33ff64c79eae26cecb0da580edff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the children manually (maybe not a great idea).  <a href="#a90f33ff64c79eae26cecb0da580edff5">More...</a><br /></td></tr>
<tr class="separator:a90f33ff64c79eae26cecb0da580edff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c3764c98d5804083a9ec2c867eb9366"><td class="memItemLeft" align="right" valign="top">const MatType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a4c3764c98d5804083a9ec2c867eb9366">Dataset</a> () const</td></tr>
<tr class="memdesc:a4c3764c98d5804083a9ec2c867eb9366"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to the dataset.  <a href="#a4c3764c98d5804083a9ec2c867eb9366">More...</a><br /></td></tr>
<tr class="separator:a4c3764c98d5804083a9ec2c867eb9366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa732ea3eeb38529c549fd4d15d8655be"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#aa732ea3eeb38529c549fd4d15d8655be">Descendant</a> (const size_t index) const</td></tr>
<tr class="memdesc:aa732ea3eeb38529c549fd4d15d8655be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of a particular descendant point.  <a href="#aa732ea3eeb38529c549fd4d15d8655be">More...</a><br /></td></tr>
<tr class="separator:aa732ea3eeb38529c549fd4d15d8655be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7be1f01295fcc373795004d746d322c7"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a7be1f01295fcc373795004d746d322c7">DistanceComps</a> () const</td></tr>
<tr class="separator:a7be1f01295fcc373795004d746d322c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35de97abd8fb6701fa9d14aeae13ca8b"><td class="memItemLeft" align="right" valign="top">size_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a35de97abd8fb6701fa9d14aeae13ca8b">DistanceComps</a> ()</td></tr>
<tr class="separator:a35de97abd8fb6701fa9d14aeae13ca8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc597088eadfcfa3060336d0484ab573"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#adc597088eadfcfa3060336d0484ab573">FurthestDescendantDistance</a> () const</td></tr>
<tr class="memdesc:adc597088eadfcfa3060336d0484ab573"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the distance from the center of the node to the furthest descendant.  <a href="#adc597088eadfcfa3060336d0484ab573">More...</a><br /></td></tr>
<tr class="separator:adc597088eadfcfa3060336d0484ab573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae17d614e8bd97bae2a3f8ade36bcffe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#aae17d614e8bd97bae2a3f8ade36bcffe">FurthestDescendantDistance</a> ()</td></tr>
<tr class="memdesc:aae17d614e8bd97bae2a3f8ade36bcffe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the distance from the center of the node to the furthest descendant.  <a href="#aae17d614e8bd97bae2a3f8ade36bcffe">More...</a><br /></td></tr>
<tr class="separator:aae17d614e8bd97bae2a3f8ade36bcffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbe82a6439f71405b5801ca7d941cbfb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#acbe82a6439f71405b5801ca7d941cbfb">FurthestPointDistance</a> () const</td></tr>
<tr class="memdesc:acbe82a6439f71405b5801ca7d941cbfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the distance to the furthest point. This is always 0 for cover trees.  <a href="#acbe82a6439f71405b5801ca7d941cbfb">More...</a><br /></td></tr>
<tr class="separator:acbe82a6439f71405b5801ca7d941cbfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0257281722537c7916db7763623f67f7"><td class="memTemplParams" colspan="2">template&lt;typename VecType &gt; </td></tr>
<tr class="memitem:a0257281722537c7916db7763623f67f7"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a0257281722537c7916db7763623f67f7">GetFurthestChild</a> (const VecType &amp;point, typename <a class="el" href="namespacestd.html#a93e9cb7fadbcfaa2afb5b94058b8e34c">std::enable_if_t</a>&lt; <a class="el" href="structIsVector.html">IsVector</a>&lt; VecType &gt;::value &gt; *=0)</td></tr>
<tr class="memdesc:a0257281722537c7916db7763623f67f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index of the furthest child node to the given query point.  <a href="#a0257281722537c7916db7763623f67f7">More...</a><br /></td></tr>
<tr class="separator:a0257281722537c7916db7763623f67f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac33b5915ee9d32fbeef8e3237cc5e4a5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#ac33b5915ee9d32fbeef8e3237cc5e4a5">GetFurthestChild</a> (const <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html">CoverTree</a> &amp;queryNode)</td></tr>
<tr class="memdesc:ac33b5915ee9d32fbeef8e3237cc5e4a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index of the furthest child node to the given query node.  <a href="#ac33b5915ee9d32fbeef8e3237cc5e4a5">More...</a><br /></td></tr>
<tr class="separator:ac33b5915ee9d32fbeef8e3237cc5e4a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19b9a5fd41d8e192b62effb1445bd410"><td class="memTemplParams" colspan="2">template&lt;typename VecType &gt; </td></tr>
<tr class="memitem:a19b9a5fd41d8e192b62effb1445bd410"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a19b9a5fd41d8e192b62effb1445bd410">GetNearestChild</a> (const VecType &amp;point, typename <a class="el" href="namespacestd.html#a93e9cb7fadbcfaa2afb5b94058b8e34c">std::enable_if_t</a>&lt; <a class="el" href="structIsVector.html">IsVector</a>&lt; VecType &gt;::value &gt; *=0)</td></tr>
<tr class="memdesc:a19b9a5fd41d8e192b62effb1445bd410"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index of the nearest child node to the given query point.  <a href="#a19b9a5fd41d8e192b62effb1445bd410">More...</a><br /></td></tr>
<tr class="separator:a19b9a5fd41d8e192b62effb1445bd410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ce3c7e531dcea920aa3fc88cb79f4a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#ab1ce3c7e531dcea920aa3fc88cb79f4a">GetNearestChild</a> (const <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html">CoverTree</a> &amp;queryNode)</td></tr>
<tr class="memdesc:ab1ce3c7e531dcea920aa3fc88cb79f4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index of the nearest child node to the given query node.  <a href="#ab1ce3c7e531dcea920aa3fc88cb79f4a">More...</a><br /></td></tr>
<tr class="separator:ab1ce3c7e531dcea920aa3fc88cb79f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0f4813924e6cdee43b45050bb947abe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#aa0f4813924e6cdee43b45050bb947abe">IsLeaf</a> () const</td></tr>
<tr class="separator:aa0f4813924e6cdee43b45050bb947abe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03a85c9b3e3967ac6ff9107fc9fe8c60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a03a85c9b3e3967ac6ff9107fc9fe8c60">MaxDistance</a> (const <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html">CoverTree</a> &amp;other) const</td></tr>
<tr class="memdesc:a03a85c9b3e3967ac6ff9107fc9fe8c60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum distance to another node.  <a href="#a03a85c9b3e3967ac6ff9107fc9fe8c60">More...</a><br /></td></tr>
<tr class="separator:a03a85c9b3e3967ac6ff9107fc9fe8c60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97a2a15f4c4e0e0de51d90117dca6cb7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a97a2a15f4c4e0e0de51d90117dca6cb7">MaxDistance</a> (const <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html">CoverTree</a> &amp;other, const <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a> distance) const</td></tr>
<tr class="memdesc:a97a2a15f4c4e0e0de51d90117dca6cb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum distance to another node given that the point-to-point distance has already been calculated.  <a href="#a97a2a15f4c4e0e0de51d90117dca6cb7">More...</a><br /></td></tr>
<tr class="separator:a97a2a15f4c4e0e0de51d90117dca6cb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88dfc32f4c701197670b839b02181f60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a88dfc32f4c701197670b839b02181f60">MaxDistance</a> (const arma::vec &amp;other) const</td></tr>
<tr class="memdesc:a88dfc32f4c701197670b839b02181f60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum distance to another point.  <a href="#a88dfc32f4c701197670b839b02181f60">More...</a><br /></td></tr>
<tr class="separator:a88dfc32f4c701197670b839b02181f60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a079e3ebb15f63b1d94661f9e87e39dd2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a079e3ebb15f63b1d94661f9e87e39dd2">MaxDistance</a> (const arma::vec &amp;other, const <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a> distance) const</td></tr>
<tr class="memdesc:a079e3ebb15f63b1d94661f9e87e39dd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum distance to another point given that the distance from the center to the point has already been calculated.  <a href="#a079e3ebb15f63b1d94661f9e87e39dd2">More...</a><br /></td></tr>
<tr class="separator:a079e3ebb15f63b1d94661f9e87e39dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab4999ec031306bc508cca8ea8f1889b"><td class="memItemLeft" align="right" valign="top">MetricType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#aab4999ec031306bc508cca8ea8f1889b">Metric</a> () const</td></tr>
<tr class="memdesc:aab4999ec031306bc508cca8ea8f1889b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the instantiated metric.  <a href="#aab4999ec031306bc508cca8ea8f1889b">More...</a><br /></td></tr>
<tr class="separator:aab4999ec031306bc508cca8ea8f1889b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d7c3fc69a509a305d08e1f3250002de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a9d7c3fc69a509a305d08e1f3250002de">MinDistance</a> (const <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html">CoverTree</a> &amp;other) const</td></tr>
<tr class="memdesc:a9d7c3fc69a509a305d08e1f3250002de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the minimum distance to another node.  <a href="#a9d7c3fc69a509a305d08e1f3250002de">More...</a><br /></td></tr>
<tr class="separator:a9d7c3fc69a509a305d08e1f3250002de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5696d6c26ff7adbafbf2400c61e9c5b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a5696d6c26ff7adbafbf2400c61e9c5b3">MinDistance</a> (const <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html">CoverTree</a> &amp;other, const <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a> distance) const</td></tr>
<tr class="memdesc:a5696d6c26ff7adbafbf2400c61e9c5b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the minimum distance to another node given that the point-to-point distance has already been calculated.  <a href="#a5696d6c26ff7adbafbf2400c61e9c5b3">More...</a><br /></td></tr>
<tr class="separator:a5696d6c26ff7adbafbf2400c61e9c5b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bc4caf2b12327ccf0572bb2d47a69b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a9bc4caf2b12327ccf0572bb2d47a69b4">MinDistance</a> (const arma::vec &amp;other) const</td></tr>
<tr class="memdesc:a9bc4caf2b12327ccf0572bb2d47a69b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the minimum distance to another point.  <a href="#a9bc4caf2b12327ccf0572bb2d47a69b4">More...</a><br /></td></tr>
<tr class="separator:a9bc4caf2b12327ccf0572bb2d47a69b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15f02ed8d02d6f56ad62673e3b192ed3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a15f02ed8d02d6f56ad62673e3b192ed3">MinDistance</a> (const arma::vec &amp;other, const <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a> distance) const</td></tr>
<tr class="memdesc:a15f02ed8d02d6f56ad62673e3b192ed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the minimum distance to another point given that the distance from the center to the point has already been calculated.  <a href="#a15f02ed8d02d6f56ad62673e3b192ed3">More...</a><br /></td></tr>
<tr class="separator:a15f02ed8d02d6f56ad62673e3b192ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20a4e92da6066eb335a576b7f9cd0415"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a20a4e92da6066eb335a576b7f9cd0415">MinimumBoundDistance</a> () const</td></tr>
<tr class="memdesc:a20a4e92da6066eb335a576b7f9cd0415"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the minimum distance from the center to any bound edge (this is the same as furthestDescendantDistance).  <a href="#a20a4e92da6066eb335a576b7f9cd0415">More...</a><br /></td></tr>
<tr class="separator:a20a4e92da6066eb335a576b7f9cd0415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f7ec083be66d58a3e02e12956bf005e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a1f7ec083be66d58a3e02e12956bf005e">NumChildren</a> () const</td></tr>
<tr class="memdesc:a1f7ec083be66d58a3e02e12956bf005e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of children.  <a href="#a1f7ec083be66d58a3e02e12956bf005e">More...</a><br /></td></tr>
<tr class="separator:a1f7ec083be66d58a3e02e12956bf005e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a85eb34222f1fc073940e8c89274e81"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a2a85eb34222f1fc073940e8c89274e81">NumDescendants</a> () const</td></tr>
<tr class="memdesc:a2a85eb34222f1fc073940e8c89274e81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of descendant points.  <a href="#a2a85eb34222f1fc073940e8c89274e81">More...</a><br /></td></tr>
<tr class="separator:a2a85eb34222f1fc073940e8c89274e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a352077c26368da0ee570c0b7f062b1e3"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a352077c26368da0ee570c0b7f062b1e3">NumPoints</a> () const</td></tr>
<tr class="separator:a352077c26368da0ee570c0b7f062b1e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbaf407e14b2b2cd50853a83e12380e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html">CoverTree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#acbaf407e14b2b2cd50853a83e12380e2">operator=</a> (const <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html">CoverTree</a> &amp;other)</td></tr>
<tr class="memdesc:acbaf407e14b2b2cd50853a83e12380e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the given Cover Tree.  <a href="#acbaf407e14b2b2cd50853a83e12380e2">More...</a><br /></td></tr>
<tr class="separator:acbaf407e14b2b2cd50853a83e12380e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee044966da9dba5e263fba874fb742e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html">CoverTree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#aee044966da9dba5e263fba874fb742e7">operator=</a> (<a class="el" href="classmlpack_1_1tree_1_1CoverTree.html">CoverTree</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:aee044966da9dba5e263fba874fb742e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take ownership of the given Cover Tree.  <a href="#aee044966da9dba5e263fba874fb742e7">More...</a><br /></td></tr>
<tr class="separator:aee044966da9dba5e263fba874fb742e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac68716eaa24588f11642fe35a0b0a6a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html">CoverTree</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#ac68716eaa24588f11642fe35a0b0a6a2">Parent</a> () const</td></tr>
<tr class="memdesc:ac68716eaa24588f11642fe35a0b0a6a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the parent node.  <a href="#ac68716eaa24588f11642fe35a0b0a6a2">More...</a><br /></td></tr>
<tr class="separator:ac68716eaa24588f11642fe35a0b0a6a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19755c56b49ec82deaa09e00c6771eb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html">CoverTree</a> *&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a19755c56b49ec82deaa09e00c6771eb6">Parent</a> ()</td></tr>
<tr class="memdesc:a19755c56b49ec82deaa09e00c6771eb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the parent node.  <a href="#a19755c56b49ec82deaa09e00c6771eb6">More...</a><br /></td></tr>
<tr class="separator:a19755c56b49ec82deaa09e00c6771eb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af44ed4e7bfea088689caed082da67e17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#af44ed4e7bfea088689caed082da67e17">ParentDistance</a> () const</td></tr>
<tr class="memdesc:af44ed4e7bfea088689caed082da67e17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the distance to the parent.  <a href="#af44ed4e7bfea088689caed082da67e17">More...</a><br /></td></tr>
<tr class="separator:af44ed4e7bfea088689caed082da67e17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa22ead21ac809efb970b90ec014dc318"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#aa22ead21ac809efb970b90ec014dc318">ParentDistance</a> ()</td></tr>
<tr class="memdesc:aa22ead21ac809efb970b90ec014dc318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the distance to the parent.  <a href="#aa22ead21ac809efb970b90ec014dc318">More...</a><br /></td></tr>
<tr class="separator:aa22ead21ac809efb970b90ec014dc318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a252939c8d0bc18169f72b8ea4741a1"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a4a252939c8d0bc18169f72b8ea4741a1">Point</a> () const</td></tr>
<tr class="memdesc:a4a252939c8d0bc18169f72b8ea4741a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of the point which this node represents.  <a href="#a4a252939c8d0bc18169f72b8ea4741a1">More...</a><br /></td></tr>
<tr class="separator:a4a252939c8d0bc18169f72b8ea4741a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2cd8fc8591e2d7c222f120bb35abd1a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#ae2cd8fc8591e2d7c222f120bb35abd1a">Point</a> (const size_t) const</td></tr>
<tr class="memdesc:ae2cd8fc8591e2d7c222f120bb35abd1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">For compatibility with other trees; the argument is ignored.  <a href="#ae2cd8fc8591e2d7c222f120bb35abd1a">More...</a><br /></td></tr>
<tr class="separator:ae2cd8fc8591e2d7c222f120bb35abd1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79946ce2f635d5731b5558ad4e8410cf"><td class="memItemLeft" align="right" valign="top">math::RangeType&lt; <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a79946ce2f635d5731b5558ad4e8410cf">RangeDistance</a> (const <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html">CoverTree</a> &amp;other) const</td></tr>
<tr class="memdesc:a79946ce2f635d5731b5558ad4e8410cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the minimum and maximum distance to another node.  <a href="#a79946ce2f635d5731b5558ad4e8410cf">More...</a><br /></td></tr>
<tr class="separator:a79946ce2f635d5731b5558ad4e8410cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4dabd8a1ef126a8fbeba28466db4a12"><td class="memItemLeft" align="right" valign="top">math::RangeType&lt; <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#ab4dabd8a1ef126a8fbeba28466db4a12">RangeDistance</a> (const <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html">CoverTree</a> &amp;other, const <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a> distance) const</td></tr>
<tr class="memdesc:ab4dabd8a1ef126a8fbeba28466db4a12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the minimum and maximum distance to another node given that the point-to-point distance has already been calculated.  <a href="#ab4dabd8a1ef126a8fbeba28466db4a12">More...</a><br /></td></tr>
<tr class="separator:ab4dabd8a1ef126a8fbeba28466db4a12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adad110287e2b644778a7c572a21144ed"><td class="memItemLeft" align="right" valign="top">math::RangeType&lt; <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#adad110287e2b644778a7c572a21144ed">RangeDistance</a> (const arma::vec &amp;other) const</td></tr>
<tr class="memdesc:adad110287e2b644778a7c572a21144ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the minimum and maximum distance to another point.  <a href="#adad110287e2b644778a7c572a21144ed">More...</a><br /></td></tr>
<tr class="separator:adad110287e2b644778a7c572a21144ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a326e0150de98039e6b9db9a89adc4275"><td class="memItemLeft" align="right" valign="top">math::RangeType&lt; <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a326e0150de98039e6b9db9a89adc4275">RangeDistance</a> (const arma::vec &amp;other, const <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a> distance) const</td></tr>
<tr class="memdesc:a326e0150de98039e6b9db9a89adc4275"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the minimum and maximum distance to another point given that the point-to-point distance has already been calculated.  <a href="#a326e0150de98039e6b9db9a89adc4275">More...</a><br /></td></tr>
<tr class="separator:a326e0150de98039e6b9db9a89adc4275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dd9a9752971834a6c42ec7e45b71c84"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a8dd9a9752971834a6c42ec7e45b71c84">Scale</a> () const</td></tr>
<tr class="memdesc:a8dd9a9752971834a6c42ec7e45b71c84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the scale of this node.  <a href="#a8dd9a9752971834a6c42ec7e45b71c84">More...</a><br /></td></tr>
<tr class="separator:a8dd9a9752971834a6c42ec7e45b71c84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bbfde922cf6700d130c5be70a5d7dd4"><td class="memItemLeft" align="right" valign="top">int &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a1bbfde922cf6700d130c5be70a5d7dd4">Scale</a> ()</td></tr>
<tr class="memdesc:a1bbfde922cf6700d130c5be70a5d7dd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the scale of this node. Be careful...  <a href="#a1bbfde922cf6700d130c5be70a5d7dd4">More...</a><br /></td></tr>
<tr class="separator:a1bbfde922cf6700d130c5be70a5d7dd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65cba07328997659bec80b9879b15a51"><td class="memTemplParams" colspan="2">template&lt;typename Archive &gt; </td></tr>
<tr class="memitem:a65cba07328997659bec80b9879b15a51"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a65cba07328997659bec80b9879b15a51">serialize</a> (Archive &amp;ar, const uint32_t)</td></tr>
<tr class="memdesc:a65cba07328997659bec80b9879b15a51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize the tree.  <a href="#a65cba07328997659bec80b9879b15a51">More...</a><br /></td></tr>
<tr class="separator:a65cba07328997659bec80b9879b15a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8b29c84ac793742cd15834f9f4c4f31"><td class="memItemLeft" align="right" valign="top">const StatisticType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#ad8b29c84ac793742cd15834f9f4c4f31">Stat</a> () const</td></tr>
<tr class="memdesc:ad8b29c84ac793742cd15834f9f4c4f31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the statistic for this node.  <a href="#ad8b29c84ac793742cd15834f9f4c4f31">More...</a><br /></td></tr>
<tr class="separator:ad8b29c84ac793742cd15834f9f4c4f31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac2d3c104b89109f3df4a9a8cad244da"><td class="memItemLeft" align="right" valign="top">StatisticType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#aac2d3c104b89109f3df4a9a8cad244da">Stat</a> ()</td></tr>
<tr class="memdesc:aac2d3c104b89109f3df4a9a8cad244da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the statistic for this node.  <a href="#aac2d3c104b89109f3df4a9a8cad244da">More...</a><br /></td></tr>
<tr class="separator:aac2d3c104b89109f3df4a9a8cad244da"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a6691991a6b8cd438a03368dc3c5f4b95"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a6691991a6b8cd438a03368dc3c5f4b95">CoverTree</a> ()</td></tr>
<tr class="memdesc:a6691991a6b8cd438a03368dc3c5f4b95"><td class="mdescLeft">&#160;</td><td class="mdescRight">A default constructor.  <a href="#a6691991a6b8cd438a03368dc3c5f4b95">More...</a><br /></td></tr>
<tr class="separator:a6691991a6b8cd438a03368dc3c5f4b95"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename MetricType = metric::LMetric&lt;2, true&gt;, typename StatisticType = EmptyStatistic, typename MatType = arma::mat, typename RootPointPolicy = FirstPointIsRoot&gt;<br />
class mlpack::tree::CoverTree&lt; MetricType, StatisticType, MatType, RootPointPolicy &gt;</h3>

<p>A cover tree is a tree specifically designed to speed up nearest-neighbor computation in high-dimensional spaces. </p>
<p>Each non-leaf node references a point and has a nonzero number of children, including a "self-child" which references the same point. A leaf node represents only one point.</p>
<p>The tree can be thought of as a hierarchy with the root node at the top level and the leaf nodes at the bottom level. Each level in the tree has an assigned 'scale' i. The tree follows these two invariants:</p>
<ul>
<li>nesting: the level C_i is a subset of the level C_{i - 1}.</li>
<li>covering: all node in level C_{i - 1} have at least one node in the level C_i with distance less than or equal to b^i (exactly one of these is a parent of the point in level C_{i - 1}.</li>
</ul>
<p>Note that in the cover tree paper, there is a third invariant (the 'separation invariant'), but that does not apply to our implementation, because we have relaxed the invariant.</p>
<p>The value 'b' refers to the base, which is a parameter of the tree. These three properties make the cover tree very good for fast, high-dimensional nearest-neighbor search.</p>
<p>The theoretical structure of the tree contains many 'implicit' nodes which only have a "self-child" (a child referencing the same point, but at a lower scale level). This practical implementation only constructs explicit nodes &ndash; non-leaf nodes with more than one child. A leaf node has no children, and its scale level is INT_MIN.</p>
<p>For more information on cover trees, see</p>
<div class="fragment"><div class="line">@inproceedings{</div><div class="line">  author = {Beygelzimer, Alina and Kakade, Sham and Langford, John},</div><div class="line">  title = {Cover trees <span class="keywordflow">for</span> nearest neighbor},</div><div class="line">  booktitle = {Proceedings of the 23rd International Conference on Machine</div><div class="line">    Learning},</div><div class="line">  series = {ICML <span class="stringliteral">&#39;06},</span></div><div class="line"><span class="stringliteral">  year = {2006},</span></div><div class="line"><span class="stringliteral">  pages = {97--104]</span></div><div class="line"><span class="stringliteral">}</span></div></div><!-- fragment --><p>For information on runtime bounds of the nearest-neighbor computation using cover trees, see the following paper, presented at NIPS 2009:</p>
<div class="fragment"><div class="line">@inproceedings{</div><div class="line">  author = {Ram, P., and Lee, D., and March, W.B., and Gray, A.G.},</div><div class="line">  title = {Linear-time Algorithms <span class="keywordflow">for</span> Pairwise Statistical Problems},</div><div class="line">  booktitle = {Advances in Neural Information Processing Systems 22},</div><div class="line">  editor = {Y. Bengio and D. Schuurmans and J. Lafferty and C.K.I. Williams</div><div class="line">    and A. Culotta},</div><div class="line">  pages = {1527--1535},</div><div class="line">  year = {2009}</div><div class="line">}</div></div><!-- fragment --><p>The <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html" title="A cover tree is a tree specifically designed to speed up nearest-neighbor computation in high-dimensi...">CoverTree</a> class offers three template parameters; a custom metric type can be used with MetricType (this class defaults to the L2-squared metric). The root node's point can be chosen with the RootPointPolicy; by default, the <a class="el" href="classmlpack_1_1tree_1_1FirstPointIsRoot.html" title="This class is meant to be used as a choice for the policy class RootPointPolicy of the CoverTree clas...">FirstPointIsRoot</a> policy is used, meaning the first point in the dataset is used. The StatisticType policy allows you to define statistics which can be gathered during the creation of the tree.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MetricType</td><td>Metric type to use during tree construction. </td></tr>
    <tr><td class="paramname">RootPointPolicy</td><td>Determines which point to use as the root node. </td></tr>
    <tr><td class="paramname">StatisticType</td><td>Statistic to be used during tree creation. </td></tr>
    <tr><td class="paramname">MatType</td><td>Type of matrix to build the tree on (generally mat or sp_mat). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="cover__tree_2cover__tree_8hpp_source.html#l00099">99</a> of file <a class="el" href="cover__tree_2cover__tree_8hpp_source.html">cover_tree.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aac99a3dcf43d40656d7043cab1693311"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac99a3dcf43d40656d7043cab1693311">&#9670;&nbsp;</a></span>BreadthFirstDualTreeTraverser</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#aac99a3dcf43d40656d7043cab1693311">BreadthFirstDualTreeTraverser</a> =  <a class="el" href="classmlpack_1_1tree_1_1CoverTree_1_1DualTreeTraverser.html">DualTreeTraverser</a>&lt;RuleType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cover__tree_2cover__tree_8hpp_source.html#l00280">280</a> of file <a class="el" href="cover__tree_2cover__tree_8hpp_source.html">cover_tree.hpp</a>.</p>

</div>
</div>
<a id="a227d0c7e23e98fcd6c81ecab357a791f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a227d0c7e23e98fcd6c81ecab357a791f">&#9670;&nbsp;</a></span>ElemType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef MatType::elem_type <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type held by the matrix type. </p>

<p class="definition">Definition at line <a class="el" href="cover__tree_2cover__tree_8hpp_source.html#l00105">105</a> of file <a class="el" href="cover__tree_2cover__tree_8hpp_source.html">cover_tree.hpp</a>.</p>

</div>
</div>
<a id="a57758caa2e58c3fe05d1284eeabae523"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57758caa2e58c3fe05d1284eeabae523">&#9670;&nbsp;</a></span>Mat</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef MatType <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a57758caa2e58c3fe05d1284eeabae523">Mat</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>So that other classes can access the matrix type. </p>

<p class="definition">Definition at line <a class="el" href="cover__tree_2cover__tree_8hpp_source.html#l00103">103</a> of file <a class="el" href="cover__tree_2cover__tree_8hpp_source.html">cover_tree.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3f43b81626f944c2ef781042e52c1750"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f43b81626f944c2ef781042e52c1750">&#9670;&nbsp;</a></span>CoverTree() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html">CoverTree</a> </td>
          <td>(</td>
          <td class="paramtype">const MatType &amp;&#160;</td>
          <td class="paramname"><em>dataset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a>&#160;</td>
          <td class="paramname"><em>base</em> = <code>2.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MetricType *&#160;</td>
          <td class="paramname"><em>metric</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the cover tree with the given dataset and given base. </p>
<p>The dataset will not be modified during the building procedure (unlike <a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html" title="A binary space partitioning tree, such as a KD-tree or a ball tree. ">BinarySpaceTree</a>).</p>
<p>The last argument will be removed in mlpack 1.1.0 (see #274 and #273).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataset</td><td>Reference to the dataset to build a tree on. </td></tr>
    <tr><td class="paramname">base</td><td>Base to use during tree building (default 2.0). </td></tr>
    <tr><td class="paramname">metric</td><td>Metric to use (default NULL). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11c6565c66e76da821210ecc040959ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11c6565c66e76da821210ecc040959ea">&#9670;&nbsp;</a></span>CoverTree() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html">CoverTree</a> </td>
          <td>(</td>
          <td class="paramtype">const MatType &amp;&#160;</td>
          <td class="paramname"><em>dataset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MetricType &amp;&#160;</td>
          <td class="paramname"><em>metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a>&#160;</td>
          <td class="paramname"><em>base</em> = <code>2.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the cover tree with the given dataset and the given instantiated metric. </p>
<p>Optionally, set the base. The dataset will not be modified during the building procedure (unlike <a class="el" href="classmlpack_1_1tree_1_1BinarySpaceTree.html" title="A binary space partitioning tree, such as a KD-tree or a ball tree. ">BinarySpaceTree</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataset</td><td>Reference to the dataset to build a tree on. </td></tr>
    <tr><td class="paramname">metric</td><td>Instantiated metric to use during tree building. </td></tr>
    <tr><td class="paramname">base</td><td>Base to use during tree building (default 2.0). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab0073539371ad10a42720fa2d29f67aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0073539371ad10a42720fa2d29f67aa">&#9670;&nbsp;</a></span>CoverTree() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html">CoverTree</a> </td>
          <td>(</td>
          <td class="paramtype">MatType &amp;&amp;&#160;</td>
          <td class="paramname"><em>dataset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a>&#160;</td>
          <td class="paramname"><em>base</em> = <code>2.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the cover tree with the given dataset, taking ownership of the dataset. </p>
<p>Optionally, set the base.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataset</td><td>Reference to the dataset to build a tree on. </td></tr>
    <tr><td class="paramname">base</td><td>Base to use during tree building (default 2.0). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aacb7278d9ace042e3484c12f0a82e4a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacb7278d9ace042e3484c12f0a82e4a3">&#9670;&nbsp;</a></span>CoverTree() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html">CoverTree</a> </td>
          <td>(</td>
          <td class="paramtype">MatType &amp;&amp;&#160;</td>
          <td class="paramname"><em>dataset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MetricType &amp;&#160;</td>
          <td class="paramname"><em>metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a>&#160;</td>
          <td class="paramname"><em>base</em> = <code>2.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the cover tree with the given dataset and the given instantiated metric, taking ownership of the dataset. </p>
<p>Optionally, set the base.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataset</td><td>Reference to the dataset to build a tree on. </td></tr>
    <tr><td class="paramname">metric</td><td>Instantiated metric to use during tree building. </td></tr>
    <tr><td class="paramname">base</td><td>Base to use during tree building (default 2.0). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2386b0029af0f79ba6b7990b72760bab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2386b0029af0f79ba6b7990b72760bab">&#9670;&nbsp;</a></span>CoverTree() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html">CoverTree</a> </td>
          <td>(</td>
          <td class="paramtype">const MatType &amp;&#160;</td>
          <td class="paramname"><em>dataset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a>&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>pointIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html">CoverTree</a>&lt; MetricType, StatisticType, MatType, RootPointPolicy &gt; *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a>&#160;</td>
          <td class="paramname"><em>parentDistance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::Col&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::vec &amp;&#160;</td>
          <td class="paramname"><em>distances</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nearSetSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>farSetSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>usedSetSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MetricType &amp;&#160;</td>
          <td class="paramname"><em>metric</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a child cover tree node. </p>
<p>This constructor is not meant to be used externally, but it could be used to insert another node into a tree. This procedure uses only one vector for the near set, the far set, and the used set (this is to prevent unnecessary memory allocation in recursive calls to this constructor). Therefore, the size of the near set, far set, and used set must be passed in. The near set will be entirely used up, and some of the far set may be used. The value of usedSetSize will be set to the number of points used in the construction of this node, and the value of farSetSize will be modified to reflect the number of points in the far set <em>after</em> the construction of this node.</p>
<p>If you are calling this manually, be careful that the given scale is as small as possible, or you may be creating an implicit node in your tree.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataset</td><td>Reference to the dataset to build a tree on. </td></tr>
    <tr><td class="paramname">base</td><td>Base to use during tree building. </td></tr>
    <tr><td class="paramname">pointIndex</td><td>Index of the point this node references. </td></tr>
    <tr><td class="paramname">scale</td><td>Scale of this level in the tree. </td></tr>
    <tr><td class="paramname">parent</td><td>Parent of this node (NULL indicates no parent). </td></tr>
    <tr><td class="paramname">parentDistance</td><td>Distance to the parent node. </td></tr>
    <tr><td class="paramname">indices</td><td>Array of indices, ordered [ nearSet | farSet | usedSet ]; will be modified to [ farSet | usedSet ]. </td></tr>
    <tr><td class="paramname">distances</td><td>Array of distances, ordered the same way as the indices. These represent the distances between the point specified by pointIndex and each point in the indices array. </td></tr>
    <tr><td class="paramname">nearSetSize</td><td>Size of the near set; if 0, this will be a leaf. </td></tr>
    <tr><td class="paramname">farSetSize</td><td>Size of the far set; may be modified (if this node uses any points in the far set). </td></tr>
    <tr><td class="paramname">usedSetSize</td><td>The number of points used will be added to this number. </td></tr>
    <tr><td class="paramname">metric</td><td>Metric to use (default NULL). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5d63518e019d8907dc87f51eccad0075"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d63518e019d8907dc87f51eccad0075">&#9670;&nbsp;</a></span>CoverTree() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html">CoverTree</a> </td>
          <td>(</td>
          <td class="paramtype">const MatType &amp;&#160;</td>
          <td class="paramname"><em>dataset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a>&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>pointIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html">CoverTree</a>&lt; MetricType, StatisticType, MatType, RootPointPolicy &gt; *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a>&#160;</td>
          <td class="paramname"><em>parentDistance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a>&#160;</td>
          <td class="paramname"><em>furthestDescendantDistance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MetricType *&#160;</td>
          <td class="paramname"><em>metric</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Manually construct a cover tree node; no tree assembly is done in this constructor, and children must be added manually (use <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a90f33ff64c79eae26cecb0da580edff5" title="Modify the children manually (maybe not a great idea). ">Children()</a>). </p>
<p>This constructor is useful when the tree is being "imported" into the <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html" title="A cover tree is a tree specifically designed to speed up nearest-neighbor computation in high-dimensi...">CoverTree</a> class after being created in some other manner.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataset</td><td>Reference to the dataset this node is a part of. </td></tr>
    <tr><td class="paramname">base</td><td>Base that was used for tree building. </td></tr>
    <tr><td class="paramname">pointIndex</td><td>Index of the point in the dataset which this node refers to. </td></tr>
    <tr><td class="paramname">scale</td><td>Scale of this node's level in the tree. </td></tr>
    <tr><td class="paramname">parent</td><td>Parent node (NULL indicates no parent). </td></tr>
    <tr><td class="paramname">parentDistance</td><td>Distance to parent node point. </td></tr>
    <tr><td class="paramname">furthestDescendantDistance</td><td>Distance to furthest descendant point. </td></tr>
    <tr><td class="paramname">metric</td><td>Instantiated metric (optional). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3777403406c60ded153be4d63064a543"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3777403406c60ded153be4d63064a543">&#9670;&nbsp;</a></span>CoverTree() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html">CoverTree</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html">CoverTree</a>&lt; MetricType, StatisticType, MatType, RootPointPolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a cover tree from another tree. </p>
<p>Be careful! This may use a lot of memory and take a lot of time. This will also make a copy of the dataset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Cover tree to copy from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abd036d5c6e4ed6f889f1771bfc9b5b54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd036d5c6e4ed6f889f1771bfc9b5b54">&#9670;&nbsp;</a></span>CoverTree() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html">CoverTree</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html">CoverTree</a>&lt; MetricType, StatisticType, MatType, RootPointPolicy &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move constructor for a Cover Tree, possess all the members of the given tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Cover Tree to move. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae18326cd02f05872a99e837e5f0081c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae18326cd02f05872a99e837e5f0081c5">&#9670;&nbsp;</a></span>CoverTree() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html">CoverTree</a> </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="namespacestd.html#a93e9cb7fadbcfaa2afb5b94058b8e34c">std::enable_if_t</a>&lt; <a class="el" href="namespacecereal.html#ad79f9b690399d7e8aad9e7fc9ef3b797">cereal::is_loading</a>&lt; Archive &gt;()&gt; *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a cover tree from a cereal archive. </p>

</div>
</div>
<a id="addb637c59f0e955dd9dd5bcd683fa686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addb637c59f0e955dd9dd5bcd683fa686">&#9670;&nbsp;</a></span>~CoverTree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classmlpack_1_1tree_1_1CoverTree.html">CoverTree</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete this cover tree node and its children. </p>

</div>
</div>
<a id="a6691991a6b8cd438a03368dc3c5f4b95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6691991a6b8cd438a03368dc3c5f4b95">&#9670;&nbsp;</a></span>CoverTree() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html">CoverTree</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A default constructor. </p>
<p>This is meant to only be used with cereal, which is allowed with the friend declaration below. This does not return a valid tree! This method must be protected, so that the serialization shim can work with the default constructor. </p>

<p class="reference">Referenced by <a class="el" href="cover__tree_2cover__tree_8hpp_source.html#l00434">CoverTree&lt; MetricType, StatisticType, MatType, RootPointPolicy &gt;::Metric()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a51045cdd7ef57652ef25ff6deffe493a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51045cdd7ef57652ef25ff6deffe493a">&#9670;&nbsp;</a></span>Base() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a> Base </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the base. </p>

<p class="definition">Definition at line <a class="el" href="cover__tree_2cover__tree_8hpp_source.html#l00320">320</a> of file <a class="el" href="cover__tree_2cover__tree_8hpp_source.html">cover_tree.hpp</a>.</p>

</div>
</div>
<a id="af32485882a0cdffe3f00333784c149eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af32485882a0cdffe3f00333784c149eb">&#9670;&nbsp;</a></span>Base() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a>&amp; Base </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify the base; don't do this, you'll break everything. </p>

<p class="definition">Definition at line <a class="el" href="cover__tree_2cover__tree_8hpp_source.html#l00322">322</a> of file <a class="el" href="cover__tree_2cover__tree_8hpp_source.html">cover_tree.hpp</a>.</p>

</div>
</div>
<a id="aa800439660375c0253008cafa648da78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa800439660375c0253008cafa648da78">&#9670;&nbsp;</a></span>Center()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Center </td>
          <td>(</td>
          <td class="paramtype">arma::vec &amp;&#160;</td>
          <td class="paramname"><em>center</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the center of the node and store it in the given vector. </p>

<p class="definition">Definition at line <a class="el" href="cover__tree_2cover__tree_8hpp_source.html#l00428">428</a> of file <a class="el" href="cover__tree_2cover__tree_8hpp_source.html">cover_tree.hpp</a>.</p>

</div>
</div>
<a id="adb93f04eb20ed732ec48b6e07128186b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb93f04eb20ed732ec48b6e07128186b">&#9670;&nbsp;</a></span>Child() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html">CoverTree</a>&amp; Child </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a particular child node. </p>

<p class="definition">Definition at line <a class="el" href="cover__tree_2cover__tree_8hpp_source.html#l00294">294</a> of file <a class="el" href="cover__tree_2cover__tree_8hpp_source.html">cover_tree.hpp</a>.</p>

</div>
</div>
<a id="afa7a363aeb37212be36fc9f66506ccc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa7a363aeb37212be36fc9f66506ccc7">&#9670;&nbsp;</a></span>Child() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html">CoverTree</a>&amp; Child </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify a particular child node. </p>

<p class="definition">Definition at line <a class="el" href="cover__tree_2cover__tree_8hpp_source.html#l00296">296</a> of file <a class="el" href="cover__tree_2cover__tree_8hpp_source.html">cover_tree.hpp</a>.</p>

</div>
</div>
<a id="a0284ae2b6f380c4f342c7b6a7b9a2e51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0284ae2b6f380c4f342c7b6a7b9a2e51">&#9670;&nbsp;</a></span>ChildPtr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html">CoverTree</a>*&amp; ChildPtr </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cover__tree_2cover__tree_8hpp_source.html#l00298">298</a> of file <a class="el" href="cover__tree_2cover__tree_8hpp_source.html">cover_tree.hpp</a>.</p>

</div>
</div>
<a id="ac581755aea3bdeaa509dda3ae36d83ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac581755aea3bdeaa509dda3ae36d83ba">&#9670;&nbsp;</a></span>Children() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classmlpack_1_1tree_1_1CoverTree.html">CoverTree</a>*&gt;&amp; Children </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the children. </p>

<p class="definition">Definition at line <a class="el" href="cover__tree_2cover__tree_8hpp_source.html#l00304">304</a> of file <a class="el" href="cover__tree_2cover__tree_8hpp_source.html">cover_tree.hpp</a>.</p>

</div>
</div>
<a id="a90f33ff64c79eae26cecb0da580edff5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90f33ff64c79eae26cecb0da580edff5">&#9670;&nbsp;</a></span>Children() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classmlpack_1_1tree_1_1CoverTree.html">CoverTree</a>*&gt;&amp; Children </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify the children manually (maybe not a great idea). </p>

<p class="definition">Definition at line <a class="el" href="cover__tree_2cover__tree_8hpp_source.html#l00306">306</a> of file <a class="el" href="cover__tree_2cover__tree_8hpp_source.html">cover_tree.hpp</a>.</p>

<p class="reference">References <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#aa732ea3eeb38529c549fd4d15d8655be">CoverTree&lt; MetricType, StatisticType, MatType, RootPointPolicy &gt;::Descendant()</a>, and <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a2a85eb34222f1fc073940e8c89274e81">CoverTree&lt; MetricType, StatisticType, MatType, RootPointPolicy &gt;::NumDescendants()</a>.</p>

</div>
</div>
<a id="a4c3764c98d5804083a9ec2c867eb9366"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c3764c98d5804083a9ec2c867eb9366">&#9670;&nbsp;</a></span>Dataset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const MatType&amp; Dataset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a reference to the dataset. </p>

<p class="definition">Definition at line <a class="el" href="cover__tree_2cover__tree_8hpp_source.html#l00283">283</a> of file <a class="el" href="cover__tree_2cover__tree_8hpp_source.html">cover_tree.hpp</a>.</p>

</div>
</div>
<a id="aa732ea3eeb38529c549fd4d15d8655be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa732ea3eeb38529c549fd4d15d8655be">&#9670;&nbsp;</a></span>Descendant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Descendant </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the index of a particular descendant point. </p>

<p class="reference">Referenced by <a class="el" href="cover__tree_2cover__tree_8hpp_source.html#l00306">CoverTree&lt; MetricType, StatisticType, MatType, RootPointPolicy &gt;::Children()</a>.</p>

</div>
</div>
<a id="a7be1f01295fcc373795004d746d322c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7be1f01295fcc373795004d746d322c7">&#9670;&nbsp;</a></span>DistanceComps() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t DistanceComps </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cover__tree_2cover__tree_8hpp_source.html#l00571">571</a> of file <a class="el" href="cover__tree_2cover__tree_8hpp_source.html">cover_tree.hpp</a>.</p>

</div>
</div>
<a id="a35de97abd8fb6701fa9d14aeae13ca8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35de97abd8fb6701fa9d14aeae13ca8b">&#9670;&nbsp;</a></span>DistanceComps() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t&amp; DistanceComps </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cover__tree_2cover__tree_8hpp_source.html#l00572">572</a> of file <a class="el" href="cover__tree_2cover__tree_8hpp_source.html">cover_tree.hpp</a>.</p>

</div>
</div>
<a id="adc597088eadfcfa3060336d0484ab573"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc597088eadfcfa3060336d0484ab573">&#9670;&nbsp;</a></span>FurthestDescendantDistance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a> FurthestDescendantDistance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the distance from the center of the node to the furthest descendant. </p>

<p class="definition">Definition at line <a class="el" href="cover__tree_2cover__tree_8hpp_source.html#l00417">417</a> of file <a class="el" href="cover__tree_2cover__tree_8hpp_source.html">cover_tree.hpp</a>.</p>

</div>
</div>
<a id="aae17d614e8bd97bae2a3f8ade36bcffe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae17d614e8bd97bae2a3f8ade36bcffe">&#9670;&nbsp;</a></span>FurthestDescendantDistance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a>&amp; FurthestDescendantDistance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify the distance from the center of the node to the furthest descendant. </p>

<p class="definition">Definition at line <a class="el" href="cover__tree_2cover__tree_8hpp_source.html#l00421">421</a> of file <a class="el" href="cover__tree_2cover__tree_8hpp_source.html">cover_tree.hpp</a>.</p>

</div>
</div>
<a id="acbe82a6439f71405b5801ca7d941cbfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbe82a6439f71405b5801ca7d941cbfb">&#9670;&nbsp;</a></span>FurthestPointDistance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a> FurthestPointDistance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the distance to the furthest point. This is always 0 for cover trees. </p>

<p class="definition">Definition at line <a class="el" href="cover__tree_2cover__tree_8hpp_source.html#l00414">414</a> of file <a class="el" href="cover__tree_2cover__tree_8hpp_source.html">cover_tree.hpp</a>.</p>

</div>
</div>
<a id="a0257281722537c7916db7763623f67f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0257281722537c7916db7763623f67f7">&#9670;&nbsp;</a></span>GetFurthestChild() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t GetFurthestChild </td>
          <td>(</td>
          <td class="paramtype">const VecType &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="namespacestd.html#a93e9cb7fadbcfaa2afb5b94058b8e34c">std::enable_if_t</a>&lt; <a class="el" href="structIsVector.html">IsVector</a>&lt; VecType &gt;::value &gt; *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the index of the furthest child node to the given query point. </p>
<p>If this is a leaf node, it will return <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a1f7ec083be66d58a3e02e12956bf005e" title="Get the number of children. ">NumChildren()</a> (invalid index). </p>

<p class="reference">Referenced by <a class="el" href="cover__tree_2cover__tree_8hpp_source.html#l00327">CoverTree&lt; MetricType, StatisticType, MatType, RootPointPolicy &gt;::Stat()</a>.</p>

</div>
</div>
<a id="ac33b5915ee9d32fbeef8e3237cc5e4a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac33b5915ee9d32fbeef8e3237cc5e4a5">&#9670;&nbsp;</a></span>GetFurthestChild() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t GetFurthestChild </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html">CoverTree</a>&lt; MetricType, StatisticType, MatType, RootPointPolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>queryNode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the index of the furthest child node to the given query node. </p>
<p>If it can't decide, it will return <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a1f7ec083be66d58a3e02e12956bf005e" title="Get the number of children. ">NumChildren()</a> (invalid index). </p>

</div>
</div>
<a id="a19b9a5fd41d8e192b62effb1445bd410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19b9a5fd41d8e192b62effb1445bd410">&#9670;&nbsp;</a></span>GetNearestChild() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t GetNearestChild </td>
          <td>(</td>
          <td class="paramtype">const VecType &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="namespacestd.html#a93e9cb7fadbcfaa2afb5b94058b8e34c">std::enable_if_t</a>&lt; <a class="el" href="structIsVector.html">IsVector</a>&lt; VecType &gt;::value &gt; *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the index of the nearest child node to the given query point. </p>
<p>If this is a leaf node, it will return <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a1f7ec083be66d58a3e02e12956bf005e" title="Get the number of children. ">NumChildren()</a> (invalid index). </p>

<p class="reference">Referenced by <a class="el" href="cover__tree_2cover__tree_8hpp_source.html#l00327">CoverTree&lt; MetricType, StatisticType, MatType, RootPointPolicy &gt;::Stat()</a>.</p>

</div>
</div>
<a id="ab1ce3c7e531dcea920aa3fc88cb79f4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1ce3c7e531dcea920aa3fc88cb79f4a">&#9670;&nbsp;</a></span>GetNearestChild() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t GetNearestChild </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html">CoverTree</a>&lt; MetricType, StatisticType, MatType, RootPointPolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>queryNode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the index of the nearest child node to the given query node. </p>
<p>If it can't decide, it will return <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a1f7ec083be66d58a3e02e12956bf005e" title="Get the number of children. ">NumChildren()</a> (invalid index). </p>

</div>
</div>
<a id="aa0f4813924e6cdee43b45050bb947abe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0f4813924e6cdee43b45050bb947abe">&#9670;&nbsp;</a></span>IsLeaf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IsLeaf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cover__tree_2cover__tree_8hpp_source.html#l00290">290</a> of file <a class="el" href="cover__tree_2cover__tree_8hpp_source.html">cover_tree.hpp</a>.</p>

</div>
</div>
<a id="a03a85c9b3e3967ac6ff9107fc9fe8c60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03a85c9b3e3967ac6ff9107fc9fe8c60">&#9670;&nbsp;</a></span>MaxDistance() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a> MaxDistance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html">CoverTree</a>&lt; MetricType, StatisticType, MatType, RootPointPolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the maximum distance to another node. </p>

<p class="reference">Referenced by <a class="el" href="cover__tree_2cover__tree_8hpp_source.html#l00327">CoverTree&lt; MetricType, StatisticType, MatType, RootPointPolicy &gt;::Stat()</a>.</p>

</div>
</div>
<a id="a97a2a15f4c4e0e0de51d90117dca6cb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97a2a15f4c4e0e0de51d90117dca6cb7">&#9670;&nbsp;</a></span>MaxDistance() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a> MaxDistance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html">CoverTree</a>&lt; MetricType, StatisticType, MatType, RootPointPolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a>&#160;</td>
          <td class="paramname"><em>distance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the maximum distance to another node given that the point-to-point distance has already been calculated. </p>

</div>
</div>
<a id="a88dfc32f4c701197670b839b02181f60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88dfc32f4c701197670b839b02181f60">&#9670;&nbsp;</a></span>MaxDistance() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a> MaxDistance </td>
          <td>(</td>
          <td class="paramtype">const arma::vec &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the maximum distance to another point. </p>

</div>
</div>
<a id="a079e3ebb15f63b1d94661f9e87e39dd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a079e3ebb15f63b1d94661f9e87e39dd2">&#9670;&nbsp;</a></span>MaxDistance() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a> MaxDistance </td>
          <td>(</td>
          <td class="paramtype">const arma::vec &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a>&#160;</td>
          <td class="paramname"><em>distance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the maximum distance to another point given that the distance from the center to the point has already been calculated. </p>

</div>
</div>
<a id="aab4999ec031306bc508cca8ea8f1889b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab4999ec031306bc508cca8ea8f1889b">&#9670;&nbsp;</a></span>Metric()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MetricType&amp; Metric </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the instantiated metric. </p>

<p class="definition">Definition at line <a class="el" href="cover__tree_2cover__tree_8hpp_source.html#l00434">434</a> of file <a class="el" href="cover__tree_2cover__tree_8hpp_source.html">cover_tree.hpp</a>.</p>

<p class="reference">References <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a6691991a6b8cd438a03368dc3c5f4b95">CoverTree&lt; MetricType, StatisticType, MatType, RootPointPolicy &gt;::CoverTree()</a>.</p>

</div>
</div>
<a id="a9d7c3fc69a509a305d08e1f3250002de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d7c3fc69a509a305d08e1f3250002de">&#9670;&nbsp;</a></span>MinDistance() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a> MinDistance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html">CoverTree</a>&lt; MetricType, StatisticType, MatType, RootPointPolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the minimum distance to another node. </p>

<p class="reference">Referenced by <a class="el" href="cover__tree_2cover__tree_8hpp_source.html#l00327">CoverTree&lt; MetricType, StatisticType, MatType, RootPointPolicy &gt;::Stat()</a>.</p>

</div>
</div>
<a id="a5696d6c26ff7adbafbf2400c61e9c5b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5696d6c26ff7adbafbf2400c61e9c5b3">&#9670;&nbsp;</a></span>MinDistance() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a> MinDistance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html">CoverTree</a>&lt; MetricType, StatisticType, MatType, RootPointPolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a>&#160;</td>
          <td class="paramname"><em>distance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the minimum distance to another node given that the point-to-point distance has already been calculated. </p>

</div>
</div>
<a id="a9bc4caf2b12327ccf0572bb2d47a69b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bc4caf2b12327ccf0572bb2d47a69b4">&#9670;&nbsp;</a></span>MinDistance() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a> MinDistance </td>
          <td>(</td>
          <td class="paramtype">const arma::vec &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the minimum distance to another point. </p>

</div>
</div>
<a id="a15f02ed8d02d6f56ad62673e3b192ed3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15f02ed8d02d6f56ad62673e3b192ed3">&#9670;&nbsp;</a></span>MinDistance() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a> MinDistance </td>
          <td>(</td>
          <td class="paramtype">const arma::vec &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a>&#160;</td>
          <td class="paramname"><em>distance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the minimum distance to another point given that the distance from the center to the point has already been calculated. </p>

</div>
</div>
<a id="a20a4e92da6066eb335a576b7f9cd0415"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20a4e92da6066eb335a576b7f9cd0415">&#9670;&nbsp;</a></span>MinimumBoundDistance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a> MinimumBoundDistance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the minimum distance from the center to any bound edge (this is the same as furthestDescendantDistance). </p>

<p class="definition">Definition at line <a class="el" href="cover__tree_2cover__tree_8hpp_source.html#l00425">425</a> of file <a class="el" href="cover__tree_2cover__tree_8hpp_source.html">cover_tree.hpp</a>.</p>

</div>
</div>
<a id="a1f7ec083be66d58a3e02e12956bf005e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f7ec083be66d58a3e02e12956bf005e">&#9670;&nbsp;</a></span>NumChildren()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t NumChildren </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of children. </p>

<p class="definition">Definition at line <a class="el" href="cover__tree_2cover__tree_8hpp_source.html#l00301">301</a> of file <a class="el" href="cover__tree_2cover__tree_8hpp_source.html">cover_tree.hpp</a>.</p>

</div>
</div>
<a id="a2a85eb34222f1fc073940e8c89274e81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a85eb34222f1fc073940e8c89274e81">&#9670;&nbsp;</a></span>NumDescendants()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t NumDescendants </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of descendant points. </p>

<p class="reference">Referenced by <a class="el" href="cover__tree_2cover__tree_8hpp_source.html#l00306">CoverTree&lt; MetricType, StatisticType, MatType, RootPointPolicy &gt;::Children()</a>.</p>

</div>
</div>
<a id="a352077c26368da0ee570c0b7f062b1e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a352077c26368da0ee570c0b7f062b1e3">&#9670;&nbsp;</a></span>NumPoints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t NumPoints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cover__tree_2cover__tree_8hpp_source.html#l00291">291</a> of file <a class="el" href="cover__tree_2cover__tree_8hpp_source.html">cover_tree.hpp</a>.</p>

</div>
</div>
<a id="acbaf407e14b2b2cd50853a83e12380e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbaf407e14b2b2cd50853a83e12380e2">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html">CoverTree</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html">CoverTree</a>&lt; MetricType, StatisticType, MatType, RootPointPolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the given Cover Tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The tree to be copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aee044966da9dba5e263fba874fb742e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee044966da9dba5e263fba874fb742e7">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html">CoverTree</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html">CoverTree</a>&lt; MetricType, StatisticType, MatType, RootPointPolicy &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take ownership of the given Cover Tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The tree to take ownership of. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac68716eaa24588f11642fe35a0b0a6a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac68716eaa24588f11642fe35a0b0a6a2">&#9670;&nbsp;</a></span>Parent() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html">CoverTree</a>* Parent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the parent node. </p>

<p class="definition">Definition at line <a class="el" href="cover__tree_2cover__tree_8hpp_source.html#l00404">404</a> of file <a class="el" href="cover__tree_2cover__tree_8hpp_source.html">cover_tree.hpp</a>.</p>

</div>
</div>
<a id="a19755c56b49ec82deaa09e00c6771eb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19755c56b49ec82deaa09e00c6771eb6">&#9670;&nbsp;</a></span>Parent() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html">CoverTree</a>*&amp; Parent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify the parent node. </p>

<p class="definition">Definition at line <a class="el" href="cover__tree_2cover__tree_8hpp_source.html#l00406">406</a> of file <a class="el" href="cover__tree_2cover__tree_8hpp_source.html">cover_tree.hpp</a>.</p>

</div>
</div>
<a id="af44ed4e7bfea088689caed082da67e17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af44ed4e7bfea088689caed082da67e17">&#9670;&nbsp;</a></span>ParentDistance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a> ParentDistance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the distance to the parent. </p>

<p class="definition">Definition at line <a class="el" href="cover__tree_2cover__tree_8hpp_source.html#l00409">409</a> of file <a class="el" href="cover__tree_2cover__tree_8hpp_source.html">cover_tree.hpp</a>.</p>

</div>
</div>
<a id="aa22ead21ac809efb970b90ec014dc318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa22ead21ac809efb970b90ec014dc318">&#9670;&nbsp;</a></span>ParentDistance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a>&amp; ParentDistance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify the distance to the parent. </p>

<p class="definition">Definition at line <a class="el" href="cover__tree_2cover__tree_8hpp_source.html#l00411">411</a> of file <a class="el" href="cover__tree_2cover__tree_8hpp_source.html">cover_tree.hpp</a>.</p>

</div>
</div>
<a id="a4a252939c8d0bc18169f72b8ea4741a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a252939c8d0bc18169f72b8ea4741a1">&#9670;&nbsp;</a></span>Point() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Point </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the index of the point which this node represents. </p>

<p class="definition">Definition at line <a class="el" href="cover__tree_2cover__tree_8hpp_source.html#l00286">286</a> of file <a class="el" href="cover__tree_2cover__tree_8hpp_source.html">cover_tree.hpp</a>.</p>

</div>
</div>
<a id="ae2cd8fc8591e2d7c222f120bb35abd1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2cd8fc8591e2d7c222f120bb35abd1a">&#9670;&nbsp;</a></span>Point() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Point </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For compatibility with other trees; the argument is ignored. </p>

<p class="definition">Definition at line <a class="el" href="cover__tree_2cover__tree_8hpp_source.html#l00288">288</a> of file <a class="el" href="cover__tree_2cover__tree_8hpp_source.html">cover_tree.hpp</a>.</p>

</div>
</div>
<a id="a79946ce2f635d5731b5558ad4e8410cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79946ce2f635d5731b5558ad4e8410cf">&#9670;&nbsp;</a></span>RangeDistance() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">math::RangeType&lt;<a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a>&gt; RangeDistance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html">CoverTree</a>&lt; MetricType, StatisticType, MatType, RootPointPolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the minimum and maximum distance to another node. </p>

<p class="reference">Referenced by <a class="el" href="cover__tree_2cover__tree_8hpp_source.html#l00327">CoverTree&lt; MetricType, StatisticType, MatType, RootPointPolicy &gt;::Stat()</a>.</p>

</div>
</div>
<a id="ab4dabd8a1ef126a8fbeba28466db4a12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4dabd8a1ef126a8fbeba28466db4a12">&#9670;&nbsp;</a></span>RangeDistance() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">math::RangeType&lt;<a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a>&gt; RangeDistance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html">CoverTree</a>&lt; MetricType, StatisticType, MatType, RootPointPolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a>&#160;</td>
          <td class="paramname"><em>distance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the minimum and maximum distance to another node given that the point-to-point distance has already been calculated. </p>

</div>
</div>
<a id="adad110287e2b644778a7c572a21144ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adad110287e2b644778a7c572a21144ed">&#9670;&nbsp;</a></span>RangeDistance() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">math::RangeType&lt;<a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a>&gt; RangeDistance </td>
          <td>(</td>
          <td class="paramtype">const arma::vec &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the minimum and maximum distance to another point. </p>

</div>
</div>
<a id="a326e0150de98039e6b9db9a89adc4275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a326e0150de98039e6b9db9a89adc4275">&#9670;&nbsp;</a></span>RangeDistance() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">math::RangeType&lt;<a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a>&gt; RangeDistance </td>
          <td>(</td>
          <td class="paramtype">const arma::vec &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a227d0c7e23e98fcd6c81ecab357a791f">ElemType</a>&#160;</td>
          <td class="paramname"><em>distance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the minimum and maximum distance to another point given that the point-to-point distance has already been calculated. </p>

</div>
</div>
<a id="a8dd9a9752971834a6c42ec7e45b71c84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dd9a9752971834a6c42ec7e45b71c84">&#9670;&nbsp;</a></span>Scale() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Scale </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the scale of this node. </p>

<p class="definition">Definition at line <a class="el" href="cover__tree_2cover__tree_8hpp_source.html#l00315">315</a> of file <a class="el" href="cover__tree_2cover__tree_8hpp_source.html">cover_tree.hpp</a>.</p>

</div>
</div>
<a id="a1bbfde922cf6700d130c5be70a5d7dd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bbfde922cf6700d130c5be70a5d7dd4">&#9670;&nbsp;</a></span>Scale() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int&amp; Scale </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify the scale of this node. Be careful... </p>

<p class="definition">Definition at line <a class="el" href="cover__tree_2cover__tree_8hpp_source.html#l00317">317</a> of file <a class="el" href="cover__tree_2cover__tree_8hpp_source.html">cover_tree.hpp</a>.</p>

</div>
</div>
<a id="a65cba07328997659bec80b9879b15a51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65cba07328997659bec80b9879b15a51">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serialize the tree. </p>

</div>
</div>
<a id="ad8b29c84ac793742cd15834f9f4c4f31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8b29c84ac793742cd15834f9f4c4f31">&#9670;&nbsp;</a></span>Stat() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const StatisticType&amp; Stat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the statistic for this node. </p>

<p class="definition">Definition at line <a class="el" href="cover__tree_2cover__tree_8hpp_source.html#l00325">325</a> of file <a class="el" href="cover__tree_2cover__tree_8hpp_source.html">cover_tree.hpp</a>.</p>

</div>
</div>
<a id="aac2d3c104b89109f3df4a9a8cad244da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac2d3c104b89109f3df4a9a8cad244da">&#9670;&nbsp;</a></span>Stat() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">StatisticType&amp; Stat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify the statistic for this node. </p>

<p class="definition">Definition at line <a class="el" href="cover__tree_2cover__tree_8hpp_source.html#l00327">327</a> of file <a class="el" href="cover__tree_2cover__tree_8hpp_source.html">cover_tree.hpp</a>.</p>

<p class="reference">References <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a0257281722537c7916db7763623f67f7">CoverTree&lt; MetricType, StatisticType, MatType, RootPointPolicy &gt;::GetFurthestChild()</a>, <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a19b9a5fd41d8e192b62effb1445bd410">CoverTree&lt; MetricType, StatisticType, MatType, RootPointPolicy &gt;::GetNearestChild()</a>, <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a03a85c9b3e3967ac6ff9107fc9fe8c60">CoverTree&lt; MetricType, StatisticType, MatType, RootPointPolicy &gt;::MaxDistance()</a>, <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a9d7c3fc69a509a305d08e1f3250002de">CoverTree&lt; MetricType, StatisticType, MatType, RootPointPolicy &gt;::MinDistance()</a>, and <a class="el" href="classmlpack_1_1tree_1_1CoverTree.html#a79946ce2f635d5731b5558ad4e8410cf">CoverTree&lt; MetricType, StatisticType, MatType, RootPointPolicy &gt;::RangeDistance()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/aakash/mlpack/src/mlpack/core/tree/cover_tree/<a class="el" href="cover__tree_2cover__tree_8hpp_source.html">cover_tree.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
<script type="text/javascript">
var x = document.querySelectorAll("img.formulaDsp");
var i;
for (i = 0; i < x.length; i++)
{
  x[i].width = x[i].offsetWidth / 4;
}
</script>
</html>
