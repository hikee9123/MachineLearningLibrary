<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>mlpack: RASearchRules&lt; SortPolicy, MetricType, TreeType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra-stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">mlpack
   &#160;<span id="projectnumber">3.4.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlpack.html">mlpack</a></li><li class="navelem"><a class="el" href="namespacemlpack_1_1neighbor.html">neighbor</a></li><li class="navelem"><a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html">RASearchRules</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classmlpack_1_1neighbor_1_1RASearchRules-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">RASearchRules&lt; SortPolicy, MetricType, TreeType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html" title="The RASearchRules class is a template helper class used by RASearch class when performing rank-approx...">RASearchRules</a> class is a template helper class used by <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html" title="The RASearch class: This class provides a generic manner to perform rank-approximate search via rando...">RASearch</a> class when performing rank-approximate search via random-sampling.  
 <a href="classmlpack_1_1neighbor_1_1RASearchRules.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ab5f079db10d0a6813eefeb1115e894cb"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classmlpack_1_1tree_1_1TraversalInfo.html">tree::TraversalInfo</a>&lt; TreeType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#ab5f079db10d0a6813eefeb1115e894cb">TraversalInfoType</a></td></tr>
<tr class="separator:ab5f079db10d0a6813eefeb1115e894cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa215aa687871d891ee298e5be340cd32"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#aa215aa687871d891ee298e5be340cd32">RASearchRules</a> (const arma::mat &amp;referenceSet, const arma::mat &amp;querySet, const size_t k, MetricType &amp;metric, const double tau=5, const double alpha=0.95, const bool naive=false, const bool sampleAtLeaves=false, const bool firstLeafExact=false, const size_t singleSampleLimit=20, const bool sameSet=false)</td></tr>
<tr class="memdesc:aa215aa687871d891ee298e5be340cd32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the <a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html" title="The RASearchRules class is a template helper class used by RASearch class when performing rank-approx...">RASearchRules</a> object.  <a href="#aa215aa687871d891ee298e5be340cd32">More...</a><br /></td></tr>
<tr class="separator:aa215aa687871d891ee298e5be340cd32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abac50f780bb5e1bc12dd0d16d850cacc"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#abac50f780bb5e1bc12dd0d16d850cacc">BaseCase</a> (const size_t queryIndex, const size_t referenceIndex)</td></tr>
<tr class="memdesc:abac50f780bb5e1bc12dd0d16d850cacc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the distance from the query point to the reference point.  <a href="#abac50f780bb5e1bc12dd0d16d850cacc">More...</a><br /></td></tr>
<tr class="separator:abac50f780bb5e1bc12dd0d16d850cacc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add24e5e55e4b8555dbd941b137a44491"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#add24e5e55e4b8555dbd941b137a44491">GetResults</a> (arma::Mat&lt; size_t &gt; &amp;neighbors, arma::mat &amp;distances)</td></tr>
<tr class="memdesc:add24e5e55e4b8555dbd941b137a44491"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store the list of candidates for each query point in the given matrices.  <a href="#add24e5e55e4b8555dbd941b137a44491">More...</a><br /></td></tr>
<tr class="separator:add24e5e55e4b8555dbd941b137a44491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a469f61784f9cce8f2574c23823405768"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#a469f61784f9cce8f2574c23823405768">MinimumBaseCases</a> () const</td></tr>
<tr class="memdesc:a469f61784f9cce8f2574c23823405768"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the minimum number of base cases that must be performed for each query point for an acceptable result.  <a href="#a469f61784f9cce8f2574c23823405768">More...</a><br /></td></tr>
<tr class="separator:a469f61784f9cce8f2574c23823405768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04b73c5ab1e330598f52d8eeb307b93e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#a04b73c5ab1e330598f52d8eeb307b93e">NumDistComputations</a> ()</td></tr>
<tr class="separator:a04b73c5ab1e330598f52d8eeb307b93e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9de23bafc455c99bc6d96a00386b025"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#af9de23bafc455c99bc6d96a00386b025">NumEffectiveSamples</a> ()</td></tr>
<tr class="separator:af9de23bafc455c99bc6d96a00386b025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f97dd07745e07a2d7ff3d4a42347e48"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#a6f97dd07745e07a2d7ff3d4a42347e48">Rescore</a> (const size_t queryIndex, TreeType &amp;referenceNode, const double oldScore)</td></tr>
<tr class="memdesc:a6f97dd07745e07a2d7ff3d4a42347e48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-evaluate the score for recursion order.  <a href="#a6f97dd07745e07a2d7ff3d4a42347e48">More...</a><br /></td></tr>
<tr class="separator:a6f97dd07745e07a2d7ff3d4a42347e48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a355b654f0c696bfe4f7be6d98c96d1ee"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#a355b654f0c696bfe4f7be6d98c96d1ee">Rescore</a> (TreeType &amp;queryNode, TreeType &amp;referenceNode, const double oldScore)</td></tr>
<tr class="memdesc:a355b654f0c696bfe4f7be6d98c96d1ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-evaluate the score for recursion order.  <a href="#a355b654f0c696bfe4f7be6d98c96d1ee">More...</a><br /></td></tr>
<tr class="separator:a355b654f0c696bfe4f7be6d98c96d1ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53d373b7aeee359b0e686f823c602b1c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#a53d373b7aeee359b0e686f823c602b1c">Score</a> (const size_t queryIndex, TreeType &amp;referenceNode)</td></tr>
<tr class="memdesc:a53d373b7aeee359b0e686f823c602b1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the score for recursion order.  <a href="#a53d373b7aeee359b0e686f823c602b1c">More...</a><br /></td></tr>
<tr class="separator:a53d373b7aeee359b0e686f823c602b1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ebec48c6a7d410c1792a778f0a99d1f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#a5ebec48c6a7d410c1792a778f0a99d1f">Score</a> (const size_t queryIndex, TreeType &amp;referenceNode, const double baseCaseResult)</td></tr>
<tr class="memdesc:a5ebec48c6a7d410c1792a778f0a99d1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the score for recursion order.  <a href="#a5ebec48c6a7d410c1792a778f0a99d1f">More...</a><br /></td></tr>
<tr class="separator:a5ebec48c6a7d410c1792a778f0a99d1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05b142945ef94221b628a75961f48b02"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#a05b142945ef94221b628a75961f48b02">Score</a> (TreeType &amp;queryNode, TreeType &amp;referenceNode)</td></tr>
<tr class="memdesc:a05b142945ef94221b628a75961f48b02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the score for recursion order.  <a href="#a05b142945ef94221b628a75961f48b02">More...</a><br /></td></tr>
<tr class="separator:a05b142945ef94221b628a75961f48b02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add6ee1729c77fa8df187140ec2086b58"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#add6ee1729c77fa8df187140ec2086b58">Score</a> (TreeType &amp;queryNode, TreeType &amp;referenceNode, const double baseCaseResult)</td></tr>
<tr class="memdesc:add6ee1729c77fa8df187140ec2086b58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the score for recursion order, passing the base case result (in the situation where it may be needed to calculate the recursion order).  <a href="#add6ee1729c77fa8df187140ec2086b58">More...</a><br /></td></tr>
<tr class="separator:add6ee1729c77fa8df187140ec2086b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5c6f4ae7c3b71b808403a7b7454f26f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#ab5f079db10d0a6813eefeb1115e894cb">TraversalInfoType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#ab5c6f4ae7c3b71b808403a7b7454f26f">TraversalInfo</a> () const</td></tr>
<tr class="separator:ab5c6f4ae7c3b71b808403a7b7454f26f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4027bb90e756a4520d55978459c7f83e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#ab5f079db10d0a6813eefeb1115e894cb">TraversalInfoType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#a4027bb90e756a4520d55978459c7f83e">TraversalInfo</a> ()</td></tr>
<tr class="separator:a4027bb90e756a4520d55978459c7f83e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename SortPolicy, typename MetricType, typename TreeType&gt;<br />
class mlpack::neighbor::RASearchRules&lt; SortPolicy, MetricType, TreeType &gt;</h3>

<p>The <a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html" title="The RASearchRules class is a template helper class used by RASearch class when performing rank-approx...">RASearchRules</a> class is a template helper class used by <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html" title="The RASearch class: This class provides a generic manner to perform rank-approximate search via rando...">RASearch</a> class when performing rank-approximate search via random-sampling. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SortPolicy</td><td>The sort policy for distances. </td></tr>
    <tr><td class="paramname">MetricType</td><td>The metric to use for computation. </td></tr>
    <tr><td class="paramname">TreeType</td><td>The tree type to use; must adhere to the TreeType API. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ra__search__rules_8hpp_source.html#l00033">33</a> of file <a class="el" href="ra__search__rules_8hpp_source.html">ra_search_rules.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ab5f079db10d0a6813eefeb1115e894cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5f079db10d0a6813eefeb1115e894cb">&#9670;&nbsp;</a></span>TraversalInfoType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classmlpack_1_1tree_1_1TraversalInfo.html">tree::TraversalInfo</a>&lt;TreeType&gt; <a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#ab5f079db10d0a6813eefeb1115e894cb">TraversalInfoType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ra__search__rules_8hpp_source.html#l00239">239</a> of file <a class="el" href="ra__search__rules_8hpp_source.html">ra_search_rules.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa215aa687871d891ee298e5be340cd32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa215aa687871d891ee298e5be340cd32">&#9670;&nbsp;</a></span>RASearchRules()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html">RASearchRules</a> </td>
          <td>(</td>
          <td class="paramtype">const arma::mat &amp;&#160;</td>
          <td class="paramname"><em>referenceSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arma::mat &amp;&#160;</td>
          <td class="paramname"><em>querySet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MetricType &amp;&#160;</td>
          <td class="paramname"><em>metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>tau</em> = <code>5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>alpha</em> = <code>0.95</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>naive</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>sampleAtLeaves</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>firstLeafExact</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>singleSampleLimit</em> = <code>20</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>sameSet</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the <a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html" title="The RASearchRules class is a template helper class used by RASearch class when performing rank-approx...">RASearchRules</a> object. </p>
<p>This is usually done from within the <a class="el" href="classmlpack_1_1neighbor_1_1RASearch.html" title="The RASearch class: This class provides a generic manner to perform rank-approximate search via rando...">RASearch</a> class at search time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">referenceSet</td><td>Set of reference data. </td></tr>
    <tr><td class="paramname">querySet</td><td>Set of query data. </td></tr>
    <tr><td class="paramname">k</td><td>Number of neighbors to search for. </td></tr>
    <tr><td class="paramname">metric</td><td>Instantiated metric. </td></tr>
    <tr><td class="paramname">tau</td><td>The rank-approximation in percentile of the data. </td></tr>
    <tr><td class="paramname">alpha</td><td>The desired success probability. </td></tr>
    <tr><td class="paramname">naive</td><td>If true, the rank-approximate search will be performed by directly sampling the whole set instead of using the stratified sampling on the tree. </td></tr>
    <tr><td class="paramname">sampleAtLeaves</td><td>Sample at leaves for faster but less accurate computation. </td></tr>
    <tr><td class="paramname">firstLeafExact</td><td>Traverse to the first leaf without approximation. </td></tr>
    <tr><td class="paramname">singleSampleLimit</td><td>The limit on the largest node that can be approximated by sampling. </td></tr>
    <tr><td class="paramname">sameSet</td><td>If true, the query and reference set are taken to be the same, and a query point will not return itself in the results. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="abac50f780bb5e1bc12dd0d16d850cacc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abac50f780bb5e1bc12dd0d16d850cacc">&#9670;&nbsp;</a></span>BaseCase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double BaseCase </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>queryIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>referenceIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the distance from the query point to the reference point. </p>
<p>This will update the list of candidates with the new point if appropriate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queryIndex</td><td>Index of query point. </td></tr>
    <tr><td class="paramname">referenceIndex</td><td>Index of reference point. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="add24e5e55e4b8555dbd941b137a44491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add24e5e55e4b8555dbd941b137a44491">&#9670;&nbsp;</a></span>GetResults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GetResults </td>
          <td>(</td>
          <td class="paramtype">arma::Mat&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>neighbors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::mat &amp;&#160;</td>
          <td class="paramname"><em>distances</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store the list of candidates for each query point in the given matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">neighbors</td><td>Matrix storing lists of neighbors for each query point. </td></tr>
    <tr><td class="paramname">distances</td><td>Matrix storing distances of neighbors for each query point. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a469f61784f9cce8f2574c23823405768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a469f61784f9cce8f2574c23823405768">&#9670;&nbsp;</a></span>MinimumBaseCases()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t MinimumBaseCases </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the minimum number of base cases that must be performed for each query point for an acceptable result. </p>
<p>This is only needed in defeatist search mode. </p>

<p class="definition">Definition at line <a class="el" href="ra__search__rules_8hpp_source.html#l00247">247</a> of file <a class="el" href="ra__search__rules_8hpp_source.html">ra_search_rules.hpp</a>.</p>

<p class="reference">References <a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#a53d373b7aeee359b0e686f823c602b1c">RASearchRules&lt; SortPolicy, MetricType, TreeType &gt;::Score()</a>.</p>

</div>
</div>
<a id="a04b73c5ab1e330598f52d8eeb307b93e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04b73c5ab1e330598f52d8eeb307b93e">&#9670;&nbsp;</a></span>NumDistComputations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t NumDistComputations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ra__search__rules_8hpp_source.html#l00230">230</a> of file <a class="el" href="ra__search__rules_8hpp_source.html">ra_search_rules.hpp</a>.</p>

</div>
</div>
<a id="af9de23bafc455c99bc6d96a00386b025"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9de23bafc455c99bc6d96a00386b025">&#9670;&nbsp;</a></span>NumEffectiveSamples()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t NumEffectiveSamples </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ra__search__rules_8hpp_source.html#l00231">231</a> of file <a class="el" href="ra__search__rules_8hpp_source.html">ra_search_rules.hpp</a>.</p>

</div>
</div>
<a id="a6f97dd07745e07a2d7ff3d4a42347e48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f97dd07745e07a2d7ff3d4a42347e48">&#9670;&nbsp;</a></span>Rescore() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Rescore </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>queryIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TreeType &amp;&#160;</td>
          <td class="paramname"><em>referenceNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>oldScore</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Re-evaluate the score for recursion order. </p>
<p>A low score indicates priority for recursion, while DBL_MAX indicates that the node should not be recursed into at all (it should be pruned). This is used when the score has already been calculated, but another recursion may have modified the bounds for pruning. So the old score is checked against the new pruning bound.</p>
<p>For rank-approximation, it also checks if the number of samples left for a query to satisfy the rank constraint is small enough at this point of the algorithm, then this node is approximated by sampling and given a new score of 'DBL_MAX'.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queryIndex</td><td>Index of query point. </td></tr>
    <tr><td class="paramname">referenceNode</td><td>Candidate node to be recursed into. </td></tr>
    <tr><td class="paramname">oldScore</td><td>Old score produced by <a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#a53d373b7aeee359b0e686f823c602b1c" title="Get the score for recursion order. ">Score()</a> (or <a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#a6f97dd07745e07a2d7ff3d4a42347e48" title="Re-evaluate the score for recursion order. ">Rescore()</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a355b654f0c696bfe4f7be6d98c96d1ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a355b654f0c696bfe4f7be6d98c96d1ee">&#9670;&nbsp;</a></span>Rescore() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Rescore </td>
          <td>(</td>
          <td class="paramtype">TreeType &amp;&#160;</td>
          <td class="paramname"><em>queryNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TreeType &amp;&#160;</td>
          <td class="paramname"><em>referenceNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>oldScore</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Re-evaluate the score for recursion order. </p>
<p>A low score indicates priority for recursion, while DBL_MAX indicates that the node should not be recursed into at all (it should be pruned). This is used when the score has already been calculated, but another recursion may have modified the bounds for pruning. So the old score is checked against the new pruning bound.</p>
<p>For the rank-approximation, we check if the referenceNode can be approximated by sampling. If it can be, enough samples are made for every query in the queryNode. No further query-tree traversal is performed.</p>
<p>The 'NumSamplesMade' query stat is propagated up the tree. And then if pruning occurs (by distance or by sampling), the 'NumSamplesMade' stat is not propagated down the tree. If no pruning occurs, the stat is propagated down the tree.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queryNode</td><td>Candidate query node to recurse into. </td></tr>
    <tr><td class="paramname">referenceNode</td><td>Candidate reference node to recurse into. </td></tr>
    <tr><td class="paramname">oldScore</td><td>Old score produced by Socre() (or <a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#a6f97dd07745e07a2d7ff3d4a42347e48" title="Re-evaluate the score for recursion order. ">Rescore()</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a53d373b7aeee359b0e686f823c602b1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53d373b7aeee359b0e686f823c602b1c">&#9670;&nbsp;</a></span>Score() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Score </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>queryIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TreeType &amp;&#160;</td>
          <td class="paramname"><em>referenceNode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the score for recursion order. </p>
<p>A low score indicates priority for recursion, while DBL_MAX indicates that the node should not be recursed into at all (it should be pruned).</p>
<p>For rank-approximation, the scoring function first checks if pruning by distance is possible. If yes, then the node is given the score of 'DBL_MAX' and the expected number of samples from that node are added to the number of samples made for the query.</p>
<p>If no, then the function tries to see if the node can be pruned by approximation. If number of samples required from this node is small enough, then that number of samples are acquired from this node and the score is set to be 'DBL_MAX'.</p>
<p>If the pruning by approximation is not possible either, the algorithm continues with the usual tree-traversal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queryIndex</td><td>Index of query point. </td></tr>
    <tr><td class="paramname">referenceNode</td><td>Candidate node to be recursed into. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="ra__search__rules_8hpp_source.html#l00247">RASearchRules&lt; SortPolicy, MetricType, TreeType &gt;::MinimumBaseCases()</a>.</p>

</div>
</div>
<a id="a5ebec48c6a7d410c1792a778f0a99d1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ebec48c6a7d410c1792a778f0a99d1f">&#9670;&nbsp;</a></span>Score() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Score </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>queryIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TreeType &amp;&#160;</td>
          <td class="paramname"><em>referenceNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>baseCaseResult</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the score for recursion order. </p>
<p>A low score indicates priority for recursion, while DBL_MAX indicates that the node should not be recursed into at all (it should be pruned).</p>
<p>For rank-approximation, the scoring function first checks if pruning by distance is possible. If yes, then the node is given the score of 'DBL_MAX' and the expected number of samples from that node are added to the number of samples made for the query.</p>
<p>If no, then the function tries to see if the node can be pruned by approximation. If number of samples required from this node is small enough, then that number of samples are acquired from this node and the score is set to be 'DBL_MAX'.</p>
<p>If the pruning by approximation is not possible either, the algorithm continues with the usual tree-traversal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queryIndex</td><td>Index of query point. </td></tr>
    <tr><td class="paramname">referenceNode</td><td>Candidate node to be recursed into. </td></tr>
    <tr><td class="paramname">baseCaseResult</td><td>Result of BaseCase(queryIndex, referenceNode). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a05b142945ef94221b628a75961f48b02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05b142945ef94221b628a75961f48b02">&#9670;&nbsp;</a></span>Score() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Score </td>
          <td>(</td>
          <td class="paramtype">TreeType &amp;&#160;</td>
          <td class="paramname"><em>queryNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TreeType &amp;&#160;</td>
          <td class="paramname"><em>referenceNode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the score for recursion order. </p>
<p>A low score indicates priority for recursionm while DBL_MAX indicates that the node should not be recursed into at all (it should be pruned).</p>
<p>For the rank-approximation, we check if the referenceNode can be approximated by sampling. If it can be, enough samples are made for every query in the queryNode. No further query-tree traversal is performed.</p>
<p>The 'NumSamplesMade' query stat is propagated up the tree. And then if pruning occurs (by distance or by sampling), the 'NumSamplesMade' stat is not propagated down the tree. If no pruning occurs, the stat is propagated down the tree.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queryNode</td><td>Candidate query node to recurse into. </td></tr>
    <tr><td class="paramname">referenceNode</td><td>Candidate reference node to recurse into. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="add6ee1729c77fa8df187140ec2086b58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add6ee1729c77fa8df187140ec2086b58">&#9670;&nbsp;</a></span>Score() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Score </td>
          <td>(</td>
          <td class="paramtype">TreeType &amp;&#160;</td>
          <td class="paramname"><em>queryNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TreeType &amp;&#160;</td>
          <td class="paramname"><em>referenceNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>baseCaseResult</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the score for recursion order, passing the base case result (in the situation where it may be needed to calculate the recursion order). </p>
<p>A low score indicates priority for recursion, while DBL_MAX indicates that the node should not be recursed into at all (it should be pruned).</p>
<p>For the rank-approximation, we check if the referenceNode can be approximated by sampling. If it can be, enough samples are made for every query in the queryNode. No further query-tree traversal is performed.</p>
<p>The 'NumSamplesMade' query stat is propagated up the tree. And then if pruning occurs (by distance or by sampling), the 'NumSamplesMade' stat is not propagated down the tree. If no pruning occurs, the stat is propagated down the tree.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queryNode</td><td>Candidate query node to recurse into. </td></tr>
    <tr><td class="paramname">referenceNode</td><td>Candidate reference node to recurse into. </td></tr>
    <tr><td class="paramname">baseCaseResult</td><td>Result of BaseCase(queryIndex, referenceNode). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab5c6f4ae7c3b71b808403a7b7454f26f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5c6f4ae7c3b71b808403a7b7454f26f">&#9670;&nbsp;</a></span>TraversalInfo() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#ab5f079db10d0a6813eefeb1115e894cb">TraversalInfoType</a>&amp; TraversalInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ra__search__rules_8hpp_source.html#l00241">241</a> of file <a class="el" href="ra__search__rules_8hpp_source.html">ra_search_rules.hpp</a>.</p>

</div>
</div>
<a id="a4027bb90e756a4520d55978459c7f83e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4027bb90e756a4520d55978459c7f83e">&#9670;&nbsp;</a></span>TraversalInfo() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1neighbor_1_1RASearchRules.html#ab5f079db10d0a6813eefeb1115e894cb">TraversalInfoType</a>&amp; TraversalInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ra__search__rules_8hpp_source.html#l00242">242</a> of file <a class="el" href="ra__search__rules_8hpp_source.html">ra_search_rules.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/aakash/mlpack/src/mlpack/methods/rann/<a class="el" href="ra__search__rules_8hpp_source.html">ra_search_rules.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
<script type="text/javascript">
var x = document.querySelectorAll("img.formulaDsp");
var i;
for (i = 0; i < x.length; i++)
{
  x[i].width = x[i].offsetWidth / 4;
}
</script>
</html>
