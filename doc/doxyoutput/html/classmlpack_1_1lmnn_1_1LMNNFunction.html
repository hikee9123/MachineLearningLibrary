<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>mlpack: LMNNFunction&lt; MetricType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra-stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">mlpack
   &#160;<span id="projectnumber">3.4.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlpack.html">mlpack</a></li><li class="navelem"><a class="el" href="namespacemlpack_1_1lmnn.html">lmnn</a></li><li class="navelem"><a class="el" href="classmlpack_1_1lmnn_1_1LMNNFunction.html">LMNNFunction</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classmlpack_1_1lmnn_1_1LMNNFunction-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">LMNNFunction&lt; MetricType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The Large Margin Nearest Neighbors function.  
 <a href="classmlpack_1_1lmnn_1_1LMNNFunction.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad5d0ec2e3f5998fce48a99a212437c7b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1lmnn_1_1LMNNFunction.html#ad5d0ec2e3f5998fce48a99a212437c7b">LMNNFunction</a> (const arma::mat &amp;dataset, const arma::Row&lt; size_t &gt; &amp;labels, size_t k, double regularization, size_t range, MetricType metric=MetricType())</td></tr>
<tr class="memdesc:ad5d0ec2e3f5998fce48a99a212437c7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for <a class="el" href="classmlpack_1_1lmnn_1_1LMNNFunction.html" title="The Large Margin Nearest Neighbors function. ">LMNNFunction</a> class.  <a href="#ad5d0ec2e3f5998fce48a99a212437c7b">More...</a><br /></td></tr>
<tr class="separator:ad5d0ec2e3f5998fce48a99a212437c7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff320b9a86b77a150e630c01d5888273"><td class="memItemLeft" align="right" valign="top">const arma::mat &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1lmnn_1_1LMNNFunction.html#aff320b9a86b77a150e630c01d5888273">Dataset</a> () const</td></tr>
<tr class="memdesc:aff320b9a86b77a150e630c01d5888273"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the dataset passed into the constructor.  <a href="#aff320b9a86b77a150e630c01d5888273">More...</a><br /></td></tr>
<tr class="separator:aff320b9a86b77a150e630c01d5888273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a984a5518a600950a14782757aea93b59"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1lmnn_1_1LMNNFunction.html#a984a5518a600950a14782757aea93b59">Evaluate</a> (const arma::mat &amp;transformation)</td></tr>
<tr class="memdesc:a984a5518a600950a14782757aea93b59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the <a class="el" href="classmlpack_1_1lmnn_1_1LMNN.html" title="An implementation of Large Margin nearest neighbor metric learning technique. ">LMNN</a> function for the given transformation matrix.  <a href="#a984a5518a600950a14782757aea93b59">More...</a><br /></td></tr>
<tr class="separator:a984a5518a600950a14782757aea93b59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ec40724bffda10e022fdaf072fae3ac"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1lmnn_1_1LMNNFunction.html#a3ec40724bffda10e022fdaf072fae3ac">Evaluate</a> (const arma::mat &amp;transformation, const size_t begin, const size_t batchSize=1)</td></tr>
<tr class="memdesc:a3ec40724bffda10e022fdaf072fae3ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the <a class="el" href="classmlpack_1_1lmnn_1_1LMNN.html" title="An implementation of Large Margin nearest neighbor metric learning technique. ">LMNN</a> objective function for the given transformation matrix on the given batch size from a given inital point of the dataset.  <a href="#a3ec40724bffda10e022fdaf072fae3ac">More...</a><br /></td></tr>
<tr class="separator:a3ec40724bffda10e022fdaf072fae3ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18208d5789919b6d12eaaffe007b7dcf"><td class="memTemplParams" colspan="2">template&lt;typename GradType &gt; </td></tr>
<tr class="memitem:a18208d5789919b6d12eaaffe007b7dcf"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlpack_1_1lmnn_1_1LMNNFunction.html#a18208d5789919b6d12eaaffe007b7dcf">EvaluateWithGradient</a> (const arma::mat &amp;transformation, GradType &amp;gradient)</td></tr>
<tr class="memdesc:a18208d5789919b6d12eaaffe007b7dcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the <a class="el" href="classmlpack_1_1lmnn_1_1LMNN.html" title="An implementation of Large Margin nearest neighbor metric learning technique. ">LMNN</a> objective function together with gradient for the given transformation matrix.  <a href="#a18208d5789919b6d12eaaffe007b7dcf">More...</a><br /></td></tr>
<tr class="separator:a18208d5789919b6d12eaaffe007b7dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71970d9b9013a39efd08c1054c077557"><td class="memTemplParams" colspan="2">template&lt;typename GradType &gt; </td></tr>
<tr class="memitem:a71970d9b9013a39efd08c1054c077557"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlpack_1_1lmnn_1_1LMNNFunction.html#a71970d9b9013a39efd08c1054c077557">EvaluateWithGradient</a> (const arma::mat &amp;transformation, const size_t begin, GradType &amp;gradient, const size_t batchSize=1)</td></tr>
<tr class="memdesc:a71970d9b9013a39efd08c1054c077557"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the <a class="el" href="classmlpack_1_1lmnn_1_1LMNN.html" title="An implementation of Large Margin nearest neighbor metric learning technique. ">LMNN</a> objective function together with gradient for the given transformation matrix on the given batch size, from a given initial point of the dataset.  <a href="#a71970d9b9013a39efd08c1054c077557">More...</a><br /></td></tr>
<tr class="separator:a71970d9b9013a39efd08c1054c077557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3e9aa612cb56d0d93f3259f4a8122bb"><td class="memItemLeft" align="right" valign="top">const arma::mat &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1lmnn_1_1LMNNFunction.html#ac3e9aa612cb56d0d93f3259f4a8122bb">GetInitialPoint</a> () const</td></tr>
<tr class="memdesc:ac3e9aa612cb56d0d93f3259f4a8122bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the initial point for the optimization.  <a href="#ac3e9aa612cb56d0d93f3259f4a8122bb">More...</a><br /></td></tr>
<tr class="separator:ac3e9aa612cb56d0d93f3259f4a8122bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ab4bb24874b8bd6fee743b169f1d059"><td class="memTemplParams" colspan="2">template&lt;typename GradType &gt; </td></tr>
<tr class="memitem:a8ab4bb24874b8bd6fee743b169f1d059"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlpack_1_1lmnn_1_1LMNNFunction.html#a8ab4bb24874b8bd6fee743b169f1d059">Gradient</a> (const arma::mat &amp;transformation, GradType &amp;gradient)</td></tr>
<tr class="memdesc:a8ab4bb24874b8bd6fee743b169f1d059"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the gradient of the <a class="el" href="classmlpack_1_1lmnn_1_1LMNN.html" title="An implementation of Large Margin nearest neighbor metric learning technique. ">LMNN</a> function for the given transformation matrix.  <a href="#a8ab4bb24874b8bd6fee743b169f1d059">More...</a><br /></td></tr>
<tr class="separator:a8ab4bb24874b8bd6fee743b169f1d059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac15fcb34b662aa35bb6fb4a089ae1de4"><td class="memTemplParams" colspan="2">template&lt;typename GradType &gt; </td></tr>
<tr class="memitem:ac15fcb34b662aa35bb6fb4a089ae1de4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlpack_1_1lmnn_1_1LMNNFunction.html#ac15fcb34b662aa35bb6fb4a089ae1de4">Gradient</a> (const arma::mat &amp;transformation, const size_t begin, GradType &amp;gradient, const size_t batchSize=1)</td></tr>
<tr class="memdesc:ac15fcb34b662aa35bb6fb4a089ae1de4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the gradient of the <a class="el" href="classmlpack_1_1lmnn_1_1LMNN.html" title="An implementation of Large Margin nearest neighbor metric learning technique. ">LMNN</a> function for the given transformation matrix on the given batch size, from a given initial point of the dataset.  <a href="#ac15fcb34b662aa35bb6fb4a089ae1de4">More...</a><br /></td></tr>
<tr class="separator:ac15fcb34b662aa35bb6fb4a089ae1de4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab749ea30c4c3d750ef3a619f32dc3e75"><td class="memItemLeft" align="right" valign="top">const size_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1lmnn_1_1LMNNFunction.html#ab749ea30c4c3d750ef3a619f32dc3e75">K</a> () const</td></tr>
<tr class="memdesc:ab749ea30c4c3d750ef3a619f32dc3e75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the value of k.  <a href="#ab749ea30c4c3d750ef3a619f32dc3e75">More...</a><br /></td></tr>
<tr class="separator:ab749ea30c4c3d750ef3a619f32dc3e75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af80ea69c69c6463691509f509f3bff05"><td class="memItemLeft" align="right" valign="top">size_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1lmnn_1_1LMNNFunction.html#af80ea69c69c6463691509f509f3bff05">K</a> ()</td></tr>
<tr class="memdesc:af80ea69c69c6463691509f509f3bff05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the value of k.  <a href="#af80ea69c69c6463691509f509f3bff05">More...</a><br /></td></tr>
<tr class="separator:af80ea69c69c6463691509f509f3bff05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa76af34a6e3ea927b307f0c318ee4b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1lmnn_1_1LMNNFunction.html#a1fa76af34a6e3ea927b307f0c318ee4b">NumFunctions</a> () const</td></tr>
<tr class="memdesc:a1fa76af34a6e3ea927b307f0c318ee4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of functions the objective function can be decomposed into.  <a href="#a1fa76af34a6e3ea927b307f0c318ee4b">More...</a><br /></td></tr>
<tr class="separator:a1fa76af34a6e3ea927b307f0c318ee4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a26c8724520d749b483fe8dcfe7416b"><td class="memItemLeft" align="right" valign="top">const size_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1lmnn_1_1LMNNFunction.html#a8a26c8724520d749b483fe8dcfe7416b">Range</a> () const</td></tr>
<tr class="memdesc:a8a26c8724520d749b483fe8dcfe7416b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the value of range.  <a href="#a8a26c8724520d749b483fe8dcfe7416b">More...</a><br /></td></tr>
<tr class="separator:a8a26c8724520d749b483fe8dcfe7416b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2cebd1b43cb779465e7323255112bb4"><td class="memItemLeft" align="right" valign="top">size_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1lmnn_1_1LMNNFunction.html#ab2cebd1b43cb779465e7323255112bb4">Range</a> ()</td></tr>
<tr class="memdesc:ab2cebd1b43cb779465e7323255112bb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the value of k.  <a href="#ab2cebd1b43cb779465e7323255112bb4">More...</a><br /></td></tr>
<tr class="separator:ab2cebd1b43cb779465e7323255112bb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3a3c8f810d08e2e922b3c30e29b7f11"><td class="memItemLeft" align="right" valign="top">const double &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1lmnn_1_1LMNNFunction.html#ad3a3c8f810d08e2e922b3c30e29b7f11">Regularization</a> () const</td></tr>
<tr class="memdesc:ad3a3c8f810d08e2e922b3c30e29b7f11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the regularization value.  <a href="#ad3a3c8f810d08e2e922b3c30e29b7f11">More...</a><br /></td></tr>
<tr class="separator:ad3a3c8f810d08e2e922b3c30e29b7f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c741ac26a2c0ee8bb0fbe52534dd544"><td class="memItemLeft" align="right" valign="top">double &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1lmnn_1_1LMNNFunction.html#a9c741ac26a2c0ee8bb0fbe52534dd544">Regularization</a> ()</td></tr>
<tr class="memdesc:a9c741ac26a2c0ee8bb0fbe52534dd544"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the regularization value.  <a href="#a9c741ac26a2c0ee8bb0fbe52534dd544">More...</a><br /></td></tr>
<tr class="separator:a9c741ac26a2c0ee8bb0fbe52534dd544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2697cc8b37d7bca7c055228382a9b208"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1lmnn_1_1LMNNFunction.html#a2697cc8b37d7bca7c055228382a9b208">Shuffle</a> ()</td></tr>
<tr class="memdesc:a2697cc8b37d7bca7c055228382a9b208"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shuffle the points in the dataset.  <a href="#a2697cc8b37d7bca7c055228382a9b208">More...</a><br /></td></tr>
<tr class="separator:a2697cc8b37d7bca7c055228382a9b208"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename MetricType = metric::SquaredEuclideanDistance&gt;<br />
class mlpack::lmnn::LMNNFunction&lt; MetricType &gt;</h3>

<p>The Large Margin Nearest Neighbors function. </p>
<p>The actual function is</p>
<p><img class="formulaInl" alt="$ \epsilon(M) = \sum_{ij}\eta_{ij}|| L x_i - L x_j ||^2 + c\sum_{ijl}\eta_{ij}(1-y_{il})[1 + || L x_i - L x_j ||^2 - || L x_i - L x_l ||^2)]_{+} $" src="form_163.png"/></p>
<p>where x_n represents a point and A is the current scaling matrix.</p>
<p>This class is more flexible than the original paper, allowing an arbitrary metric function to be used in place of || A x_i - A x_j ||^2, meaning that the squared Euclidean distance is not the only allowed metric for <a class="el" href="classmlpack_1_1lmnn_1_1LMNN.html" title="An implementation of Large Margin nearest neighbor metric learning technique. ">LMNN</a>. However, that is probably the best way to use this class.</p>
<p>In addition to the standard <a class="el" href="classmlpack_1_1lmnn_1_1LMNNFunction.html#a984a5518a600950a14782757aea93b59" title="Evaluate the LMNN function for the given transformation matrix. ">Evaluate()</a> and <a class="el" href="classmlpack_1_1lmnn_1_1LMNNFunction.html#a8ab4bb24874b8bd6fee743b169f1d059" title="Evaluate the gradient of the LMNN function for the given transformation matrix. ">Gradient()</a> functions which mlpack optimizers use, overloads of <a class="el" href="classmlpack_1_1lmnn_1_1LMNNFunction.html#a984a5518a600950a14782757aea93b59" title="Evaluate the LMNN function for the given transformation matrix. ">Evaluate()</a> and <a class="el" href="classmlpack_1_1lmnn_1_1LMNNFunction.html#a8ab4bb24874b8bd6fee743b169f1d059" title="Evaluate the gradient of the LMNN function for the given transformation matrix. ">Gradient()</a> are given which only operate on one point in the dataset. This is useful for optimizers like stochastic gradient descent (see ens::SGD). </p>

<p class="definition">Definition at line <a class="el" href="lmnn__function_8hpp_source.html#l00046">46</a> of file <a class="el" href="lmnn__function_8hpp_source.html">lmnn_function.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad5d0ec2e3f5998fce48a99a212437c7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5d0ec2e3f5998fce48a99a212437c7b">&#9670;&nbsp;</a></span>LMNNFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1lmnn_1_1LMNNFunction.html">LMNNFunction</a> </td>
          <td>(</td>
          <td class="paramtype">const arma::mat &amp;&#160;</td>
          <td class="paramname"><em>dataset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arma::Row&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>regularization</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MetricType&#160;</td>
          <td class="paramname"><em>metric</em> = <code>MetricType()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor for <a class="el" href="classmlpack_1_1lmnn_1_1LMNNFunction.html" title="The Large Margin Nearest Neighbors function. ">LMNNFunction</a> class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataset</td><td>Input dataset. </td></tr>
    <tr><td class="paramname">labels</td><td>Input dataset labels. </td></tr>
    <tr><td class="paramname">k</td><td>Number of target neighbors to be used. </td></tr>
    <tr><td class="paramname">regularization</td><td>Regularization value. </td></tr>
    <tr><td class="paramname">range</td><td>Range after which impostors need to be recalculated. </td></tr>
    <tr><td class="paramname">metric</td><td>Type of metric used for computation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aff320b9a86b77a150e630c01d5888273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff320b9a86b77a150e630c01d5888273">&#9670;&nbsp;</a></span>Dataset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const arma::mat&amp; Dataset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the dataset passed into the constructor. </p>

<p class="definition">Definition at line <a class="el" href="lmnn__function_8hpp_source.html#l00175">175</a> of file <a class="el" href="lmnn__function_8hpp_source.html">lmnn_function.hpp</a>.</p>

</div>
</div>
<a id="a984a5518a600950a14782757aea93b59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a984a5518a600950a14782757aea93b59">&#9670;&nbsp;</a></span>Evaluate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Evaluate </td>
          <td>(</td>
          <td class="paramtype">const arma::mat &amp;&#160;</td>
          <td class="paramname"><em>transformation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate the <a class="el" href="classmlpack_1_1lmnn_1_1LMNN.html" title="An implementation of Large Margin nearest neighbor metric learning technique. ">LMNN</a> function for the given transformation matrix. </p>
<p>This is the non-separable implementation, where the objective function is not decomposed into the sum of several objective functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transformation</td><td>Transformation matrix of Mahalanobis distance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3ec40724bffda10e022fdaf072fae3ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ec40724bffda10e022fdaf072fae3ac">&#9670;&nbsp;</a></span>Evaluate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Evaluate </td>
          <td>(</td>
          <td class="paramtype">const arma::mat &amp;&#160;</td>
          <td class="paramname"><em>transformation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>batchSize</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate the <a class="el" href="classmlpack_1_1lmnn_1_1LMNN.html" title="An implementation of Large Margin nearest neighbor metric learning technique. ">LMNN</a> objective function for the given transformation matrix on the given batch size from a given inital point of the dataset. </p>
<p>This is the separable implementation, where the objective function is decomposed into the sum of many objective functions, and here, only one of those constituent objective functions is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transformation</td><td>Transformation matrix of Mahalanobis distance. </td></tr>
    <tr><td class="paramname">begin</td><td>Index of the initial point to use for objective function. </td></tr>
    <tr><td class="paramname">batchSize</td><td>Number of points to use for objective function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a18208d5789919b6d12eaaffe007b7dcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18208d5789919b6d12eaaffe007b7dcf">&#9670;&nbsp;</a></span>EvaluateWithGradient() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double EvaluateWithGradient </td>
          <td>(</td>
          <td class="paramtype">const arma::mat &amp;&#160;</td>
          <td class="paramname"><em>transformation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GradType &amp;&#160;</td>
          <td class="paramname"><em>gradient</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate the <a class="el" href="classmlpack_1_1lmnn_1_1LMNN.html" title="An implementation of Large Margin nearest neighbor metric learning technique. ">LMNN</a> objective function together with gradient for the given transformation matrix. </p>
<p>This is the non-separable implementation, where the objective function is not decomposed into the sum of several objective functions.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">GradType</td><td>The type of the gradient out-param. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transformation</td><td>Transformation matrix of Mahalanobis distance. </td></tr>
    <tr><td class="paramname">gradient</td><td>Matrix to store the calculated gradient in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a71970d9b9013a39efd08c1054c077557"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71970d9b9013a39efd08c1054c077557">&#9670;&nbsp;</a></span>EvaluateWithGradient() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double EvaluateWithGradient </td>
          <td>(</td>
          <td class="paramtype">const arma::mat &amp;&#160;</td>
          <td class="paramname"><em>transformation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GradType &amp;&#160;</td>
          <td class="paramname"><em>gradient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>batchSize</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate the <a class="el" href="classmlpack_1_1lmnn_1_1LMNN.html" title="An implementation of Large Margin nearest neighbor metric learning technique. ">LMNN</a> objective function together with gradient for the given transformation matrix on the given batch size, from a given initial point of the dataset. </p>
<p>This is the separable implementation, where the objective function is decomposed into the sum of many objective functions, and here, only one of those constituent objective functions is returned. The type of the gradient parameter is a template argument to allow the computation of a sparse gradient.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">GradType</td><td>The type of the gradient out-param. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transformation</td><td>Transformation matrix of Mahalanobis distance. </td></tr>
    <tr><td class="paramname">begin</td><td>Index of the initial point to use for objective function. </td></tr>
    <tr><td class="paramname">gradient</td><td>Matrix to store the calculated gradient in. </td></tr>
    <tr><td class="paramname">batchSize</td><td>Number of points to use for objective function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac3e9aa612cb56d0d93f3259f4a8122bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3e9aa612cb56d0d93f3259f4a8122bb">&#9670;&nbsp;</a></span>GetInitialPoint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const arma::mat&amp; GetInitialPoint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the initial point for the optimization. </p>

<p class="definition">Definition at line <a class="el" href="lmnn__function_8hpp_source.html#l00166">166</a> of file <a class="el" href="lmnn__function_8hpp_source.html">lmnn_function.hpp</a>.</p>

</div>
</div>
<a id="a8ab4bb24874b8bd6fee743b169f1d059"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ab4bb24874b8bd6fee743b169f1d059">&#9670;&nbsp;</a></span>Gradient() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gradient </td>
          <td>(</td>
          <td class="paramtype">const arma::mat &amp;&#160;</td>
          <td class="paramname"><em>transformation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GradType &amp;&#160;</td>
          <td class="paramname"><em>gradient</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate the gradient of the <a class="el" href="classmlpack_1_1lmnn_1_1LMNN.html" title="An implementation of Large Margin nearest neighbor metric learning technique. ">LMNN</a> function for the given transformation matrix. </p>
<p>This is the non-separable implementation, where the objective function is not decomposed into the sum of several objective functions.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">GradType</td><td>The type of the gradient out-param. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transformation</td><td>Transformation matrix of Mahalanobis distance. </td></tr>
    <tr><td class="paramname">gradient</td><td>Matrix to store the calculated gradient in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac15fcb34b662aa35bb6fb4a089ae1de4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac15fcb34b662aa35bb6fb4a089ae1de4">&#9670;&nbsp;</a></span>Gradient() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gradient </td>
          <td>(</td>
          <td class="paramtype">const arma::mat &amp;&#160;</td>
          <td class="paramname"><em>transformation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GradType &amp;&#160;</td>
          <td class="paramname"><em>gradient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>batchSize</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate the gradient of the <a class="el" href="classmlpack_1_1lmnn_1_1LMNN.html" title="An implementation of Large Margin nearest neighbor metric learning technique. ">LMNN</a> function for the given transformation matrix on the given batch size, from a given initial point of the dataset. </p>
<p>This is the separable implementation, where the objective function is decomposed into the sum of many objective functions, and here, only one of those constituent objective functions is returned. The type of the gradient parameter is a template argument to allow the computation of a sparse gradient.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">GradType</td><td>The type of the gradient out-param. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transformation</td><td>Transformation matrix of Mahalanobis distance. </td></tr>
    <tr><td class="paramname">begin</td><td>Index of the initial point to use for objective function. </td></tr>
    <tr><td class="paramname">gradient</td><td>Matrix to store the calculated gradient in. </td></tr>
    <tr><td class="paramname">batchSize</td><td>Number of points to use for objective function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab749ea30c4c3d750ef3a619f32dc3e75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab749ea30c4c3d750ef3a619f32dc3e75">&#9670;&nbsp;</a></span>K() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t&amp; K </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the value of k. </p>

<p class="definition">Definition at line <a class="el" href="lmnn__function_8hpp_source.html#l00183">183</a> of file <a class="el" href="lmnn__function_8hpp_source.html">lmnn_function.hpp</a>.</p>

</div>
</div>
<a id="af80ea69c69c6463691509f509f3bff05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af80ea69c69c6463691509f509f3bff05">&#9670;&nbsp;</a></span>K() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t&amp; K </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify the value of k. </p>

<p class="definition">Definition at line <a class="el" href="lmnn__function_8hpp_source.html#l00185">185</a> of file <a class="el" href="lmnn__function_8hpp_source.html">lmnn_function.hpp</a>.</p>

</div>
</div>
<a id="a1fa76af34a6e3ea927b307f0c318ee4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fa76af34a6e3ea927b307f0c318ee4b">&#9670;&nbsp;</a></span>NumFunctions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t NumFunctions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of functions the objective function can be decomposed into. </p>
<p>This is just the number of points in the dataset. </p>

<p class="definition">Definition at line <a class="el" href="lmnn__function_8hpp_source.html#l00172">172</a> of file <a class="el" href="lmnn__function_8hpp_source.html">lmnn_function.hpp</a>.</p>

</div>
</div>
<a id="a8a26c8724520d749b483fe8dcfe7416b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a26c8724520d749b483fe8dcfe7416b">&#9670;&nbsp;</a></span>Range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t&amp; Range </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the value of range. </p>

<p class="definition">Definition at line <a class="el" href="lmnn__function_8hpp_source.html#l00188">188</a> of file <a class="el" href="lmnn__function_8hpp_source.html">lmnn_function.hpp</a>.</p>

</div>
</div>
<a id="ab2cebd1b43cb779465e7323255112bb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2cebd1b43cb779465e7323255112bb4">&#9670;&nbsp;</a></span>Range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t&amp; Range </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify the value of k. </p>

<p class="definition">Definition at line <a class="el" href="lmnn__function_8hpp_source.html#l00190">190</a> of file <a class="el" href="lmnn__function_8hpp_source.html">lmnn_function.hpp</a>.</p>

</div>
</div>
<a id="ad3a3c8f810d08e2e922b3c30e29b7f11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3a3c8f810d08e2e922b3c30e29b7f11">&#9670;&nbsp;</a></span>Regularization() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const double&amp; Regularization </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the regularization value. </p>

<p class="definition">Definition at line <a class="el" href="lmnn__function_8hpp_source.html#l00178">178</a> of file <a class="el" href="lmnn__function_8hpp_source.html">lmnn_function.hpp</a>.</p>

</div>
</div>
<a id="a9c741ac26a2c0ee8bb0fbe52534dd544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c741ac26a2c0ee8bb0fbe52534dd544">&#9670;&nbsp;</a></span>Regularization() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double&amp; Regularization </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify the regularization value. </p>

<p class="definition">Definition at line <a class="el" href="lmnn__function_8hpp_source.html#l00180">180</a> of file <a class="el" href="lmnn__function_8hpp_source.html">lmnn_function.hpp</a>.</p>

</div>
</div>
<a id="a2697cc8b37d7bca7c055228382a9b208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2697cc8b37d7bca7c055228382a9b208">&#9670;&nbsp;</a></span>Shuffle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Shuffle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shuffle the points in the dataset. </p>
<p>This may be used by optimizers. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/aakash/mlpack/src/mlpack/methods/lmnn/<a class="el" href="lmnn__function_8hpp_source.html">lmnn_function.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
<script type="text/javascript">
var x = document.querySelectorAll("img.formulaDsp");
var i;
for (i = 0; i < x.length; i++)
{
  x[i].width = x[i].offsetWidth / 4;
}
</script>
</html>
