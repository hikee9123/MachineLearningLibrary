<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>mlpack: KMeans&lt; MetricType, InitialPartitionPolicy, EmptyClusterPolicy, LloydStepType, MatType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra-stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">mlpack
   &#160;<span id="projectnumber">3.4.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlpack.html">mlpack</a></li><li class="navelem"><a class="el" href="namespacemlpack_1_1kmeans.html">kmeans</a></li><li class="navelem"><a class="el" href="classmlpack_1_1kmeans_1_1KMeans.html">KMeans</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classmlpack_1_1kmeans_1_1KMeans-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">KMeans&lt; MetricType, InitialPartitionPolicy, EmptyClusterPolicy, LloydStepType, MatType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class implements K-Means clustering, using a variety of possible implementations of Lloyd's algorithm.  
 <a href="classmlpack_1_1kmeans_1_1KMeans.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2c02f26404b56010005348a1a9c78811"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1kmeans_1_1KMeans.html#a2c02f26404b56010005348a1a9c78811">KMeans</a> (const size_t maxIterations=1000, const MetricType metric=MetricType(), const InitialPartitionPolicy partitioner=InitialPartitionPolicy(), const EmptyClusterPolicy emptyClusterAction=EmptyClusterPolicy())</td></tr>
<tr class="memdesc:a2c02f26404b56010005348a1a9c78811"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a K-Means object and (optionally) set the parameters which K-Means will be run with.  <a href="#a2c02f26404b56010005348a1a9c78811">More...</a><br /></td></tr>
<tr class="separator:a2c02f26404b56010005348a1a9c78811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6826456ef16a5d9129bdcb14d4e7b601"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1kmeans_1_1KMeans.html#a6826456ef16a5d9129bdcb14d4e7b601">Cluster</a> (const MatType &amp;data, const size_t clusters, arma::Row&lt; size_t &gt; &amp;assignments, const bool initialGuess=false)</td></tr>
<tr class="memdesc:a6826456ef16a5d9129bdcb14d4e7b601"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform k-means clustering on the data, returning a list of cluster assignments.  <a href="#a6826456ef16a5d9129bdcb14d4e7b601">More...</a><br /></td></tr>
<tr class="separator:a6826456ef16a5d9129bdcb14d4e7b601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a628f7259d908bb79c6076e6c8542bb37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1kmeans_1_1KMeans.html#a628f7259d908bb79c6076e6c8542bb37">Cluster</a> (const MatType &amp;data, size_t clusters, arma::mat &amp;centroids, const bool initialGuess=false)</td></tr>
<tr class="memdesc:a628f7259d908bb79c6076e6c8542bb37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform k-means clustering on the data, returning the centroids of each cluster in the centroids matrix.  <a href="#a628f7259d908bb79c6076e6c8542bb37">More...</a><br /></td></tr>
<tr class="separator:a628f7259d908bb79c6076e6c8542bb37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f936cca3a7f4af330fb90da9e2f4d0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1kmeans_1_1KMeans.html#a7f936cca3a7f4af330fb90da9e2f4d0b">Cluster</a> (const MatType &amp;data, const size_t clusters, arma::Row&lt; size_t &gt; &amp;assignments, arma::mat &amp;centroids, const bool initialAssignmentGuess=false, const bool initialCentroidGuess=false)</td></tr>
<tr class="memdesc:a7f936cca3a7f4af330fb90da9e2f4d0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform k-means clustering on the data, returning a list of cluster assignments and also the centroids of each cluster.  <a href="#a7f936cca3a7f4af330fb90da9e2f4d0b">More...</a><br /></td></tr>
<tr class="separator:a7f936cca3a7f4af330fb90da9e2f4d0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa48f5728e3adee070ea825c121ebe25e"><td class="memItemLeft" align="right" valign="top">const EmptyClusterPolicy &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1kmeans_1_1KMeans.html#aa48f5728e3adee070ea825c121ebe25e">EmptyClusterAction</a> () const</td></tr>
<tr class="memdesc:aa48f5728e3adee070ea825c121ebe25e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the empty cluster policy.  <a href="#aa48f5728e3adee070ea825c121ebe25e">More...</a><br /></td></tr>
<tr class="separator:aa48f5728e3adee070ea825c121ebe25e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fad56c8618d74d504739243a5acd350"><td class="memItemLeft" align="right" valign="top">EmptyClusterPolicy &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1kmeans_1_1KMeans.html#a6fad56c8618d74d504739243a5acd350">EmptyClusterAction</a> ()</td></tr>
<tr class="memdesc:a6fad56c8618d74d504739243a5acd350"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the empty cluster policy.  <a href="#a6fad56c8618d74d504739243a5acd350">More...</a><br /></td></tr>
<tr class="separator:a6fad56c8618d74d504739243a5acd350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a420770944a5b0c7a852c4ec372c4a2d1"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1kmeans_1_1KMeans.html#a420770944a5b0c7a852c4ec372c4a2d1">MaxIterations</a> () const</td></tr>
<tr class="memdesc:a420770944a5b0c7a852c4ec372c4a2d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum number of iterations.  <a href="#a420770944a5b0c7a852c4ec372c4a2d1">More...</a><br /></td></tr>
<tr class="separator:a420770944a5b0c7a852c4ec372c4a2d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acda675ab4ab86b95c92bc33bc391a61b"><td class="memItemLeft" align="right" valign="top">size_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1kmeans_1_1KMeans.html#acda675ab4ab86b95c92bc33bc391a61b">MaxIterations</a> ()</td></tr>
<tr class="memdesc:acda675ab4ab86b95c92bc33bc391a61b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum number of iterations.  <a href="#acda675ab4ab86b95c92bc33bc391a61b">More...</a><br /></td></tr>
<tr class="separator:acda675ab4ab86b95c92bc33bc391a61b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac4d643c62af7d9cc2a072aea10d2b32"><td class="memItemLeft" align="right" valign="top">const MetricType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1kmeans_1_1KMeans.html#aac4d643c62af7d9cc2a072aea10d2b32">Metric</a> () const</td></tr>
<tr class="memdesc:aac4d643c62af7d9cc2a072aea10d2b32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the distance metric.  <a href="#aac4d643c62af7d9cc2a072aea10d2b32">More...</a><br /></td></tr>
<tr class="separator:aac4d643c62af7d9cc2a072aea10d2b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc71d930ed90e73b2bc0c360835c5371"><td class="memItemLeft" align="right" valign="top">MetricType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1kmeans_1_1KMeans.html#acc71d930ed90e73b2bc0c360835c5371">Metric</a> ()</td></tr>
<tr class="memdesc:acc71d930ed90e73b2bc0c360835c5371"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the distance metric.  <a href="#acc71d930ed90e73b2bc0c360835c5371">More...</a><br /></td></tr>
<tr class="separator:acc71d930ed90e73b2bc0c360835c5371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e66bff389c56384db8677109a05eb8b"><td class="memItemLeft" align="right" valign="top">const InitialPartitionPolicy &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1kmeans_1_1KMeans.html#a7e66bff389c56384db8677109a05eb8b">Partitioner</a> () const</td></tr>
<tr class="memdesc:a7e66bff389c56384db8677109a05eb8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the initial partitioning policy.  <a href="#a7e66bff389c56384db8677109a05eb8b">More...</a><br /></td></tr>
<tr class="separator:a7e66bff389c56384db8677109a05eb8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4312395900bd208fb8f63c8d0a6f7c6c"><td class="memItemLeft" align="right" valign="top">InitialPartitionPolicy &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1kmeans_1_1KMeans.html#a4312395900bd208fb8f63c8d0a6f7c6c">Partitioner</a> ()</td></tr>
<tr class="memdesc:a4312395900bd208fb8f63c8d0a6f7c6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the initial partitioning policy.  <a href="#a4312395900bd208fb8f63c8d0a6f7c6c">More...</a><br /></td></tr>
<tr class="separator:a4312395900bd208fb8f63c8d0a6f7c6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72d63b74c8166dff8e1a9006905ad9ca"><td class="memTemplParams" colspan="2">template&lt;typename Archive &gt; </td></tr>
<tr class="memitem:a72d63b74c8166dff8e1a9006905ad9ca"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlpack_1_1kmeans_1_1KMeans.html#a72d63b74c8166dff8e1a9006905ad9ca">serialize</a> (Archive &amp;ar, const uint32_t version)</td></tr>
<tr class="memdesc:a72d63b74c8166dff8e1a9006905ad9ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize the k-means object.  <a href="#a72d63b74c8166dff8e1a9006905ad9ca">More...</a><br /></td></tr>
<tr class="separator:a72d63b74c8166dff8e1a9006905ad9ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename MetricType = metric::EuclideanDistance, typename InitialPartitionPolicy = SampleInitialization, typename EmptyClusterPolicy = MaxVarianceNewCluster, template&lt; class, class &gt; class LloydStepType = NaiveKMeans, typename MatType = arma::mat&gt;<br />
class mlpack::kmeans::KMeans&lt; MetricType, InitialPartitionPolicy, EmptyClusterPolicy, LloydStepType, MatType &gt;</h3>

<p>This class implements K-Means clustering, using a variety of possible implementations of Lloyd's algorithm. </p>
<p>Four template parameters can (optionally) be supplied: the distance metric to use, the policy for how to find the initial partition of the data, the actions to be taken when an empty cluster is encountered, and the implementation of a single Lloyd step to use.</p>
<p>A simple example of how to run K-Means clustering is shown below.</p>
<div class="fragment"><div class="line"><span class="keyword">extern</span> arma::mat data; <span class="comment">// Dataset we want to run K-Means on.</span></div><div class="line">arma::Row&lt;size_t&gt; assignments; <span class="comment">// Cluster assignments.</span></div><div class="line">arma::mat centroids; <span class="comment">// Cluster centroids.</span></div><div class="line"></div><div class="line">KMeans&lt;&gt; k; <span class="comment">// Default options.</span></div><div class="line">k.Cluster(data, 3, assignments, centroids); <span class="comment">// 3 clusters.</span></div><div class="line"></div><div class="line"><span class="comment">// Cluster using the Manhattan distance, 100 iterations maximum, saving only</span></div><div class="line"><span class="comment">// the centroids.</span></div><div class="line">KMeans&lt;metric::ManhattanDistance&gt; k(100);</div><div class="line">k.Cluster(data, 6, centroids); <span class="comment">// 6 clusters.</span></div></div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MetricType</td><td>The distance metric to use for this <a class="el" href="classmlpack_1_1kmeans_1_1KMeans.html" title="This class implements K-Means clustering, using a variety of possible implementations of Lloyd&#39;s algo...">KMeans</a>; see <a class="el" href="classmlpack_1_1metric_1_1LMetric.html" title="The L_p metric for arbitrary integer p, with an option to take the root. ">metric::LMetric</a> for an example. </td></tr>
    <tr><td class="paramname">InitialPartitionPolicy</td><td>Initial partitioning policy; must implement a default constructor and either 'void Cluster(const arma::mat&amp;, const size_t, arma::Row&lt;size_t&gt;&amp;)' or 'void Cluster(const arma::mat&amp;, const size_t, arma::mat&amp;)'. </td></tr>
    <tr><td class="paramname">EmptyClusterPolicy</td><td>Policy for what to do on an empty cluster; must implement a default constructor and 'void EmptyCluster(const arma::mat&amp; data, const size_t emptyCluster, const arma::mat&amp; oldCentroids, arma::mat&amp; newCentroids, arma::Col&lt;size_t&gt;&amp; counts, MetricType&amp; metric, const size_t iteration)'. </td></tr>
    <tr><td class="paramname">LloydStepType</td><td>Implementation of single Lloyd step to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classmlpack_1_1kmeans_1_1RandomPartition.html" title="A very simple partitioner which partitions the data randomly into the number of desired clusters...">RandomPartition</a>, <a class="el" href="classmlpack_1_1kmeans_1_1SampleInitialization.html">SampleInitialization</a>, <a class="el" href="classmlpack_1_1kmeans_1_1RefinedStart.html" title="A refined approach for choosing initial points for k-means clustering. ">RefinedStart</a>, AllowEmptyClusters, <a class="el" href="classmlpack_1_1kmeans_1_1MaxVarianceNewCluster.html" title="When an empty cluster is detected, this class takes the point furthest from the centroid of the clust...">MaxVarianceNewCluster</a>, <a class="el" href="classmlpack_1_1kmeans_1_1NaiveKMeans.html" title="This is an implementation of a single iteration of Lloyd&#39;s algorithm for k-means. ...">NaiveKMeans</a>, <a class="el" href="classmlpack_1_1kmeans_1_1ElkanKMeans.html">ElkanKMeans</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="kmeans_8hpp_source.html#l00073">73</a> of file <a class="el" href="kmeans_8hpp_source.html">kmeans.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2c02f26404b56010005348a1a9c78811"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c02f26404b56010005348a1a9c78811">&#9670;&nbsp;</a></span>KMeans()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1kmeans_1_1KMeans.html">KMeans</a> </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>maxIterations</em> = <code>1000</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MetricType&#160;</td>
          <td class="paramname"><em>metric</em> = <code>MetricType()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InitialPartitionPolicy&#160;</td>
          <td class="paramname"><em>partitioner</em> = <code>InitialPartitionPolicy()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EmptyClusterPolicy&#160;</td>
          <td class="paramname"><em>emptyClusterAction</em> = <code>EmptyClusterPolicy()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a K-Means object and (optionally) set the parameters which K-Means will be run with. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxIterations</td><td>Maximum number of iterations allowed before giving up (0 is valid, but the algorithm may never terminate). </td></tr>
    <tr><td class="paramname">metric</td><td>Optional MetricType object; for when the metric has state it needs to store. </td></tr>
    <tr><td class="paramname">partitioner</td><td>Optional InitialPartitionPolicy object; for when a specially initialized partitioning policy is required. </td></tr>
    <tr><td class="paramname">emptyClusterAction</td><td>Optional EmptyClusterPolicy object; for when a specially initialized empty cluster policy is required. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6826456ef16a5d9129bdcb14d4e7b601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6826456ef16a5d9129bdcb14d4e7b601">&#9670;&nbsp;</a></span>Cluster() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cluster </td>
          <td>(</td>
          <td class="paramtype">const MatType &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>clusters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::Row&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>assignments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>initialGuess</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform k-means clustering on the data, returning a list of cluster assignments. </p>
<p>Optionally, the vector of assignments can be set to an initial guess of the cluster assignments; to do this, set initialGuess to true.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatType</td><td>Type of matrix (arma::mat or arma::sp_mat). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Dataset to cluster. </td></tr>
    <tr><td class="paramname">clusters</td><td>Number of clusters to compute. </td></tr>
    <tr><td class="paramname">assignments</td><td>Vector to store cluster assignments in. </td></tr>
    <tr><td class="paramname">initialGuess</td><td>If true, then it is assumed that assignments has a list of initial cluster assignments. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a628f7259d908bb79c6076e6c8542bb37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a628f7259d908bb79c6076e6c8542bb37">&#9670;&nbsp;</a></span>Cluster() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cluster </td>
          <td>(</td>
          <td class="paramtype">const MatType &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>clusters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::mat &amp;&#160;</td>
          <td class="paramname"><em>centroids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>initialGuess</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform k-means clustering on the data, returning the centroids of each cluster in the centroids matrix. </p>
<p>Optionally, the initial centroids can be specified by filling the centroids matrix with the initial centroids and specifying initialGuess = true.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatType</td><td>Type of matrix (arma::mat or arma::sp_mat). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Dataset to cluster. </td></tr>
    <tr><td class="paramname">clusters</td><td>Number of clusters to compute. </td></tr>
    <tr><td class="paramname">centroids</td><td>Matrix in which centroids are stored. </td></tr>
    <tr><td class="paramname">initialGuess</td><td>If true, then it is assumed that centroids contains the initial cluster centroids. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7f936cca3a7f4af330fb90da9e2f4d0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f936cca3a7f4af330fb90da9e2f4d0b">&#9670;&nbsp;</a></span>Cluster() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cluster </td>
          <td>(</td>
          <td class="paramtype">const MatType &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>clusters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::Row&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>assignments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::mat &amp;&#160;</td>
          <td class="paramname"><em>centroids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>initialAssignmentGuess</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>initialCentroidGuess</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform k-means clustering on the data, returning a list of cluster assignments and also the centroids of each cluster. </p>
<p>Optionally, the vector of assignments can be set to an initial guess of the cluster assignments; to do this, set initialAssignmentGuess to true. Another way to set initial cluster guesses is to fill the centroids matrix with the centroid guesses, and then set initialCentroidGuess to true. initialAssignmentGuess supersedes initialCentroidGuess, so if both are set to true, the assignments vector is used.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatType</td><td>Type of matrix (arma::mat or arma::sp_mat). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Dataset to cluster. </td></tr>
    <tr><td class="paramname">clusters</td><td>Number of clusters to compute. </td></tr>
    <tr><td class="paramname">assignments</td><td>Vector to store cluster assignments in. </td></tr>
    <tr><td class="paramname">centroids</td><td>Matrix in which centroids are stored. </td></tr>
    <tr><td class="paramname">initialAssignmentGuess</td><td>If true, then it is assumed that assignments has a list of initial cluster assignments. </td></tr>
    <tr><td class="paramname">initialCentroidGuess</td><td>If true, then it is assumed that centroids contains the initial centroids of each cluster. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa48f5728e3adee070ea825c121ebe25e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa48f5728e3adee070ea825c121ebe25e">&#9670;&nbsp;</a></span>EmptyClusterAction() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const EmptyClusterPolicy&amp; EmptyClusterAction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the empty cluster policy. </p>

<p class="definition">Definition at line <a class="el" href="kmeans_8hpp_source.html#l00174">174</a> of file <a class="el" href="kmeans_8hpp_source.html">kmeans.hpp</a>.</p>

</div>
</div>
<a id="a6fad56c8618d74d504739243a5acd350"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fad56c8618d74d504739243a5acd350">&#9670;&nbsp;</a></span>EmptyClusterAction() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EmptyClusterPolicy&amp; EmptyClusterAction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify the empty cluster policy. </p>

<p class="definition">Definition at line <a class="el" href="kmeans_8hpp_source.html#l00177">177</a> of file <a class="el" href="kmeans_8hpp_source.html">kmeans.hpp</a>.</p>

<p class="reference">References <a class="el" href="classmlpack_1_1kmeans_1_1KMeans.html#a72d63b74c8166dff8e1a9006905ad9ca">KMeans&lt; MetricType, InitialPartitionPolicy, EmptyClusterPolicy, LloydStepType, MatType &gt;::serialize()</a>.</p>

</div>
</div>
<a id="a420770944a5b0c7a852c4ec372c4a2d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a420770944a5b0c7a852c4ec372c4a2d1">&#9670;&nbsp;</a></span>MaxIterations() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t MaxIterations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the maximum number of iterations. </p>

<p class="definition">Definition at line <a class="el" href="kmeans_8hpp_source.html#l00159">159</a> of file <a class="el" href="kmeans_8hpp_source.html">kmeans.hpp</a>.</p>

</div>
</div>
<a id="acda675ab4ab86b95c92bc33bc391a61b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acda675ab4ab86b95c92bc33bc391a61b">&#9670;&nbsp;</a></span>MaxIterations() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t&amp; MaxIterations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the maximum number of iterations. </p>

<p class="definition">Definition at line <a class="el" href="kmeans_8hpp_source.html#l00161">161</a> of file <a class="el" href="kmeans_8hpp_source.html">kmeans.hpp</a>.</p>

</div>
</div>
<a id="aac4d643c62af7d9cc2a072aea10d2b32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac4d643c62af7d9cc2a072aea10d2b32">&#9670;&nbsp;</a></span>Metric() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const MetricType&amp; Metric </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the distance metric. </p>

<p class="definition">Definition at line <a class="el" href="kmeans_8hpp_source.html#l00164">164</a> of file <a class="el" href="kmeans_8hpp_source.html">kmeans.hpp</a>.</p>

</div>
</div>
<a id="acc71d930ed90e73b2bc0c360835c5371"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc71d930ed90e73b2bc0c360835c5371">&#9670;&nbsp;</a></span>Metric() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MetricType&amp; Metric </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify the distance metric. </p>

<p class="definition">Definition at line <a class="el" href="kmeans_8hpp_source.html#l00166">166</a> of file <a class="el" href="kmeans_8hpp_source.html">kmeans.hpp</a>.</p>

</div>
</div>
<a id="a7e66bff389c56384db8677109a05eb8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e66bff389c56384db8677109a05eb8b">&#9670;&nbsp;</a></span>Partitioner() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const InitialPartitionPolicy&amp; Partitioner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the initial partitioning policy. </p>

<p class="definition">Definition at line <a class="el" href="kmeans_8hpp_source.html#l00169">169</a> of file <a class="el" href="kmeans_8hpp_source.html">kmeans.hpp</a>.</p>

</div>
</div>
<a id="a4312395900bd208fb8f63c8d0a6f7c6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4312395900bd208fb8f63c8d0a6f7c6c">&#9670;&nbsp;</a></span>Partitioner() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">InitialPartitionPolicy&amp; Partitioner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify the initial partitioning policy. </p>

<p class="definition">Definition at line <a class="el" href="kmeans_8hpp_source.html#l00171">171</a> of file <a class="el" href="kmeans_8hpp_source.html">kmeans.hpp</a>.</p>

</div>
</div>
<a id="a72d63b74c8166dff8e1a9006905ad9ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72d63b74c8166dff8e1a9006905ad9ca">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serialize the k-means object. </p>

<p class="reference">Referenced by <a class="el" href="kmeans_8hpp_source.html#l00177">KMeans&lt; MetricType, InitialPartitionPolicy, EmptyClusterPolicy, LloydStepType, MatType &gt;::EmptyClusterAction()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/aakash/mlpack/src/mlpack/methods/kmeans/<a class="el" href="kmeans_8hpp_source.html">kmeans.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
<script type="text/javascript">
var x = document.querySelectorAll("img.formulaDsp");
var i;
for (i = 0; i < x.length; i++)
{
  x[i].width = x[i].offsetWidth / 4;
}
</script>
</html>
