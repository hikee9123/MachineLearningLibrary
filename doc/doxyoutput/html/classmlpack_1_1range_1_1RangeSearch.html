<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>mlpack: RangeSearch&lt; MetricType, MatType, TreeType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra-stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">mlpack
   &#160;<span id="projectnumber">3.4.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlpack.html">mlpack</a></li><li class="navelem"><a class="el" href="namespacemlpack_1_1range.html">range</a></li><li class="navelem"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">RangeSearch</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classmlpack_1_1range_1_1RangeSearch-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">RangeSearch&lt; MetricType, MatType, TreeType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html" title="The RangeSearch class is a template class for performing range searches. ">RangeSearch</a> class is a template class for performing range searches.  
 <a href="classmlpack_1_1range_1_1RangeSearch.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for RangeSearch&lt; MetricType, MatType, TreeType &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classmlpack_1_1range_1_1RangeSearch__inherit__graph.png" border="0" usemap="#RangeSearch_3_01MetricType_00_01MatType_00_01TreeType_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="RangeSearch_3_01MetricType_00_01MatType_00_01TreeType_01_4_inherit__map" id="RangeSearch_3_01MetricType_00_01MatType_00_01TreeType_01_4_inherit__map">
<area shape="rect" id="node2" href="classmlpack_1_1range_1_1RangeSearch.html" title="RangeSearch\&lt; metric\l::EuclideanDistance,\l arma::mat, TreeType \&gt;" alt="" coords="17,124,177,180"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a5cbbe0e3dd87208f402ebd5a35dcd608"><td class="memItemLeft" align="right" valign="top">typedef TreeType&lt; MetricType, <a class="el" href="classmlpack_1_1range_1_1RangeSearchStat.html">RangeSearchStat</a>, MatType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a5cbbe0e3dd87208f402ebd5a35dcd608">Tree</a></td></tr>
<tr class="memdesc:a5cbbe0e3dd87208f402ebd5a35dcd608"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience typedef.  <a href="#a5cbbe0e3dd87208f402ebd5a35dcd608">More...</a><br /></td></tr>
<tr class="separator:a5cbbe0e3dd87208f402ebd5a35dcd608"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9292d974d50191623b9f26d7f2ccea1d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a9292d974d50191623b9f26d7f2ccea1d">RangeSearch</a> (MatType referenceSet, const bool naive=false, const bool singleMode=false, const MetricType metric=MetricType())</td></tr>
<tr class="memdesc:a9292d974d50191623b9f26d7f2ccea1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html" title="The RangeSearch class is a template class for performing range searches. ">RangeSearch</a> object with a given reference dataset (this is the dataset which is searched).  <a href="#a9292d974d50191623b9f26d7f2ccea1d">More...</a><br /></td></tr>
<tr class="separator:a9292d974d50191623b9f26d7f2ccea1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d201f3cf484ea56a37daabeb0cded94"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a6d201f3cf484ea56a37daabeb0cded94">RangeSearch</a> (<a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a5cbbe0e3dd87208f402ebd5a35dcd608">Tree</a> *referenceTree, const bool singleMode=false, const MetricType metric=MetricType())</td></tr>
<tr class="memdesc:a6d201f3cf484ea56a37daabeb0cded94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html" title="The RangeSearch class is a template class for performing range searches. ">RangeSearch</a> object with the given pre-constructed reference tree (this is the tree built on the reference set, which is the set that is searched).  <a href="#a6d201f3cf484ea56a37daabeb0cded94">More...</a><br /></td></tr>
<tr class="separator:a6d201f3cf484ea56a37daabeb0cded94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a838592644923cb86943f789ca0522bd1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a838592644923cb86943f789ca0522bd1">RangeSearch</a> (const bool naive=false, const bool singleMode=false, const MetricType metric=MetricType())</td></tr>
<tr class="memdesc:a838592644923cb86943f789ca0522bd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html" title="The RangeSearch class is a template class for performing range searches. ">RangeSearch</a> object without any reference data.  <a href="#a838592644923cb86943f789ca0522bd1">More...</a><br /></td></tr>
<tr class="separator:a838592644923cb86943f789ca0522bd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af751a5f912b2f3eb714567b6b6ca7c2d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#af751a5f912b2f3eb714567b6b6ca7c2d">RangeSearch</a> (const <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">RangeSearch</a> &amp;other)</td></tr>
<tr class="memdesc:af751a5f912b2f3eb714567b6b6ca7c2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html" title="The RangeSearch class is a template class for performing range searches. ">RangeSearch</a> model as a copy of the given model.  <a href="#af751a5f912b2f3eb714567b6b6ca7c2d">More...</a><br /></td></tr>
<tr class="separator:af751a5f912b2f3eb714567b6b6ca7c2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb192154ad7a75d89fcc6dbb6ffc1f24"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#aeb192154ad7a75d89fcc6dbb6ffc1f24">RangeSearch</a> (<a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">RangeSearch</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:aeb192154ad7a75d89fcc6dbb6ffc1f24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html" title="The RangeSearch class is a template class for performing range searches. ">RangeSearch</a> model by taking ownership of the given model.  <a href="#aeb192154ad7a75d89fcc6dbb6ffc1f24">More...</a><br /></td></tr>
<tr class="separator:aeb192154ad7a75d89fcc6dbb6ffc1f24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a250641479dfc9c4881bdae8c960f767f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a250641479dfc9c4881bdae8c960f767f">~RangeSearch</a> ()</td></tr>
<tr class="memdesc:a250641479dfc9c4881bdae8c960f767f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html" title="The RangeSearch class is a template class for performing range searches. ">RangeSearch</a> object.  <a href="#a250641479dfc9c4881bdae8c960f767f">More...</a><br /></td></tr>
<tr class="separator:a250641479dfc9c4881bdae8c960f767f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f4bd5d0aa64ea090796725f7755287d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a3f4bd5d0aa64ea090796725f7755287d">BaseCases</a> () const</td></tr>
<tr class="memdesc:a3f4bd5d0aa64ea090796725f7755287d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of base cases during the last search.  <a href="#a3f4bd5d0aa64ea090796725f7755287d">More...</a><br /></td></tr>
<tr class="separator:a3f4bd5d0aa64ea090796725f7755287d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a343230e7d7344e3f7d5f5f2eb89cf2c5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a343230e7d7344e3f7d5f5f2eb89cf2c5">Naive</a> () const</td></tr>
<tr class="memdesc:a343230e7d7344e3f7d5f5f2eb89cf2c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get whether naive search is being used.  <a href="#a343230e7d7344e3f7d5f5f2eb89cf2c5">More...</a><br /></td></tr>
<tr class="separator:a343230e7d7344e3f7d5f5f2eb89cf2c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7d397adca3f411b4e2d2f977b280ce6"><td class="memItemLeft" align="right" valign="top">bool &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#af7d397adca3f411b4e2d2f977b280ce6">Naive</a> ()</td></tr>
<tr class="memdesc:af7d397adca3f411b4e2d2f977b280ce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify whether naive search is being used.  <a href="#af7d397adca3f411b4e2d2f977b280ce6">More...</a><br /></td></tr>
<tr class="separator:af7d397adca3f411b4e2d2f977b280ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b0922f9fb5439cf21e6873f8a9a84b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">RangeSearch</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a9b0922f9fb5439cf21e6873f8a9a84b5">operator=</a> (const <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">RangeSearch</a> &amp;other)</td></tr>
<tr class="memdesc:a9b0922f9fb5439cf21e6873f8a9a84b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deep copy the given <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html" title="The RangeSearch class is a template class for performing range searches. ">RangeSearch</a> model.  <a href="#a9b0922f9fb5439cf21e6873f8a9a84b5">More...</a><br /></td></tr>
<tr class="separator:a9b0922f9fb5439cf21e6873f8a9a84b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c57ee3bbf6708990e6432d0962e2226"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">RangeSearch</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a2c57ee3bbf6708990e6432d0962e2226">operator=</a> (<a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">RangeSearch</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:a2c57ee3bbf6708990e6432d0962e2226"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move the given <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html" title="The RangeSearch class is a template class for performing range searches. ">RangeSearch</a> model.  <a href="#a2c57ee3bbf6708990e6432d0962e2226">More...</a><br /></td></tr>
<tr class="separator:a2c57ee3bbf6708990e6432d0962e2226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a975940b302b4efec85bbe2d8b36251"><td class="memItemLeft" align="right" valign="top">const MatType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a0a975940b302b4efec85bbe2d8b36251">ReferenceSet</a> () const</td></tr>
<tr class="memdesc:a0a975940b302b4efec85bbe2d8b36251"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the reference set.  <a href="#a0a975940b302b4efec85bbe2d8b36251">More...</a><br /></td></tr>
<tr class="separator:a0a975940b302b4efec85bbe2d8b36251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92cb2297c084f56afea6f37e3c894f52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a5cbbe0e3dd87208f402ebd5a35dcd608">Tree</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a92cb2297c084f56afea6f37e3c894f52">ReferenceTree</a> ()</td></tr>
<tr class="memdesc:a92cb2297c084f56afea6f37e3c894f52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the reference tree (or NULL if in naive mode).  <a href="#a92cb2297c084f56afea6f37e3c894f52">More...</a><br /></td></tr>
<tr class="separator:a92cb2297c084f56afea6f37e3c894f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d1e40c0bf406280a237ca1b487e3c62"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a4d1e40c0bf406280a237ca1b487e3c62">Scores</a> () const</td></tr>
<tr class="memdesc:a4d1e40c0bf406280a237ca1b487e3c62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of scores during the last search.  <a href="#a4d1e40c0bf406280a237ca1b487e3c62">More...</a><br /></td></tr>
<tr class="separator:a4d1e40c0bf406280a237ca1b487e3c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0df148abcabf67c5876e942e12279f8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a0df148abcabf67c5876e942e12279f8e">Search</a> (const MatType &amp;querySet, const math::Range &amp;range, std::vector&lt; std::vector&lt; size_t &gt;&gt; &amp;neighbors, std::vector&lt; std::vector&lt; double &gt;&gt; &amp;distances)</td></tr>
<tr class="memdesc:a0df148abcabf67c5876e942e12279f8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for all reference points in the given range for each point in the query set, returning the results in the neighbors and distances objects.  <a href="#a0df148abcabf67c5876e942e12279f8e">More...</a><br /></td></tr>
<tr class="separator:a0df148abcabf67c5876e942e12279f8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24f0beece99aedbee1edf5890f5bc235"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a24f0beece99aedbee1edf5890f5bc235">Search</a> (<a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a5cbbe0e3dd87208f402ebd5a35dcd608">Tree</a> *queryTree, const math::Range &amp;range, std::vector&lt; std::vector&lt; size_t &gt;&gt; &amp;neighbors, std::vector&lt; std::vector&lt; double &gt;&gt; &amp;distances)</td></tr>
<tr class="memdesc:a24f0beece99aedbee1edf5890f5bc235"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a pre-built query tree, search for all reference points in the given range for each point in the query set, returning the results in the neighbors and distances objects.  <a href="#a24f0beece99aedbee1edf5890f5bc235">More...</a><br /></td></tr>
<tr class="separator:a24f0beece99aedbee1edf5890f5bc235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3868480bcd41a740550657144b5f7018"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a3868480bcd41a740550657144b5f7018">Search</a> (const math::Range &amp;range, std::vector&lt; std::vector&lt; size_t &gt;&gt; &amp;neighbors, std::vector&lt; std::vector&lt; double &gt;&gt; &amp;distances)</td></tr>
<tr class="memdesc:a3868480bcd41a740550657144b5f7018"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for all points in the given range for each point in the reference set (which was passed to the constructor), returning the results in the neighbors and distances objects.  <a href="#a3868480bcd41a740550657144b5f7018">More...</a><br /></td></tr>
<tr class="separator:a3868480bcd41a740550657144b5f7018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72d63b74c8166dff8e1a9006905ad9ca"><td class="memTemplParams" colspan="2">template&lt;typename Archive &gt; </td></tr>
<tr class="memitem:a72d63b74c8166dff8e1a9006905ad9ca"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a72d63b74c8166dff8e1a9006905ad9ca">serialize</a> (Archive &amp;ar, const uint32_t version)</td></tr>
<tr class="memdesc:a72d63b74c8166dff8e1a9006905ad9ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize the model.  <a href="#a72d63b74c8166dff8e1a9006905ad9ca">More...</a><br /></td></tr>
<tr class="separator:a72d63b74c8166dff8e1a9006905ad9ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7477b3e8499a6158bbe177e7f30d4947"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a7477b3e8499a6158bbe177e7f30d4947">SingleMode</a> () const</td></tr>
<tr class="memdesc:a7477b3e8499a6158bbe177e7f30d4947"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get whether single-tree search is being used.  <a href="#a7477b3e8499a6158bbe177e7f30d4947">More...</a><br /></td></tr>
<tr class="separator:a7477b3e8499a6158bbe177e7f30d4947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adadacd63ddeadf138d834b1fdc632773"><td class="memItemLeft" align="right" valign="top">bool &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#adadacd63ddeadf138d834b1fdc632773">SingleMode</a> ()</td></tr>
<tr class="memdesc:adadacd63ddeadf138d834b1fdc632773"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify whether single-tree search is being used.  <a href="#adadacd63ddeadf138d834b1fdc632773">More...</a><br /></td></tr>
<tr class="separator:adadacd63ddeadf138d834b1fdc632773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27ba39af83e3cb01f2e6fbec159adf0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a27ba39af83e3cb01f2e6fbec159adf0e">Train</a> (MatType referenceSet)</td></tr>
<tr class="memdesc:a27ba39af83e3cb01f2e6fbec159adf0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the reference set to a new reference set, and build a tree if necessary.  <a href="#a27ba39af83e3cb01f2e6fbec159adf0e">More...</a><br /></td></tr>
<tr class="separator:a27ba39af83e3cb01f2e6fbec159adf0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d1133fe6bda66e7143fd7aab27cbd04"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a3d1133fe6bda66e7143fd7aab27cbd04">Train</a> (<a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a5cbbe0e3dd87208f402ebd5a35dcd608">Tree</a> *referenceTree)</td></tr>
<tr class="memdesc:a3d1133fe6bda66e7143fd7aab27cbd04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the reference tree to a new reference tree.  <a href="#a3d1133fe6bda66e7143fd7aab27cbd04">More...</a><br /></td></tr>
<tr class="separator:a3d1133fe6bda66e7143fd7aab27cbd04"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template&lt; typename TreeMetricType, typename TreeStatType, typename TreeMatType &gt; class TreeType = tree::KDTree&gt;<br />
class mlpack::range::RangeSearch&lt; MetricType, MatType, TreeType &gt;</h3>

<p>The <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html" title="The RangeSearch class is a template class for performing range searches. ">RangeSearch</a> class is a template class for performing range searches. </p>
<p>It is implemented in the style of a generalized tree-independent dual-tree algorithm; for more details on the actual algorithm, see the <a class="el" href="classmlpack_1_1range_1_1RangeSearchRules.html" title="The RangeSearchRules class is a template helper class used by RangeSearch class when performing range...">RangeSearchRules</a> class.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MetricType</td><td>Metric to use for range search calculations. </td></tr>
    <tr><td class="paramname">MatType</td><td>Type of data to use. </td></tr>
    <tr><td class="paramname">TreeType</td><td>Type of tree to use; must satisfy the TreeType policy API. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="range__search_8hpp_source.html#l00045">45</a> of file <a class="el" href="range__search_8hpp_source.html">range_search.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a5cbbe0e3dd87208f402ebd5a35dcd608"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cbbe0e3dd87208f402ebd5a35dcd608">&#9670;&nbsp;</a></span>Tree</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef TreeType&lt;MetricType, <a class="el" href="classmlpack_1_1range_1_1RangeSearchStat.html">RangeSearchStat</a>, MatType&gt; <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a5cbbe0e3dd87208f402ebd5a35dcd608">Tree</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience typedef. </p>

<p class="definition">Definition at line <a class="el" href="range__search_8hpp_source.html#l00049">49</a> of file <a class="el" href="range__search_8hpp_source.html">range_search.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9292d974d50191623b9f26d7f2ccea1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9292d974d50191623b9f26d7f2ccea1d">&#9670;&nbsp;</a></span>RangeSearch() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">RangeSearch</a> </td>
          <td>(</td>
          <td class="paramtype">MatType&#160;</td>
          <td class="paramname"><em>referenceSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>naive</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>singleMode</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MetricType&#160;</td>
          <td class="paramname"><em>metric</em> = <code>MetricType()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html" title="The RangeSearch class is a template class for performing range searches. ">RangeSearch</a> object with a given reference dataset (this is the dataset which is searched). </p>
<p>Optionally, perform the computation in naive mode or single-tree mode. Additionally, an instantiated metric can be given, for cases where the distance metric holds data.</p>
<p>This method will move the matrices to internal copies, which are rearranged during tree-building. You can avoid creating an extra copy by pre-constructing the trees and passing them in using std::move.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">referenceSet</td><td>Reference dataset. </td></tr>
    <tr><td class="paramname">naive</td><td>Whether the computation should be done in O(n^2) naive mode. </td></tr>
    <tr><td class="paramname">singleMode</td><td>Whether single-tree computation should be used (as opposed to dual-tree computation). </td></tr>
    <tr><td class="paramname">metric</td><td>Instantiated distance metric. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6d201f3cf484ea56a37daabeb0cded94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d201f3cf484ea56a37daabeb0cded94">&#9670;&nbsp;</a></span>RangeSearch() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">RangeSearch</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a5cbbe0e3dd87208f402ebd5a35dcd608">Tree</a> *&#160;</td>
          <td class="paramname"><em>referenceTree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>singleMode</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MetricType&#160;</td>
          <td class="paramname"><em>metric</em> = <code>MetricType()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html" title="The RangeSearch class is a template class for performing range searches. ">RangeSearch</a> object with the given pre-constructed reference tree (this is the tree built on the reference set, which is the set that is searched). </p>
<p>Optionally, choose to use single-tree mode, which will not build a tree on query points. Naive mode is not available as an option for this constructor. Additionally, an instantiated distance metric can be given, for cases where the distance metric holds data.</p>
<p>There is no copying of the data matrices in this constructor (because tree-building is not necessary), so this is the constructor to use when copies absolutely must be avoided.</p>
<dl class="section note"><dt>Note</dt><dd>Because tree-building (at least with BinarySpaceTree) modifies the ordering of a matrix, be aware that mapping of the points back to their original indices is not done when this constructor is used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">referenceTree</td><td>Pre-built tree for reference points. </td></tr>
    <tr><td class="paramname">singleMode</td><td>Whether single-tree computation should be used (as opposed to dual-tree computation). </td></tr>
    <tr><td class="paramname">metric</td><td>Instantiated distance metric. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a838592644923cb86943f789ca0522bd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a838592644923cb86943f789ca0522bd1">&#9670;&nbsp;</a></span>RangeSearch() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">RangeSearch</a> </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>naive</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>singleMode</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MetricType&#160;</td>
          <td class="paramname"><em>metric</em> = <code>MetricType()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html" title="The RangeSearch class is a template class for performing range searches. ">RangeSearch</a> object without any reference data. </p>
<p>If the monochromatic <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a0df148abcabf67c5876e942e12279f8e" title="Search for all reference points in the given range for each point in the query set, returning the results in the neighbors and distances objects. ">Search()</a> is called before a reference set is set with <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a27ba39af83e3cb01f2e6fbec159adf0e" title="Set the reference set to a new reference set, and build a tree if necessary. ">Train()</a>, no results will be returned (since the reference set is empty).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">naive</td><td>Whether to use naive search. </td></tr>
    <tr><td class="paramname">singleMode</td><td>Whether single-tree computation should be used (as opposed to dual-tree computation). </td></tr>
    <tr><td class="paramname">metric</td><td>Instantiated metric. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af751a5f912b2f3eb714567b6b6ca7c2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af751a5f912b2f3eb714567b6b6ca7c2d">&#9670;&nbsp;</a></span>RangeSearch() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">RangeSearch</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">RangeSearch</a>&lt; MetricType, MatType, TreeType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html" title="The RangeSearch class is a template class for performing range searches. ">RangeSearch</a> model as a copy of the given model. </p>
<p>Note that this may be computationally intensive!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html" title="The RangeSearch class is a template class for performing range searches. ">RangeSearch</a> model to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeb192154ad7a75d89fcc6dbb6ffc1f24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb192154ad7a75d89fcc6dbb6ffc1f24">&#9670;&nbsp;</a></span>RangeSearch() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">RangeSearch</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">RangeSearch</a>&lt; MetricType, MatType, TreeType &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html" title="The RangeSearch class is a template class for performing range searches. ">RangeSearch</a> model by taking ownership of the given model. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html" title="The RangeSearch class is a template class for performing range searches. ">RangeSearch</a> model to take ownership of. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a250641479dfc9c4881bdae8c960f767f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a250641479dfc9c4881bdae8c960f767f">&#9670;&nbsp;</a></span>~RangeSearch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">RangeSearch</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy the <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html" title="The RangeSearch class is a template class for performing range searches. ">RangeSearch</a> object. </p>
<p>If trees were created, they will be deleted. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3f4bd5d0aa64ea090796725f7755287d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f4bd5d0aa64ea090796725f7755287d">&#9670;&nbsp;</a></span>BaseCases()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t BaseCases </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of base cases during the last search. </p>

<p class="definition">Definition at line <a class="el" href="range__search_8hpp_source.html#l00282">282</a> of file <a class="el" href="range__search_8hpp_source.html">range_search.hpp</a>.</p>

</div>
</div>
<a id="a343230e7d7344e3f7d5f5f2eb89cf2c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a343230e7d7344e3f7d5f5f2eb89cf2c5">&#9670;&nbsp;</a></span>Naive() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Naive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get whether naive search is being used. </p>

<p class="definition">Definition at line <a class="el" href="range__search_8hpp_source.html#l00277">277</a> of file <a class="el" href="range__search_8hpp_source.html">range_search.hpp</a>.</p>

</div>
</div>
<a id="af7d397adca3f411b4e2d2f977b280ce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7d397adca3f411b4e2d2f977b280ce6">&#9670;&nbsp;</a></span>Naive() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool&amp; Naive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify whether naive search is being used. </p>

<p class="definition">Definition at line <a class="el" href="range__search_8hpp_source.html#l00279">279</a> of file <a class="el" href="range__search_8hpp_source.html">range_search.hpp</a>.</p>

</div>
</div>
<a id="a9b0922f9fb5439cf21e6873f8a9a84b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b0922f9fb5439cf21e6873f8a9a84b5">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">RangeSearch</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">RangeSearch</a>&lt; MetricType, MatType, TreeType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deep copy the given <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html" title="The RangeSearch class is a template class for performing range searches. ">RangeSearch</a> model. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html" title="The RangeSearch class is a template class for performing range searches. ">RangeSearch</a> model to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c57ee3bbf6708990e6432d0962e2226"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c57ee3bbf6708990e6432d0962e2226">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">RangeSearch</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html">RangeSearch</a>&lt; MetricType, MatType, TreeType &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move the given <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html" title="The RangeSearch class is a template class for performing range searches. ">RangeSearch</a> model. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html" title="The RangeSearch class is a template class for performing range searches. ">RangeSearch</a> model to move. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a975940b302b4efec85bbe2d8b36251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a975940b302b4efec85bbe2d8b36251">&#9670;&nbsp;</a></span>ReferenceSet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const MatType&amp; ReferenceSet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the reference set. </p>

<p class="definition">Definition at line <a class="el" href="range__search_8hpp_source.html#l00291">291</a> of file <a class="el" href="range__search_8hpp_source.html">range_search.hpp</a>.</p>

</div>
</div>
<a id="a92cb2297c084f56afea6f37e3c894f52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92cb2297c084f56afea6f37e3c894f52">&#9670;&nbsp;</a></span>ReferenceTree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a5cbbe0e3dd87208f402ebd5a35dcd608">Tree</a>* ReferenceTree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the reference tree (or NULL if in naive mode). </p>

<p class="definition">Definition at line <a class="el" href="range__search_8hpp_source.html#l00294">294</a> of file <a class="el" href="range__search_8hpp_source.html">range_search.hpp</a>.</p>

</div>
</div>
<a id="a4d1e40c0bf406280a237ca1b487e3c62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d1e40c0bf406280a237ca1b487e3c62">&#9670;&nbsp;</a></span>Scores()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Scores </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of scores during the last search. </p>

<p class="definition">Definition at line <a class="el" href="range__search_8hpp_source.html#l00284">284</a> of file <a class="el" href="range__search_8hpp_source.html">range_search.hpp</a>.</p>

</div>
</div>
<a id="a0df148abcabf67c5876e942e12279f8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0df148abcabf67c5876e942e12279f8e">&#9670;&nbsp;</a></span>Search() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Search </td>
          <td>(</td>
          <td class="paramtype">const MatType &amp;&#160;</td>
          <td class="paramname"><em>querySet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const math::Range &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; size_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>neighbors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>distances</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search for all reference points in the given range for each point in the query set, returning the results in the neighbors and distances objects. </p>
<p>Each entry in the external vector corresponds to a query point. Each of these entries holds a vector which contains the indices and distances of the reference points falling into the given range.</p>
<p>That is:</p>
<ul>
<li>neighbors.size() and distances.size() both equal the number of query points.</li>
<li>neighbors[i] contains the indices of all the points in the reference set which have distances inside the given range to query point i.</li>
<li>distances[i] contains all of the distances corresponding to the indices contained in neighbors[i].</li>
<li>neighbors[i] and distances[i] are not sorted in any particular order.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">querySet</td><td>Set of query points to search with. </td></tr>
    <tr><td class="paramname">range</td><td>Range of distances in which to search. </td></tr>
    <tr><td class="paramname">neighbors</td><td>Object which will hold the list of neighbors for each point which fell into the given range, for each query point. </td></tr>
    <tr><td class="paramname">distances</td><td>Object which will hold the list of distances for each point which fell into the given range, for each query point. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a24f0beece99aedbee1edf5890f5bc235"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24f0beece99aedbee1edf5890f5bc235">&#9670;&nbsp;</a></span>Search() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Search </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a5cbbe0e3dd87208f402ebd5a35dcd608">Tree</a> *&#160;</td>
          <td class="paramname"><em>queryTree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const math::Range &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; size_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>neighbors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>distances</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a pre-built query tree, search for all reference points in the given range for each point in the query set, returning the results in the neighbors and distances objects. </p>
<p>Each entry in the external vector corresponds to a query point. Each of these entries holds a vector which contains the indices and distances of the reference points falling into the given range.</p>
<p>That is:</p>
<ul>
<li>neighbors.size() and distances.size() both equal the number of query points.</li>
<li>neighbors[i] contains the indices of all the points in the reference set which have distances inside the given range to query point i.</li>
<li>distances[i] contains all of the distances corresponding to the indices contained in neighbors[i].</li>
<li>neighbors[i] and distances[i] are not sorted in any particular order.</li>
</ul>
<p>If either naive or singleMode are set to true, this will throw an invalid_argument exception; passing in a query tree implies dual-tree search.</p>
<p>If you want to use the reference tree as the query tree, instead call the overload of <a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a0df148abcabf67c5876e942e12279f8e" title="Search for all reference points in the given range for each point in the query set, returning the results in the neighbors and distances objects. ">Search()</a> that does not take a query set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queryTree</td><td>Tree built on query points. </td></tr>
    <tr><td class="paramname">range</td><td>Range of distances in which to search. </td></tr>
    <tr><td class="paramname">neighbors</td><td>Object which will hold the list of neighbors for each point which fell into the given range, for each query point. </td></tr>
    <tr><td class="paramname">distances</td><td>Object which will hold the list of distances for each point which fell into the given range, for each query point. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3868480bcd41a740550657144b5f7018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3868480bcd41a740550657144b5f7018">&#9670;&nbsp;</a></span>Search() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Search </td>
          <td>(</td>
          <td class="paramtype">const math::Range &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; size_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>neighbors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>distances</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search for all points in the given range for each point in the reference set (which was passed to the constructor), returning the results in the neighbors and distances objects. </p>
<p>This means that the query set and the reference set are the same.</p>
<p>Each entry in the external vector corresponds to a query point. Each of these entries holds a vector which contains the indices and distances of the reference points falling into the given range.</p>
<p>That is:</p>
<ul>
<li>neighbors.size() and distances.size() both equal the number of query points.</li>
<li>neighbors[i] contains the indices of all the points in the reference set which have distances inside the given range to query point i.</li>
<li>distances[i] contains all of the distances corresponding to the indices contained in neighbors[i].</li>
<li>neighbors[i] and distances[i] are not sorted in any particular order.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>Range of distances in which to search. </td></tr>
    <tr><td class="paramname">neighbors</td><td>Object which will hold the list of neighbors for each point which fell into the given range, for each query point. </td></tr>
    <tr><td class="paramname">distances</td><td>Object which will hold the list of distances for each point which fell into the given range, for each query point. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a72d63b74c8166dff8e1a9006905ad9ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72d63b74c8166dff8e1a9006905ad9ca">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serialize the model. </p>

<p class="reference">Referenced by <a class="el" href="range__search_8hpp_source.html#l00284">RangeSearch&lt; metric::EuclideanDistance, arma::mat, TreeType &gt;::Scores()</a>.</p>

</div>
</div>
<a id="a7477b3e8499a6158bbe177e7f30d4947"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7477b3e8499a6158bbe177e7f30d4947">&#9670;&nbsp;</a></span>SingleMode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SingleMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get whether single-tree search is being used. </p>

<p class="definition">Definition at line <a class="el" href="range__search_8hpp_source.html#l00272">272</a> of file <a class="el" href="range__search_8hpp_source.html">range_search.hpp</a>.</p>

</div>
</div>
<a id="adadacd63ddeadf138d834b1fdc632773"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adadacd63ddeadf138d834b1fdc632773">&#9670;&nbsp;</a></span>SingleMode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool&amp; SingleMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify whether single-tree search is being used. </p>

<p class="definition">Definition at line <a class="el" href="range__search_8hpp_source.html#l00274">274</a> of file <a class="el" href="range__search_8hpp_source.html">range_search.hpp</a>.</p>

</div>
</div>
<a id="a27ba39af83e3cb01f2e6fbec159adf0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27ba39af83e3cb01f2e6fbec159adf0e">&#9670;&nbsp;</a></span>Train() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Train </td>
          <td>(</td>
          <td class="paramtype">MatType&#160;</td>
          <td class="paramname"><em>referenceSet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the reference set to a new reference set, and build a tree if necessary. </p>
<p>This method is called '<a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a27ba39af83e3cb01f2e6fbec159adf0e" title="Set the reference set to a new reference set, and build a tree if necessary. ">Train()</a>' in order to match the rest of the mlpack abstractions, even though calling this "training" is maybe a bit of a stretch.</p>
<p>Use std::move to pass in the reference set if the old copy is no longer needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">referenceSet</td><td>New set of reference data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3d1133fe6bda66e7143fd7aab27cbd04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d1133fe6bda66e7143fd7aab27cbd04">&#9670;&nbsp;</a></span>Train() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Train </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlpack_1_1range_1_1RangeSearch.html#a5cbbe0e3dd87208f402ebd5a35dcd608">Tree</a> *&#160;</td>
          <td class="paramname"><em>referenceTree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the reference tree to a new reference tree. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/aakash/mlpack/src/mlpack/methods/range_search/<a class="el" href="range__search_8hpp_source.html">range_search.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
<script type="text/javascript">
var x = document.querySelectorAll("img.formulaDsp");
var i;
for (i = 0; i < x.length; i++)
{
  x[i].width = x[i].offsetWidth / 4;
}
</script>
</html>
