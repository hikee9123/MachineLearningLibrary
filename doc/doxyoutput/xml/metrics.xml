<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="metrics" kind="page">
    <compoundname>metrics</compoundname>
    <title>The MetricType policy in mlpack</title>
    <detaileddescription>
<para>Many machine learning methods operate with some sort of metric, and often, this metric can be any arbitrary metric. For instance, consider the problem of nearest neighbor search; one can find the nearest neighbor of a point with respect to the standard Euclidean distance, or the Manhattan (city-block) distance. The actual search techniques, though, remain the same. And this is true of many machine learning methods: the specific metric that is used can be any valid metric.</para><para>mlpack algorithms, when possible, allow the use of an arbitrary metric via the use of the <computeroutput>MetricType</computeroutput> template parameter. Any metric passed as a <computeroutput>MetricType</computeroutput> template parameter will need to have</para><para><itemizedlist>
<listitem><para>an <computeroutput>Evaluate</computeroutput> function</para></listitem><listitem><para>a default constructor.</para></listitem></itemizedlist>
</para><para>The signature of the <computeroutput>Evaluate</computeroutput> function is straightforward:</para><para><programlisting><codeline><highlight class="normal">template&lt;typename<sp/>VecTypeA,<sp/>typename<sp/>VecTypeB&gt;</highlight></codeline>
<codeline><highlight class="normal">double<sp/>Evaluate(const<sp/>VecTypeA&amp;<sp/>a,<sp/>const<sp/>VecTypeB&amp;<sp/>b);</highlight></codeline>
</programlisting></para><para>The function takes two vector arguments, <computeroutput>a</computeroutput> and <computeroutput>b</computeroutput>, and returns a <computeroutput>double</computeroutput> that is the evaluation of the metric between the two arguments. So, for a particular metric <formula id="181">$d(\cdot, \cdot)$</formula>, the <computeroutput>Evaluate()</computeroutput> function should return <formula id="182">$d(a, b)$</formula>.</para><para>The arguments <computeroutput>a</computeroutput> and <computeroutput>b</computeroutput>, of types <computeroutput>VecTypeA</computeroutput> and <computeroutput>VecTypeB</computeroutput>, respectively, will be an Armadillo-like vector type (usually <computeroutput>arma::vec</computeroutput>, <computeroutput>arma::sp_vec</computeroutput>, or similar). In general it should be valid to assume that <computeroutput>VecTypeA</computeroutput> is a class with the same API as <computeroutput>arma::vec</computeroutput>.</para><para>Note that for metrics that do not hold any state, the <computeroutput>Evaluate()</computeroutput> method can be marked as <computeroutput>static</computeroutput>.</para><para>Overall, the <computeroutput>MetricType</computeroutput> template policy is quite simple (much like the <ref refid="kernels" kindref="compound">The KernelType policy in mlpack</ref> KernelType policy). Below is an example metric class, which implements the L2 distance:</para><para><programlisting><codeline><highlight class="normal">class<sp/>ExampleMetric</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Default<sp/>constructor<sp/>is<sp/>required.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ExampleMetric()<sp/>{<sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>The<sp/>example<sp/>metric<sp/>holds<sp/>no<sp/>state,<sp/>so<sp/>we<sp/>can<sp/>mark<sp/>Evaluate()<sp/>as<sp/>static.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>template&lt;typename<sp/>VecTypeA,<sp/>typename<sp/>VecTypeB&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>static<sp/>double<sp/>Evaluate(const<sp/>VecTypeA&amp;<sp/>a,<sp/>const<sp/>VecTypeB&amp;<sp/>b)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Return<sp/>the<sp/>L2<sp/>norm<sp/>of<sp/>the<sp/>difference<sp/>between<sp/>the<sp/>points,<sp/>which<sp/>is<sp/>the</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>same<sp/>as<sp/>the<sp/>L2<sp/>distance.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>arma::norm(a<sp/>-<sp/>b);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para><para>Then, this metric can easily be used inside of other mlpack algorithms. For example, the code below runs range search on a random dataset with the <computeroutput>ExampleKernel</computeroutput>, by instantiating a <computeroutput><ref refid="classmlpack_1_1range_1_1RangeSearch" kindref="compound">mlpack::range::RangeSearch</ref></computeroutput> object that uses the <computeroutput>ExampleKernel</computeroutput>. Then, the number of results are printed. The <computeroutput>RangeSearch</computeroutput> class takes three template parameters: <computeroutput>MetricType</computeroutput>, <computeroutput>MatType</computeroutput>, and <computeroutput>TreeType</computeroutput>. (All three have defaults, so we will just leave <computeroutput>MatType</computeroutput> and <computeroutput>TreeType</computeroutput> to their defaults.)</para><para><programlisting><codeline><highlight class="normal">#include<sp/>&lt;mlpack/core.hpp&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;mlpack/methods/range_search/range_search.hpp&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&quot;example_metric.hpp&quot;<sp/>//<sp/>A<sp/>file<sp/>that<sp/>contains<sp/>ExampleKernel.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">using<sp/>namespace<sp/>mlpack;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>namespace<sp/>mlpack::range;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>namespace<sp/>std;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">int<sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Create<sp/>a<sp/>random<sp/>dataset<sp/>with<sp/>10<sp/>dimensions<sp/>and<sp/>5000<sp/>points.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>arma::mat<sp/>data<sp/>=<sp/>arma::randu&lt;arma::mat&gt;(10,<sp/>5000);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Instantiate<sp/>the<sp/>RangeSearch<sp/>object<sp/>with<sp/>the<sp/>ExampleKernel.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>RangeSearch&lt;ExampleKernel&gt;<sp/>rs(data);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>These<sp/>vectors<sp/>will<sp/>store<sp/>the<sp/>results.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>vector&lt;vector&lt;size_t&gt;&gt;<sp/>neighbors;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>vector&lt;vector&lt;double&gt;&gt;<sp/>distances;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Create<sp/>a<sp/>random<sp/>10-dimensional<sp/>query<sp/>point.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>arma::vec<sp/>query<sp/>=<sp/>arma::randu&lt;arma::vec&gt;(10);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Find<sp/>those<sp/>points<sp/>with<sp/>distance<sp/>(according<sp/>to<sp/>ExampleMetric)<sp/>between<sp/>1<sp/>and</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>2<sp/>from<sp/>the<sp/>query<sp/>point.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>rs.Search(query,<sp/>math::Range(1.0,<sp/>2.0),<sp/>neighbors,<sp/>distances);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Now,<sp/>print<sp/>the<sp/>number<sp/>of<sp/>points<sp/>inside<sp/>the<sp/>desired<sp/>range.<sp/><sp/>We<sp/>know<sp/>that</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>neighbors<sp/>and<sp/>distances<sp/>will<sp/>have<sp/>length<sp/>1,<sp/>since<sp/>there<sp/>was<sp/>only<sp/>one<sp/>query</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>point.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>cout<sp/>&lt;&lt;<sp/>neighbors[0].size()<sp/>&lt;&lt;<sp/>&quot;<sp/>points<sp/>within<sp/>the<sp/>range<sp/>[1.0,<sp/>2.0]<sp/>of<sp/>the<sp/>&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>&quot;query<sp/>point!&quot;<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>mlpack comes with a number of pre-written metrics that satisfy the <computeroutput>MetricType</computeroutput> policy:</para><para><itemizedlist>
<listitem><para><ref refid="namespacemlpack_1_1metric_1a70063851fc04406ab432862576463215" kindref="member">mlpack::metric::ManhattanDistance</ref></para></listitem><listitem><para><ref refid="namespacemlpack_1_1metric_1a0306f114fdf32dcdfa8f015408cfc37d" kindref="member">mlpack::metric::EuclideanDistance</ref></para></listitem><listitem><para><ref refid="namespacemlpack_1_1metric_1ad0e0d71e65dddac145245399cb7b0b15" kindref="member">mlpack::metric::ChebyshevDistance</ref></para></listitem><listitem><para><ref refid="classmlpack_1_1metric_1_1MahalanobisDistance" kindref="compound">mlpack::metric::MahalanobisDistance</ref></para></listitem><listitem><para><ref refid="classmlpack_1_1metric_1_1LMetric" kindref="compound">mlpack::metric::LMetric</ref> (for arbitrary L-metrics)</para></listitem><listitem><para><ref refid="classmlpack_1_1metric_1_1IPMetric" kindref="compound">mlpack::metric::IPMetric</ref> (requires a <ref refid="kernels" kindref="compound">KernelType</ref> parameter) </para></listitem></itemizedlist>
</para>    </detaileddescription>
  </compounddef>
</doxygen>
