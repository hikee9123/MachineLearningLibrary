<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="kernels" kind="page">
    <compoundname>kernels</compoundname>
    <title>The KernelType policy in mlpack</title>
    <detaileddescription>
<sect1 id="kernels_1kerneltoc">
<title>Table of Contents</title>
<para><itemizedlist>
<listitem><para><ref refid="kernels_1kerneltype" kindref="member">Introduction to the KernelType policy</ref></para></listitem><listitem><para><ref refid="kernels_1kerneltraits" kindref="member">The KernelTraits trait class</ref></para></listitem><listitem><para><ref refid="kernels_1kernellist" kindref="member">List of kernels and classes that use a <computeroutput>KernelType</computeroutput> </ref></para></listitem></itemizedlist>
</para></sect1>
<sect1 id="kernels_1kerneltype">
<title>Introduction to the KernelType policy</title>
<para>`Kernel methods&apos; make up a large class of machine learning techniques. Each of these methods is characterized by its dependence on a <bold>kernel</bold> <bold>function</bold>. In rough terms, a kernel function is a general notion of similarity between two points, with its value large when objects are similar and its value small when objects are dissimilar (note that this is not the only interpretation of what a kernel is).</para><para>A kernel (or `Mercer kernel&apos;) <formula id="177">$\mathcal{K}(\cdot, \cdot)$</formula> takes two objects as input and returns some sort of similarity value. The specific details and properties of kernels are outside the scope of this documentation; for a better introduction to kernels and kernel methods, there are numerous better resources available, including <ulink url="http://www.eric-kim.net/eric-kim-net/posts/1/kernel_trick.html">Eric Kim&apos;s tutorial</ulink></para><para>mlpack implements a number of kernel methods and, accordingly, each of these methods allows arbitrary kernels to be used via the <computeroutput>KernelType</computeroutput> template parameter. Like the <ref refid="metrics" kindref="compound">MetricType policy</ref>, the requirements are quite simple: a class implementing the <computeroutput>KernelType</computeroutput> policy must have</para><para><itemizedlist>
<listitem><para>an <computeroutput>Evaluate()</computeroutput> function</para></listitem><listitem><para>a default constructor</para></listitem></itemizedlist>
</para><para>The signature of the <computeroutput>Evaluate()</computeroutput> function is straightforward:</para><para><programlisting><codeline><highlight class="normal">template&lt;typename<sp/>VecTypeA,<sp/>typename<sp/>VecTypeB&gt;</highlight></codeline>
<codeline><highlight class="normal">double<sp/>Evaluate(const<sp/>VecTypeA&amp;<sp/>a,<sp/>const<sp/>VecTypeB&amp;<sp/>b);</highlight></codeline>
</programlisting></para><para>The function takes two vector arguments, <computeroutput>a</computeroutput> and <computeroutput>b</computeroutput>, and returns a <computeroutput>double</computeroutput> that is the evaluation of the kernel between the two arguments. So, for a particular kernel <formula id="177">$\mathcal{K}(\cdot, \cdot)$</formula>, the <computeroutput>Evaluate()</computeroutput> function should return <formula id="178">$\mathcal{K}(a, b)$</formula>.</para><para>The arguments <computeroutput>a</computeroutput> and <computeroutput>b</computeroutput>, of types <computeroutput>VecTypeA</computeroutput> and <computeroutput>VecTypeB</computeroutput>, respectively, will be an Armadillo-like vector type (usually <computeroutput>arma::vec</computeroutput>, <computeroutput>arma::sp_vec</computeroutput>, or similar). In general it should be valid to assume that <computeroutput>VecTypeA</computeroutput> is a class with the same API as <computeroutput>arma::vec</computeroutput>.</para><para>Note that for kernels that do not hold any state, the <computeroutput>Evaluate()</computeroutput> method can be marked as <computeroutput>static</computeroutput>.</para><para>Overall, the <computeroutput>KernelType</computeroutput> template policy is quite simple (much like the <ref refid="metrics" kindref="compound">MetricType policy</ref>). Below is an example kernel class, which outputs <computeroutput>1</computeroutput> if the vectors are close and <computeroutput>0</computeroutput> otherwise.</para><para><programlisting><codeline><highlight class="normal">class<sp/>ExampleKernel</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Default<sp/>constructor<sp/>is<sp/>required.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ExampleKernel()<sp/>{<sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>The<sp/>example<sp/>kernel<sp/>holds<sp/>no<sp/>state,<sp/>so<sp/>we<sp/>can<sp/>mark<sp/>Evaluate()<sp/>as<sp/>static.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>template&lt;typename<sp/>VecTypeA,<sp/>typename<sp/>VecTypeB&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>static<sp/>double<sp/>Evaluate(const<sp/>VecTypeA&amp;<sp/>a,<sp/>const<sp/>VecTypeB&amp;<sp/>b)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Get<sp/>how<sp/>far<sp/>apart<sp/>the<sp/>vectors<sp/>are<sp/>(using<sp/>the<sp/>Euclidean<sp/>distance).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>double<sp/>distance<sp/>=<sp/>arma::norm(a<sp/>-<sp/>b);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(distance<sp/>&lt;<sp/>0.05)<sp/>//<sp/>Less<sp/>than<sp/>0.05<sp/>distance<sp/>is<sp/>&quot;close&quot;.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para><para>Then, this kernel may be easily used inside of mlpack algorithms. For instance, the code below runs kernel PCA (<computeroutput><ref refid="classmlpack_1_1kpca_1_1KernelPCA" kindref="compound">mlpack::kpca::KernelPCA</ref></computeroutput>) on a random dataset using the <computeroutput>ExampleKernel</computeroutput>. The results are saved to a file called <computeroutput>results.csv</computeroutput>. (Note that this is simply an example to demonstrate usage, and this example kernel isn&apos;t actually likely to be useful in practice.)</para><para><programlisting><codeline><highlight class="normal">#include<sp/>&lt;mlpack/core.hpp&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;mlpack/methods/kernel_pca/kernel_pca.hpp&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&quot;example_kernel.hpp&quot;<sp/>//<sp/>Contains<sp/>the<sp/>ExampleKernel<sp/>class.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">using<sp/>namespace<sp/>mlpack;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>namespace<sp/>mlpack::kpca;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>namespace<sp/>arma;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">int<sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Generate<sp/>the<sp/>random<sp/>dataset;<sp/>10<sp/>dimensions,<sp/>5000<sp/>points.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>mat<sp/>dataset<sp/>=<sp/>randu&lt;mat&gt;(10,<sp/>5000);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Instantiate<sp/>the<sp/>KernelPCA<sp/>object<sp/>with<sp/>the<sp/>ExampleKernel<sp/>kernel<sp/>type.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>KernelPCA&lt;ExampleKernel&gt;<sp/>kpca;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>The<sp/>dataset<sp/>will<sp/>be<sp/>transformed<sp/>using<sp/>kernel<sp/>PCA<sp/>with<sp/>the<sp/>example<sp/>kernel<sp/>to</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>contain<sp/>only<sp/>2<sp/>dimensions.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>kpca.Apply(dataset,<sp/>2);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Save<sp/>the<sp/>results<sp/>to<sp/>&apos;results.csv&apos;.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>data::Save(dataset,<sp/>&quot;results.csv&quot;);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect1>
<sect1 id="kernels_1kerneltraits">
<title>The KernelTraits trait class</title>
<para>Some algorithms that use kernels can specialize if the kernel fulfills some certain conditions. An example of a condition might be that the kernel is shift-invariant or that the kernel is normalized. In the case of fast max-kernel search (<ref refid="classmlpack_1_1fastmks_1_1FastMKS" kindref="compound">mlpack::fastmks::FastMKS</ref>), the computation can be accelerated if the kernel is normalized. For this reason, the <computeroutput>KernelTraits</computeroutput> trait class exists. This allows a kernel to specify via a <computeroutput>const</computeroutput> <computeroutput>static</computeroutput> <computeroutput>bool</computeroutput> when these types of conditions are satisfied. <bold>Note that a KernelTraits class is not required,</bold> but may be helpful.</para><para>The <computeroutput>KernelTraits</computeroutput> trait class is a template class that takes a <computeroutput>KernelType</computeroutput> as a parameter, and exposes <computeroutput>const</computeroutput> <computeroutput>static</computeroutput> <computeroutput>bool</computeroutput> values that depend on the kernel. Setting these values is achieved by specialization. The code below provides an example, specializing <computeroutput>KernelTraits</computeroutput> for the <computeroutput>ExampleKernel</computeroutput> from earlier:</para><para><programlisting><codeline><highlight class="normal">template&lt;&gt;</highlight></codeline>
<codeline><highlight class="normal">class<sp/>KernelTraits&lt;ExampleKernel&gt;</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//!<sp/>The<sp/>example<sp/>kernel<sp/>is<sp/>normalized<sp/>(K(x,<sp/>x)<sp/>=<sp/>1<sp/>for<sp/>all<sp/>x).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>static<sp/>bool<sp/>IsNormalized<sp/>=<sp/>true;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para><para>At this time, there is only one kernel trait that is used in mlpack code:</para><para><itemizedlist>
<listitem><para><computeroutput>IsNormalized</computeroutput> (defaults to <computeroutput>false</computeroutput>): if <formula id="179">$ K(x, x) = 1 \; \forall x $</formula>, then the kernel is normalized and this should be set to true.</para></listitem></itemizedlist>
</para></sect1>
<sect1 id="kernels_1kernellist">
<title>List of kernels and classes that use a \c KernelType</title>
<para>mlpack comes with a number of pre-written kernels that satisfy the <computeroutput>KernelType</computeroutput> policy:</para><para><itemizedlist>
<listitem><para><ref refid="classmlpack_1_1kernel_1_1LinearKernel" kindref="compound">mlpack::kernel::LinearKernel</ref></para></listitem><listitem><para><ref refid="classmlpack_1_1kernel_1_1ExampleKernel" kindref="compound">mlpack::kernel::ExampleKernel</ref> <ndash/> an example kernel with more documentation</para></listitem><listitem><para><ref refid="classmlpack_1_1kernel_1_1GaussianKernel" kindref="compound">mlpack::kernel::GaussianKernel</ref></para></listitem><listitem><para><ref refid="classmlpack_1_1kernel_1_1HyperbolicTangentKernel" kindref="compound">mlpack::kernel::HyperbolicTangentKernel</ref></para></listitem><listitem><para><ref refid="classmlpack_1_1kernel_1_1EpanechnikovKernel" kindref="compound">mlpack::kernel::EpanechnikovKernel</ref></para></listitem><listitem><para><ref refid="classmlpack_1_1kernel_1_1CosineDistance" kindref="compound">mlpack::kernel::CosineDistance</ref></para></listitem><listitem><para><ref refid="classmlpack_1_1kernel_1_1LaplacianKernel" kindref="compound">mlpack::kernel::LaplacianKernel</ref></para></listitem><listitem><para><ref refid="classmlpack_1_1kernel_1_1PolynomialKernel" kindref="compound">mlpack::kernel::PolynomialKernel</ref></para></listitem><listitem><para><ref refid="classmlpack_1_1kernel_1_1TriangularKernel" kindref="compound">mlpack::kernel::TriangularKernel</ref></para></listitem><listitem><para><ref refid="classmlpack_1_1kernel_1_1SphericalKernel" kindref="compound">mlpack::kernel::SphericalKernel</ref></para></listitem><listitem><para><ref refid="classmlpack_1_1kernel_1_1PSpectrumStringKernel" kindref="compound">mlpack::kernel::PSpectrumStringKernel</ref> <ndash/> operates on strings, not vectors</para></listitem></itemizedlist>
</para><para>These kernels (or a custom kernel) may be used in a variety of mlpack methods:</para><para><itemizedlist>
<listitem><para><ref refid="classmlpack_1_1kpca_1_1KernelPCA" kindref="compound">mlpack::kpca::KernelPCA</ref> - kernel principal components analysis</para></listitem><listitem><para><ref refid="classmlpack_1_1fastmks_1_1FastMKS" kindref="compound">mlpack::fastmks::FastMKS</ref> - fast max-kernel search</para></listitem><listitem><para><ref refid="classmlpack_1_1kernel_1_1NystroemMethod" kindref="compound">mlpack::kernel::NystroemMethod</ref> - the Nystroem method for sampling</para></listitem><listitem><para><ref refid="classmlpack_1_1metric_1_1IPMetric" kindref="compound">mlpack::metric::IPMetric</ref> - a metric built on a kernel </para></listitem></itemizedlist>
</para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
