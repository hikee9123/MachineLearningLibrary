<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="trees" kind="page">
    <compoundname>trees</compoundname>
    <title>The TreeType policy in mlpack</title>
    <detaileddescription>
<sect1 id="trees_1treeintro">
<title>Introduction</title>
<para>Trees are an important data structure in mlpack and are used in a number of the machine learning algorithms that mlpack implements. Often, the use of trees can allow significant acceleration of an algorithm; this is generally done by pruning away large parts of the tree during computation.</para><para>Most mlpack algorithms that use trees are not tied to a specific tree but instead allow the user to choose a tree via the <computeroutput>TreeType</computeroutput> template parameter. Any tree passed as a <computeroutput>TreeType</computeroutput> template parameter will need to implement a certain set of functions. In addition, a tree may optionally specify some traits about itself with the <computeroutput>TreeTraits</computeroutput> trait class.</para><para>This document aims to clarify the abstractions underlying mlpack trees, list and describe the required functionality of the <computeroutput>TreeType</computeroutput> policy, and point users towards existing types of trees. A table of contents is below:</para><para><itemizedlist>
<listitem><para><ref refid="trees_1treeintro" kindref="member">Introduction</ref></para></listitem><listitem><para><ref refid="trees_1whatistree" kindref="member">What is a tree?</ref></para></listitem><listitem><para><ref refid="trees_1treetype_template_params" kindref="member">Template parameters required by the TreeType policy</ref></para></listitem><listitem><para><ref refid="trees_1treetype_api" kindref="member">The TreeType API</ref></para></listitem><listitem><para><ref refid="trees_1treetype_rigorous" kindref="member">Rigorous API documentation</ref><itemizedlist>
<listitem><para><ref refid="trees_1treetype_rigorous_template" kindref="member">Template parameters</ref></para></listitem><listitem><para><ref refid="trees_1treetype_rigorous_constructor" kindref="member">Constructors and destructors</ref></para></listitem><listitem><para><ref refid="trees_1treetype_rigorous_basic" kindref="member">Basic tree functionality</ref></para></listitem><listitem><para><ref refid="trees_1treetype_rigorous_complex" kindref="member">Complex tree functionality and bounds</ref></para></listitem><listitem><para><ref refid="trees_1treetype_rigorous_serialization" kindref="member">Serialization</ref></para></listitem></itemizedlist>
</para></listitem><listitem><para><ref refid="trees_1treetype_traits" kindref="member">The TreeTraits trait class</ref></para></listitem><listitem><para><ref refid="trees_1treetype_more" kindref="member">A list of trees in mlpack and more information</ref></para></listitem></itemizedlist>
</para><para>Although this document is long, there may still be errors and unclear areas. If you are having trouble understanding anything, please get in touch on Github or on the mailing list and someone will help you (and possibly update the documentation afterwards).</para></sect1>
<sect1 id="trees_1whatistree">
<title>What is a tree?</title>
<para>In mlpack, we assume that we have some sort of data matrix, which might be sparse or dense (that is, it could be of type <computeroutput>arma::mat</computeroutput> or <computeroutput>arma::sp_mat</computeroutput>, or any variant that implements the Armadillo API). This data matrix corresponds to a collection of points in some space (usually a Euclidean space). A tree is a way of organizing this data matrix in a hierarchical manner<mdash/>so, points that are nearby should lie in similar nodes.</para><para>We can rigorously define what a tree is, using the definition of <bold>space tree</bold> introduced in the following paper:</para><para><programlisting><codeline><highlight class="normal">@quote</highlight></codeline>
<codeline><highlight class="normal">R.R.<sp/>Curtin,<sp/>W.B.<sp/>March,<sp/>P.<sp/>Ram,<sp/>D.V.<sp/>Anderson,<sp/>A.G.<sp/>Gray,<sp/>and<sp/>C.L.<sp/>Isbell<sp/>Jr.,</highlight></codeline>
<codeline><highlight class="normal">&quot;Tree-independent<sp/>dual-tree<sp/>algorithms,&quot;<sp/>in<sp/>Proceedings<sp/>of<sp/>the<sp/>30th</highlight></codeline>
<codeline><highlight class="normal">International<sp/>Conference<sp/>on<sp/>Machine<sp/>Learning<sp/>(ICML<sp/>&apos;13),<sp/>pp.<sp/>1435--1443,<sp/>2013.</highlight></codeline>
<codeline><highlight class="normal">@endquote</highlight></codeline>
</programlisting></para><para>The definition is:</para><para>A <bold>space tree</bold> on a dataset <formula id="182">$ S \in \mathcal{R}^{N \times d} $</formula> is an undirected, connected, acyclic, rooted simple graph with the following properties:</para><para><itemizedlist>
<listitem><para>Each node (or vertex) holds a number of points (possibly zero) and is connected to one parent node and a number of child nodes (possibly zero).</para></listitem><listitem><para>There is one node in every space tree with no parent; this is the root node of the tree.</para></listitem><listitem><para>Each point in <formula id="183">$S$</formula> is contained in at least one node.</para></listitem><listitem><para>Each node corresponds to some subset of <formula id="184">$\mathcal{R}^d$</formula> that contains each point in the node and also the subsets that correspond to each child of the node.</para></listitem></itemizedlist>
</para><para>This is really a quite straightforward definition: a tree is hierarchical, and each node corresponds to some region of the input space. Each node may have some number of children, and may hold some number of points. However, there is an important terminology distinction to make: the term <bold>points held by a node</bold> has a different meaning than the term <bold>descendant points held by a node</bold>. The points held in a node are just that<mdash/>points held only in the node. The descendant points of a node are the combination of the points held in a node with the points held in the node&apos;s children and the points held in the node&apos;s children&apos;s children (and so forth). For the purposes of clarity in all discussions about trees, care is taken to differentiate the terms &quot;descendant
point&quot; and &quot;point&quot;.</para><para>Now, it&apos;s also important to note that a point does not <emphasis>need</emphasis> to hold any children, and that a node <emphasis>can</emphasis> hold the same points as its children (or its parent). Some types of trees do this. For instance, each node in the cover tree holds only one point, and may have a child that holds the same point. As another example, the <formula id="185">$kd$</formula>-tree holds its points only in the leaves (at the bottom of the tree). More information on space trees can be found in either the &quot;Tree-independent dual-tree algorithms&quot; paper or any of the related literature.</para><para>So there is a huge amount of possible variety in the types of trees that can fall into the class of <emphasis>space trees</emphasis>. Therefore, it&apos;s important to treat them abstractly, and the <computeroutput>TreeType</computeroutput> policy allows us to do just that. All we need to remember is that a node in a tree can be represented as the combination of some points held in the node, some child nodes, and some geometric structure that represents the space that all of the descendant points fall into (this is a restatement of the fourth part of the definition).</para></sect1>
<sect1 id="trees_1treetype_template_params">
<title>Template parameters required by the TreeType policy</title>
<para>Most everything in mlpack is decomposed into a series of configurable template parameters, and trees are no exception. In order to ease usage of high-level mlpack algorithms, each <computeroutput>TreeType</computeroutput> itself must be a template class taking three parameters:</para><para><itemizedlist>
<listitem><para><computeroutput>MetricType</computeroutput> <ndash/> the underlying metric that the tree will be built on (see <ref refid="metrics" kindref="compound">the MetricType policy documentation</ref>)</para></listitem><listitem><para><computeroutput>StatisticType</computeroutput> <ndash/> holds any auxiliary information that individual algorithms may need</para></listitem><listitem><para><computeroutput>MatType</computeroutput> <ndash/> the type of the matrix used to represent the data</para></listitem></itemizedlist>
</para><para>The reason that these three template parameters are necessary is so that each <computeroutput>TreeType</computeroutput> can be used as a template template parameter, which can radically simplify the required syntax for instantiating mlpack algorithms. By using template template parameters, a user needs only to write</para><para><programlisting><codeline><highlight class="normal">//<sp/>The<sp/>RangeSearch<sp/>class<sp/>takes<sp/>a<sp/>MetricType<sp/>and<sp/>a<sp/>TreeType<sp/>template<sp/>parameter.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>This<sp/>code<sp/>instantiates<sp/>RangeSearch<sp/>with<sp/>the<sp/>ManhattanDistance<sp/>and<sp/>a</highlight></codeline>
<codeline><highlight class="normal">//<sp/>QuadTree.<sp/><sp/>Note<sp/>that<sp/>the<sp/>QuadTree<sp/>itself<sp/>is<sp/>a<sp/>template,<sp/>and<sp/>takes<sp/>a</highlight></codeline>
<codeline><highlight class="normal">//<sp/>MetricType,<sp/>StatisticType,<sp/>and<sp/>MatType,<sp/>just<sp/>like<sp/>the<sp/>policy<sp/>requires.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>This<sp/>example<sp/>ignores<sp/>the<sp/>constructor<sp/>parameters,<sp/>for<sp/>the<sp/>sake<sp/>of<sp/>simplicity.</highlight></codeline>
<codeline><highlight class="normal">RangeSearch&lt;ManhattanDistance,<sp/>QuadTree&gt;<sp/>rs(...);</highlight></codeline>
</programlisting></para><para>as opposed to the far more complicated alternative, where the user must specify the values of each template parameter of the tree type:</para><para><programlisting><codeline><highlight class="normal">//<sp/>This<sp/>is<sp/>a<sp/>much<sp/>worse<sp/>alternative,<sp/>where<sp/>the<sp/>user<sp/>must<sp/>specify<sp/>the<sp/>template</highlight></codeline>
<codeline><highlight class="normal">//<sp/>arguments<sp/>of<sp/>their<sp/>tree.</highlight></codeline>
<codeline><highlight class="normal">RangeSearch&lt;ManhattanDistance,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>QuadTree&lt;ManhattanDistance,<sp/>EmptyStatistic,<sp/>arma::mat&gt;&gt;<sp/>rs(...);</highlight></codeline>
</programlisting></para><para>Unfortunately, the price to pay for this user convenience is that <emphasis>every</emphasis> <computeroutput>TreeType</computeroutput> must have three template parameters, and they must be in exactly that order. Fortunately, there is an additional benefit: we are guaranteed that the tree is built using the same metric as the method (that is, a user can&apos;t specify different metric types to the algorithm and to the tree, which they can without template template parameters).</para><para>There are two important notes about this:</para><para><itemizedlist>
<listitem><para>Not every possible input of MetricType, StatisticType, and/or MatType necessarily need to be valid or work correctly for each type of tree. For instance, the QuadTree is limited to Euclidean metrics and will not work otherwise. Either compile-time static checks or detailed documentation can help keep users from using invalid combinations of template arguments.</para></listitem><listitem><para>Some types of trees have more template parameters than just these three. One example is the generalized binary space tree, where the bounding shape of each node is easily made into a fourth template parameter (the <computeroutput>BinarySpaceTree</computeroutput> class calls this the <computeroutput>BoundType</computeroutput> parameter), and the procedure used to split a node is easily made into a fifth template parameter (the <computeroutput>BinarySpaceTree</computeroutput> class calls this the <computeroutput>SplitType</computeroutput> parameter). However, the syntax of template template parameters <emphasis>requires</emphasis> that the class only has the correct number of template parameters<mdash/>no more, no less. Fortunately, C++11 allows template typedefs, which can be used to provide partial specialization of template classes:</para></listitem></itemizedlist>
</para><para><programlisting><codeline><highlight class="normal">//<sp/>This<sp/>is<sp/>the<sp/>definition<sp/>of<sp/>the<sp/>BinarySpaceTree<sp/>class,<sp/>which<sp/>has<sp/>five<sp/>template</highlight></codeline>
<codeline><highlight class="normal">//<sp/>parameters.</highlight></codeline>
<codeline><highlight class="normal">template&lt;typename<sp/>MetricType,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typename<sp/>StatisticType,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typename<sp/>MatType,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typename<sp/>BoundType,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typename<sp/>SplitType&gt;</highlight></codeline>
<codeline><highlight class="normal">class<sp/>BinarySpaceTree;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>The<sp/>&apos;using&apos;<sp/>keyword<sp/>gives<sp/>us<sp/>a<sp/>template<sp/>typedef,<sp/>so<sp/>we<sp/>can<sp/>define<sp/>the</highlight></codeline>
<codeline><highlight class="normal">//<sp/>MeanSplitKDTree<sp/>template<sp/>class,<sp/>which<sp/>has<sp/>three<sp/>parameters<sp/>and<sp/>is<sp/>a<sp/>valid</highlight></codeline>
<codeline><highlight class="normal">//<sp/>TreeType<sp/>policy<sp/>class.</highlight></codeline>
<codeline><highlight class="normal">template&lt;typename<sp/>MetricType,<sp/>typename<sp/>StatisticType,<sp/>typename<sp/>MatType&gt;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>MeanSplitKDTree<sp/>=<sp/>BinarySpaceTree&lt;MetricType,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>StatisticType,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>MatType,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>HRectBound&lt;MetricType&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>MeanSplit&lt;BoundType,<sp/>MetricType&gt;&gt;;</highlight></codeline>
</programlisting></para><para>Now, the <computeroutput>MeanSplitKDTree</computeroutput> class has only three template parameters and can be used as a <computeroutput>TreeType</computeroutput> policy class in various mlpack algorithms. Many types of trees in mlpack have more than three template parameters and rely on template typedefs to provide simplified <computeroutput>TreeType</computeroutput> interfaces.</para></sect1>
<sect1 id="trees_1treetype_api">
<title>The TreeType API</title>
<para>As a result of the definition of <emphasis>space tree</emphasis> in the previous section, a simplified API presents itself quite easily. However, more complex functionality is often necessary in mlpack, so this leads to more functions being necessary for a class to satisfy the <computeroutput>TreeType</computeroutput> policy. Combining this with the template parameters required for trees given in the previous section gives us the complete API required for a class implementing the <computeroutput>TreeType</computeroutput> policy. Below is the minimal set of functions required with minor documentation for each function. (More extensive documentation and explanation is given afterwards.)</para><para><programlisting><codeline><highlight class="normal">//<sp/>The<sp/>three<sp/>template<sp/>parameters<sp/>will<sp/>be<sp/>supplied<sp/>by<sp/>the<sp/>user,<sp/>and<sp/>are<sp/>detailed</highlight></codeline>
<codeline><highlight class="normal">//<sp/>in<sp/>the<sp/>previous<sp/>section.</highlight></codeline>
<codeline><highlight class="normal">template&lt;typename<sp/>MetricType,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typename<sp/>StatisticType,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typename<sp/>MatType&gt;</highlight></codeline>
<codeline><highlight class="normal">class<sp/>ExampleTree</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//////////////////////</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>////<sp/>Constructors<sp/>////</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//////////////////////</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>This<sp/>batch<sp/>constructor<sp/>does<sp/>not<sp/>modify<sp/>the<sp/>dataset,<sp/>and<sp/>builds<sp/>the<sp/>entire</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>tree<sp/>using<sp/>a<sp/>default-constructed<sp/>MetricType.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ExampleTree(const<sp/>MatType&amp;<sp/>data);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>This<sp/>batch<sp/>constructor<sp/>does<sp/>not<sp/>modify<sp/>the<sp/>dataset,<sp/>and<sp/>builds<sp/>the<sp/>entire</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>tree<sp/>using<sp/>the<sp/>given<sp/>MetricType.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ExampleTree(const<sp/>MatType&amp;<sp/>data,<sp/>MetricType&amp;<sp/>metric);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Initialize<sp/>the<sp/>tree<sp/>from<sp/>a<sp/>given<sp/>cereal<sp/>archive.<sp/><sp/>SFINAE<sp/>(the</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>second<sp/>argument)<sp/>is<sp/>necessary<sp/>to<sp/>ensure<sp/>that<sp/>the<sp/>archive<sp/>is<sp/>loading,<sp/>not</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>saving.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>template&lt;typename<sp/>Archive&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ExampleTree(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>Archive&amp;<sp/>ar,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>typename<sp/>boost::enable_if&lt;typename<sp/>Archive::is_loading&gt;::type*<sp/>=<sp/>0);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Release<sp/>any<sp/>resources<sp/>held<sp/>by<sp/>the<sp/>tree.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>~ExampleTree();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>/////////////////////////<sp/>//</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>//<sp/>Basic<sp/>functionality<sp/>//<sp/>//</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>/////////////////////////<sp/>//</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Get<sp/>the<sp/>dataset<sp/>that<sp/>the<sp/>tree<sp/>is<sp/>built<sp/>on.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>MatType&amp;<sp/>Dataset();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Get<sp/>the<sp/>metric<sp/>that<sp/>the<sp/>tree<sp/>is<sp/>built<sp/>with.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MetricType&amp;<sp/>Metric();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Get/modify<sp/>the<sp/>StatisticType<sp/>for<sp/>this<sp/>node.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>StatisticType&amp;<sp/>Stat();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Return<sp/>the<sp/>parent<sp/>of<sp/>the<sp/>node,<sp/>or<sp/>NULL<sp/>if<sp/>this<sp/>is<sp/>the<sp/>root.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ExampleTree*<sp/>Parent();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Return<sp/>the<sp/>number<sp/>of<sp/>children<sp/>held<sp/>by<sp/>the<sp/>node.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>size_t<sp/>NumChildren();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Return<sp/>the<sp/>i&apos;th<sp/>child<sp/>held<sp/>by<sp/>the<sp/>node.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ExampleTree&amp;<sp/>Child(const<sp/>size_t<sp/>i);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Return<sp/>the<sp/>number<sp/>of<sp/>points<sp/>held<sp/>in<sp/>the<sp/>node.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>size_t<sp/>NumPoints();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Return<sp/>the<sp/>index<sp/>of<sp/>the<sp/>i&apos;th<sp/>point<sp/>held<sp/>in<sp/>the<sp/>node.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>size_t<sp/>Point(const<sp/>size_t<sp/>i);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Return<sp/>the<sp/>number<sp/>of<sp/>descendant<sp/>nodes<sp/>of<sp/>this<sp/>node.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>size_t<sp/>NumDescendantNodes();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Return<sp/>the<sp/>i&apos;th<sp/>descendant<sp/>node<sp/>of<sp/>this<sp/>node.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ExampleTree&amp;<sp/>DescendantNode(const<sp/>size_t<sp/>i);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Return<sp/>the<sp/>number<sp/>of<sp/>descendant<sp/>points<sp/>of<sp/>this<sp/>node.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>size_t<sp/>NumDescendants();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Return<sp/>the<sp/>index<sp/>of<sp/>the<sp/>i&apos;th<sp/>descendant<sp/>point<sp/>of<sp/>this<sp/>node.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>size_t<sp/>Descendant(const<sp/>size_t<sp/>i);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Store<sp/>the<sp/>center<sp/>of<sp/>the<sp/>bounding<sp/>region<sp/>of<sp/>the<sp/>node<sp/>in<sp/>the<sp/>given<sp/>vector.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>Center(arma::vec&amp;<sp/>center);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>/////////////////////////////////////////////////<sp/>//</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>//<sp/>More<sp/>complex<sp/>distance-related<sp/>functionality<sp/>//<sp/>//</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>/////////////////////////////////////////////////<sp/>//</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Return<sp/>the<sp/>distance<sp/>between<sp/>the<sp/>center<sp/>of<sp/>this<sp/>node<sp/>and<sp/>the<sp/>center<sp/>of</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>its<sp/>parent.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>double<sp/>ParentDistance();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Return<sp/>an<sp/>upper<sp/>bound<sp/>on<sp/>the<sp/>furthest<sp/>possible<sp/>distance<sp/>between<sp/>the</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>center<sp/>of<sp/>the<sp/>node<sp/>and<sp/>any<sp/>point<sp/>held<sp/>in<sp/>the<sp/>node.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>double<sp/>FurthestPointDistance();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Return<sp/>an<sp/>upper<sp/>bound<sp/>on<sp/>the<sp/>furthest<sp/>possible<sp/>distance<sp/>between<sp/>the</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>center<sp/>of<sp/>the<sp/>node<sp/>and<sp/>any<sp/>descendant<sp/>point<sp/>of<sp/>the<sp/>node.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>double<sp/>FurthestDescendantDistance();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Return<sp/>a<sp/>lower<sp/>bound<sp/>on<sp/>the<sp/>minimum<sp/>distance<sp/>between<sp/>the<sp/>center<sp/>and<sp/>any</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>edge<sp/>of<sp/>the<sp/>node&apos;s<sp/>bounding<sp/>shape.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>double<sp/>MinimumBoundDistance();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Return<sp/>a<sp/>lower<sp/>bound<sp/>on<sp/>the<sp/>minimum<sp/>distance<sp/>between<sp/>the<sp/>given<sp/>point<sp/>and</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>the<sp/>node.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>template&lt;typename<sp/>VecType&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>double<sp/>MinDistance(VecType&amp;<sp/>point);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Return<sp/>a<sp/>lower<sp/>bound<sp/>on<sp/>the<sp/>minimum<sp/>distance<sp/>between<sp/>the<sp/>given<sp/>node<sp/>and</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>this<sp/>node.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>double<sp/>MinDistance(ExampleTree&amp;<sp/>otherNode);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Return<sp/>an<sp/>upper<sp/>bound<sp/>on<sp/>the<sp/>maximum<sp/>distance<sp/>between<sp/>the<sp/>given<sp/>point<sp/>and</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>the<sp/>node.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>template&lt;typename<sp/>VecType&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>double<sp/>MaxDistance(VecType&amp;<sp/>point);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Return<sp/>an<sp/>upper<sp/>bound<sp/>on<sp/>the<sp/>maximum<sp/>distance<sp/>between<sp/>the<sp/>given<sp/>node<sp/>and</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>this<sp/>node.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>double<sp/>MaxDistance(ExampleTree&amp;<sp/>otherNode);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Return<sp/>the<sp/>combined<sp/>results<sp/>of<sp/>MinDistance()<sp/>and<sp/>MaxDistance().</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>template&lt;typename<sp/>VecType&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>math::Range<sp/>RangeDistance(VecType&amp;<sp/>point);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Return<sp/>the<sp/>combined<sp/>results<sp/>of<sp/>MinDistance()<sp/>and<sp/>MaxDistance().</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>math::Range<sp/>RangeDistance(ExampleTree&amp;<sp/>otherNode);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>////////////////////////////////////<sp/>//</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>//<sp/>Serialization<sp/>(loading/saving)<sp/>//<sp/>//</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>////////////////////////////////////<sp/>//</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Return<sp/>a<sp/>string<sp/>representation<sp/>of<sp/>the<sp/>tree.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::string<sp/>ToString()<sp/>const;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Serialize<sp/>the<sp/>tree<sp/>(load<sp/>from<sp/>the<sp/>given<sp/>archive<sp/>/<sp/>save<sp/>to<sp/>the<sp/>given</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>archive,<sp/>depending<sp/>on<sp/>its<sp/>type).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>template&lt;typename<sp/>Archive&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>serialize(Archive&amp;<sp/>ar,<sp/>const<sp/>uint32_t<sp/>version);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/>protected:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>A<sp/>default<sp/>constructor;<sp/>only<sp/>meant<sp/>to<sp/>be<sp/>used<sp/>by<sp/>cereal.<sp/><sp/>This</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>must<sp/>be<sp/>protected<sp/>so<sp/>that<sp/>cereal<sp/>will<sp/>work;<sp/>it<sp/>does<sp/>not<sp/>need</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>to<sp/>return<sp/>a<sp/>valid<sp/>tree.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ExampleTree();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Friend<sp/>access<sp/>must<sp/>be<sp/>given<sp/>for<sp/>the<sp/>default<sp/>constructor.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>friend<sp/>class<sp/>cereal::access;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para><para>Although this is significantly more complex than the four-item definition of space tree* might suggest, it turns out many of these methods are not difficult to implement for most reasonable tree types. It is also important to realize that this is a <emphasis>minimum</emphasis> API; you may implement more complex tree types at your leisure (and you may include more template parameters too, though you will have to use template typedefs to provide versions with three parameters; see <ref refid="trees_1treetype_template_params" kindref="member">the previous section</ref>).</para><para>Before diving into the detailed documentation for each function, let us consider a few important points about the implications of this API:</para><para><itemizedlist>
<listitem><para><bold>Trees are not default-constructible</bold> and should not (in general) provide a default constructor. This helps prevent invalid trees. In general, any instantiated mlpack object should be valid and ready to use<mdash/>and a tree built on no points is not valid or ready to use.</para></listitem><listitem><para><bold>Trees only need to provide batch constructors.</bold> Although many tree types do have algorithms for incremental insertions, in mlpack this is not required because the tree-based algorithms that mlpack implements generally assume fully-built, non-modifiable trees. For this purpose, batch construction is perfectly sufficient. (It&apos;s also worth pointing out that for some types of trees, like kd-trees, the cost of a handful of insertions often outweighs the cost of completely rebuilding the tree.)</para></listitem><listitem><para><bold>Trees must provide a number of distance bounding functions.</bold> The utility of trees generally stems from the ability to place quick bounds on distance-related quantities. For instance, if all the descendant points of a node are bounded by a ball of radius <formula id="118">$\lambda$</formula> and the center of the node is a point <formula id="186">$c$</formula>, then the minimum distance between some point <formula id="187">$p$</formula> and any descendant point of the node is equal to the distance between <formula id="187">$p$</formula> and <formula id="186">$c$</formula> minus the radius <formula id="118">$\lambda$</formula>: <formula id="188">$d(p, c) - \lambda$</formula>. This is a fast calculation, and (usually) provides a decent bound on the minimum distance between <formula id="187">$p$</formula> and any descendant point of the node.</para></listitem><listitem><para><bold>Trees need to be able to be serialized.</bold> mlpack uses the cereal library for saving and loading objects. Trees<mdash/>which can be a part of machine learning models<mdash/>therefore must have the ability to be saved and loaded. Making this all work requires a protected constructor (part of the API) and generally makes it impossible to hold references instead of pointers internally, because if a tree is loaded from a file then it must own the dataset it is built on and the metric it uses (this also means that a destructor must exist for freeing these resources).</para></listitem></itemizedlist>
</para><para>Now, we can consider each part of the API more rigorously.</para></sect1>
<sect1 id="trees_1treetype_rigorous">
<title>Rigorous API documentation</title>
<para>This section is divided into five parts:</para><para><itemizedlist>
<listitem><para><ref refid="trees_1treetype_rigorous_template" kindref="member">Template parameters</ref></para></listitem><listitem><para><ref refid="trees_1treetype_rigorous_constructor" kindref="member">Constructors and destructors</ref></para></listitem><listitem><para><ref refid="trees_1treetype_rigorous_basic" kindref="member">Basic tree functionality</ref></para></listitem><listitem><para><ref refid="trees_1treetype_rigorous_complex" kindref="member">Complex tree functionality and bounds</ref></para></listitem><listitem><para><ref refid="trees_1treetype_rigorous_serialization" kindref="member">Serialization</ref></para></listitem></itemizedlist>
</para><sect2 id="trees_1treetype_rigorous_template">
<title>Template parameters</title>
<para><ref refid="trees_1treetype_template_params" kindref="member">An earlier section</ref> discussed the three different template parameters that are required by the <computeroutput>TreeType</computeroutput> policy.</para><para>The <ref refid="metrics" kindref="compound">MetricType policy</ref> provides one method that will be useful for tree building and other operations:</para><para><programlisting><codeline><highlight class="normal">//<sp/>This<sp/>function<sp/>is<sp/>required<sp/>by<sp/>the<sp/>MetricType<sp/>policy.</highlight></codeline>
<codeline><highlight class="normal">//<sp/>Evaluate<sp/>the<sp/>metric<sp/>between<sp/>two<sp/>points<sp/>(which<sp/>may<sp/>be<sp/>of<sp/>different<sp/>types).</highlight></codeline>
<codeline><highlight class="normal">template&lt;typename<sp/>VecTypeA,<sp/>typename<sp/>VecTypeB&gt;</highlight></codeline>
<codeline><highlight class="normal">double<sp/>Evaluate(const<sp/>VecTypeA&amp;<sp/>a,<sp/>const<sp/>VecTypeB&amp;<sp/>b);</highlight></codeline>
</programlisting></para><para>Note that this method is not necessarily static, so a <computeroutput>MetricType</computeroutput> object should be held internally and its <computeroutput>Evaluate()</computeroutput> method should be called whenever the distance between two points is required. <bold>It is generally a bad idea to hardcode any distance calculation in your tree.</bold> This will make the tree unable to generalize to arbitrary metrics. If your tree must depend on certain assumptions holding about the metric (i.e. the metric is a Euclidean metric), then make that clear in the documentation of the tree, so users do not try to use the tree with an inappropriate metric.</para><para>The second template parameter, <computeroutput>StatisticType</computeroutput>, is for auxiliary information that is required by certain algorithms. For instance, consider an algorithm which repeatedly uses the variance of the descendant points of a node. It might be tempting to add a <computeroutput>Variance()</computeroutput> method to the required <computeroutput>TreeType</computeroutput> API, but this quickly leads to code bloat (after all, the API already has quite enough functions as it is). Instead, it is better to create a <computeroutput>StatisticType</computeroutput> class which provides the <computeroutput>Variance()</computeroutput> method, and then call <computeroutput>Stat()</computeroutput>.Variance() when the variance is required. This also holds true for cached data members.</para><para>Each node should have its own instance of a <computeroutput>StatisticType</computeroutput> class. The <computeroutput>StatisticType</computeroutput> must provide the following constructors:</para><para><programlisting><codeline><highlight class="normal">//<sp/>Default<sp/>constructor<sp/>required<sp/>by<sp/>the<sp/>StatisticType<sp/>policy.</highlight></codeline>
<codeline><highlight class="normal">StatisticType();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>This<sp/>constructor<sp/>is<sp/>required<sp/>by<sp/>the<sp/>StatisticType<sp/>policy.</highlight></codeline>
<codeline><highlight class="normal">template&lt;typename<sp/>TreeType&gt;</highlight></codeline>
<codeline><highlight class="normal">StatisticType(TreeType&amp;<sp/>node);</highlight></codeline>
</programlisting></para><para>This constructor should be called with <computeroutput></computeroutput>(*this) after the node is constructed (usually, this ends up being the last line in the constructor of a node).</para><para>The last template parameter is the <computeroutput>MatType</computeroutput> parameter. This is generally <computeroutput>arma::mat</computeroutput> or <computeroutput>arma::sp_mat</computeroutput>, but could be any Armadillo type, including matrices that hold data points of different precisions (such as <computeroutput>float</computeroutput> or even <computeroutput>int</computeroutput>). It generally suffices to write <computeroutput>MatType</computeroutput> assuming that <computeroutput>arma::mat</computeroutput> will be used, since the vast majority of the time this will be what is used.</para></sect2>
<sect2 id="trees_1treetype_rigorous_constructor">
<title>Constructors and destructors</title>
<para>The <computeroutput>TreeType</computeroutput> API requires at least three constructors. Technically, it does not <emphasis>require</emphasis> a destructor, but almost certainly your tree class will be doing some memory management internally and should have one (though not always).</para><para>The first two constructors are variations of the same idea:</para><para><programlisting><codeline><highlight class="normal">//<sp/>This<sp/>batch<sp/>constructor<sp/>does<sp/>not<sp/>modify<sp/>the<sp/>dataset,<sp/>and<sp/>builds<sp/>the<sp/>entire</highlight></codeline>
<codeline><highlight class="normal">//<sp/>tree<sp/>using<sp/>a<sp/>default-constructed<sp/>MetricType.</highlight></codeline>
<codeline><highlight class="normal">ExampleTree(const<sp/>MatType&amp;<sp/>data);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>This<sp/>batch<sp/>constructor<sp/>does<sp/>not<sp/>modify<sp/>the<sp/>dataset,<sp/>and<sp/>builds<sp/>the<sp/>entire</highlight></codeline>
<codeline><highlight class="normal">//<sp/>tree<sp/>using<sp/>the<sp/>given<sp/>MetricType.</highlight></codeline>
<codeline><highlight class="normal">ExampleTree(const<sp/>MatType&amp;<sp/>data,<sp/>MetricType&amp;<sp/>metric);</highlight></codeline>
</programlisting></para><para>All that is required here is that a constructor is available that takes a dataset and optionally an instantiated metric. If no metric is provided, then it should be assumed that the <computeroutput>MetricType</computeroutput> class has a default constructor and a default-constructed metric should be used. The constructor <emphasis>must</emphasis> return a valid, fully-constructed, ready-to-use tree that satisfies the definition of <emphasis>space tree</emphasis> that was <ref refid="trees_1whatistree" kindref="member">given earlier</ref>.</para><para>It is possible to implement both these constructors as one by using <computeroutput>boost::optional</computeroutput>.</para><para>The third constructor requires the tree to be initializable from a <computeroutput>cereal</computeroutput> archive:</para><para><programlisting><codeline><highlight class="normal">//<sp/>Initialize<sp/>the<sp/>tree<sp/>from<sp/>a<sp/>given<sp/>cereal<sp/>archive.<sp/><sp/>SFINAE<sp/>(the</highlight></codeline>
<codeline><highlight class="normal">//<sp/>second<sp/>argument)<sp/>is<sp/>necessary<sp/>to<sp/>ensure<sp/>that<sp/>the<sp/>archive<sp/>is<sp/>loading,<sp/>not</highlight></codeline>
<codeline><highlight class="normal">//<sp/>saving.</highlight></codeline>
<codeline><highlight class="normal">template&lt;typename<sp/>Archive&gt;</highlight></codeline>
<codeline><highlight class="normal">ExampleTree(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Archive&amp;<sp/>ar,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>typename<sp/>boost::enable_if&lt;typename<sp/>Archive::is_loading&gt;::type*<sp/>=<sp/>0);</highlight></codeline>
</programlisting></para><para>This has implications on how the tree must be stored. In this case, the dataset is <emphasis>not yet loaded</emphasis> and therefore the tree <bold>may be required to have ownership of the data matrix</bold>. This means that realistically the most reasonable way to represent the data matrix internally in a tree class is not with a reference but instead with a pointer. If this is true, then a destructor will be required:</para><para><programlisting><codeline><highlight class="normal">//<sp/>Release<sp/>any<sp/>resources<sp/>held<sp/>by<sp/>the<sp/>tree.</highlight></codeline>
<codeline><highlight class="normal">~ExampleTree();</highlight></codeline>
</programlisting></para><para>and, if the data matrix is represented internally with a pointer, this destructor will need to release the memory for the data matrix (in the case that the tree was created via <computeroutput>cereal</computeroutput> ).</para><para>Note that these constructors are not necessarily the only constructors that a <computeroutput>TreeType</computeroutput> implementation can provide. One important example of when more constructors are useful is when the tree rearranges points internally; this might be desired for the sake of speed or memory optimization. But to do this with the required constructors would necessarily incur a copy of the data matrix, because the user will pass a <computeroutput>&quot;const MatType&amp;&quot;</computeroutput>. One alternate solution is to provide a constructor which takes an rvalue reference to a <computeroutput>MatType:</computeroutput> </para><para><programlisting><codeline><highlight class="normal">template&lt;typename<sp/>Archive&gt;</highlight></codeline>
<codeline><highlight class="normal">ExampleTree(MatType&amp;&amp;<sp/>data);</highlight></codeline>
</programlisting></para><para>(and another overload that takes an instantiated metric), and then the user can use <computeroutput>std::move()</computeroutput> to build the tree without copying the data matrix, although the data matrix will be modified:</para><para><programlisting><codeline><highlight class="normal">ExampleTree<sp/>exTree(std::move(dataset));</highlight></codeline>
</programlisting></para><para>It is, of course, possible to add even more constructors if desired.</para></sect2>
<sect2 id="trees_1treetype_rigorous_basic">
<title>Basic tree functionality</title>
<para>The basic functionality of a class implementing the <computeroutput>TreeType</computeroutput> API is quite straightforward and intuitive.</para><para><programlisting><codeline><highlight class="normal">//<sp/>Get<sp/>the<sp/>dataset<sp/>that<sp/>the<sp/>tree<sp/>is<sp/>built<sp/>on.</highlight></codeline>
<codeline><highlight class="normal">const<sp/>MatType&amp;<sp/>Dataset();</highlight></codeline>
</programlisting></para><para>This should return a <computeroutput>const</computeroutput> reference to the dataset the tree is built on. The fact that this function is required essentially means that each node in the tree must store a pointer to the dataset (this is not the only option, but it is the most obvious option).</para><para><programlisting><codeline><highlight class="normal">//<sp/>Get<sp/>the<sp/>metric<sp/>that<sp/>the<sp/>tree<sp/>is<sp/>built<sp/>with.</highlight></codeline>
<codeline><highlight class="normal">MetricType&amp;<sp/>Metric();</highlight></codeline>
</programlisting></para><para>Each node must also store an instantiated metric or a pointer to one (note that this is required even for metrics that have no state and have a <computeroutput>static</computeroutput> <computeroutput>Evaluate()</computeroutput> function).</para><para><programlisting><codeline><highlight class="normal">//<sp/>Get/modify<sp/>the<sp/>StatisticType<sp/>for<sp/>this<sp/>node.</highlight></codeline>
<codeline><highlight class="normal">StatisticType&amp;<sp/>Stat();</highlight></codeline>
</programlisting></para><para>As discussed earlier, each node must hold a <computeroutput>StatisticType</computeroutput>; this is accessible through the <computeroutput>Stat()</computeroutput> function.</para><para><programlisting><codeline><highlight class="normal">//<sp/>Return<sp/>the<sp/>parent<sp/>of<sp/>the<sp/>node,<sp/>or<sp/>NULL<sp/>if<sp/>this<sp/>is<sp/>the<sp/>root.</highlight></codeline>
<codeline><highlight class="normal">ExampleTree*<sp/>Parent();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Return<sp/>the<sp/>number<sp/>of<sp/>children<sp/>held<sp/>by<sp/>the<sp/>node.</highlight></codeline>
<codeline><highlight class="normal">size_t<sp/>NumChildren();</highlight></codeline>
<codeline><highlight class="normal">//<sp/>Return<sp/>the<sp/>i&apos;th<sp/>child<sp/>held<sp/>by<sp/>the<sp/>node.</highlight></codeline>
<codeline><highlight class="normal">ExampleTree&amp;<sp/>Child(const<sp/>size_t<sp/>i);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Return<sp/>the<sp/>number<sp/>of<sp/>points<sp/>held<sp/>in<sp/>the<sp/>node.</highlight></codeline>
<codeline><highlight class="normal">size_t<sp/>NumPoints();</highlight></codeline>
<codeline><highlight class="normal">//<sp/>Return<sp/>the<sp/>index<sp/>of<sp/>the<sp/>i&apos;th<sp/>point<sp/>held<sp/>in<sp/>the<sp/>node.</highlight></codeline>
<codeline><highlight class="normal">size_t<sp/>Point(const<sp/>size_t<sp/>i);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Return<sp/>the<sp/>number<sp/>of<sp/>descendant<sp/>nodes<sp/>of<sp/>this<sp/>node.</highlight></codeline>
<codeline><highlight class="normal">size_t<sp/>NumDescendantNodes();</highlight></codeline>
<codeline><highlight class="normal">//<sp/>Return<sp/>the<sp/>i&apos;th<sp/>descendant<sp/>node<sp/>of<sp/>this<sp/>node.</highlight></codeline>
<codeline><highlight class="normal">ExampleTree&amp;<sp/>DescendantNode(const<sp/>size_t<sp/>i);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Return<sp/>the<sp/>number<sp/>of<sp/>descendant<sp/>points<sp/>of<sp/>this<sp/>node.</highlight></codeline>
<codeline><highlight class="normal">size_t<sp/>NumDescendants();</highlight></codeline>
<codeline><highlight class="normal">//<sp/>Return<sp/>the<sp/>index<sp/>of<sp/>the<sp/>i&apos;th<sp/>descendant<sp/>point<sp/>of<sp/>this<sp/>node.</highlight></codeline>
<codeline><highlight class="normal">size_t<sp/>Descendant(const<sp/>size_t<sp/>i);</highlight></codeline>
</programlisting></para><para>These functions are all fairly self-explanatory. Most algorithms will use the <computeroutput>Parent()</computeroutput>, <computeroutput>Children()</computeroutput>, <computeroutput>NumChildren()</computeroutput>, <computeroutput>Point()</computeroutput>, and <computeroutput>NumPoints()</computeroutput> functions, so care should be taken when implementing those functions to ensure they will be efficient. Note that <computeroutput>Point()</computeroutput> and <computeroutput>Descendant()</computeroutput> should return indices of points, so the actual points can be accessed by calling <computeroutput>&quot;Dataset().col(Point(i))&quot;</computeroutput> for some index <computeroutput>i</computeroutput> (or something similar).</para><para>An important note about the <computeroutput>Descendant()</computeroutput> function is that each descendant point should be unique. So if a node holds the point with index 6 and it has one child that holds the points with indices 6 and 7, then <computeroutput>NumDescendants()</computeroutput> should return 2, not 3. The ordering in which the descendants are returned can be arbitrary; so, <computeroutput>Descendant(0)</computeroutput> can return 6 <bold>or</bold> 7, and <computeroutput>Descendant(1)</computeroutput> should return the other index.</para><para><programlisting><codeline><highlight class="normal">//<sp/>Store<sp/>the<sp/>center<sp/>of<sp/>the<sp/>bounding<sp/>region<sp/>of<sp/>the<sp/>node<sp/>in<sp/>the<sp/>given<sp/>vector.</highlight></codeline>
<codeline><highlight class="normal">void<sp/>Center(arma::vec&amp;<sp/>center);</highlight></codeline>
</programlisting></para><para>The last function, <computeroutput><ref refid="namespacemlpack_1_1math_1af20ca29adeac02601e8f4386bda3588e" kindref="member">Center()</ref></computeroutput>, should calculate the center of the bounding shape and store it in the given vector. So, for instance, if the tree is a ball tree, then the center is simply the center of the ball. Algorithm writers would be wise to try and avoid the use of <computeroutput><ref refid="namespacemlpack_1_1math_1af20ca29adeac02601e8f4386bda3588e" kindref="member">Center()</ref></computeroutput> if possible, since it will necessarily cost a copy of a vector.</para></sect2>
<sect2 id="trees_1treetype_rigorous_complex">
<title>Complex tree functionality and bounds</title>
<para>A node in a tree should also be able to calculate various distance-related bounds; these are particularly useful in tree-based algorithms. Note that any of these bounds does not necessarily need to be maximally tight; generally it is more important that each bound can be easily calculated.</para><para>Details on each bounding function that the <computeroutput>TreeType</computeroutput> API requires are given below.</para><para><programlisting><codeline><highlight class="normal">//<sp/>Return<sp/>the<sp/>distance<sp/>between<sp/>the<sp/>center<sp/>of<sp/>this<sp/>node<sp/>and<sp/>the<sp/>center<sp/>of</highlight></codeline>
<codeline><highlight class="normal">//<sp/>its<sp/>parent.</highlight></codeline>
<codeline><highlight class="normal">double<sp/>ParentDistance();</highlight></codeline>
</programlisting></para><para>Remember that each node corresponds to some region in the space that the dataset lies in. For most tree types this shape is often something geometrically simple: a ball, a cone, a hyperrectangle, a slice, or something similar. The <computeroutput>ParentDistance()</computeroutput> function should return the distance between the center of this node&apos;s region and the center of the parent node&apos;s region.</para><para>In practice this bound is often used in dual-tree (or single-tree) algorithms to place an easy <computeroutput>MinDistance()</computeroutput> (or <computeroutput>MaxDistance()</computeroutput> ) bound for a child node; the parent&apos;s <computeroutput>MinDistance()</computeroutput> (or <computeroutput>MaxDistance()</computeroutput> ) function is called and then adjusted with <computeroutput>ParentDistance()</computeroutput> to provide a possibly loose but efficient bound on what the result of <computeroutput>MinDistance()</computeroutput> (or <computeroutput>MaxDistance()</computeroutput> ) would be with the child.</para><para><programlisting><codeline><highlight class="normal">//<sp/>Return<sp/>an<sp/>upper<sp/>bound<sp/>on<sp/>the<sp/>furthest<sp/>possible<sp/>distance<sp/>between<sp/>the</highlight></codeline>
<codeline><highlight class="normal">//<sp/>center<sp/>of<sp/>the<sp/>node<sp/>and<sp/>any<sp/>point<sp/>held<sp/>in<sp/>the<sp/>node.</highlight></codeline>
<codeline><highlight class="normal">double<sp/>FurthestPointDistance();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Return<sp/>an<sp/>upper<sp/>bound<sp/>on<sp/>the<sp/>furthest<sp/>possible<sp/>distance<sp/>between<sp/>the</highlight></codeline>
<codeline><highlight class="normal">//<sp/>center<sp/>of<sp/>the<sp/>node<sp/>and<sp/>any<sp/>descendant<sp/>point<sp/>of<sp/>the<sp/>node.</highlight></codeline>
<codeline><highlight class="normal">double<sp/>FurthestDescendantDistance();</highlight></codeline>
</programlisting></para><para>It is often very useful to be able to bound the radius of a node, which is effectively what <computeroutput>FurthestDescendantDistance()</computeroutput> does. Often it is easiest to simply calculate and cache the furthest descendant distance at tree construction time. Some trees, such as the cover tree, are able to give guarantees that the points held in the node will necessarily be closer than the descendant points; therefore, the <computeroutput>FurthestPointDistance()</computeroutput> function is also useful.</para><para>It is permissible to simply have <computeroutput>FurthestPointDistance()</computeroutput> return the result of <computeroutput>FurthestDescendantDistance()</computeroutput>, and that will still be a valid bound, but depending on the type of tree it may be possible to have <computeroutput>FurthestPointDistance()</computeroutput> return a tighter bound.</para><para><programlisting><codeline><highlight class="normal">//<sp/>Return<sp/>a<sp/>lower<sp/>bound<sp/>on<sp/>the<sp/>minimum<sp/>distance<sp/>between<sp/>the<sp/>center<sp/>and<sp/>any</highlight></codeline>
<codeline><highlight class="normal">//<sp/>edge<sp/>of<sp/>the<sp/>node&apos;s<sp/>bounding<sp/>shape.</highlight></codeline>
<codeline><highlight class="normal">double<sp/>MinimumBoundDistance();</highlight></codeline>
</programlisting></para><para>This is, admittedly, a somewhat complex and weird quantity. It is one of the less important bounding functions, so it is valid to simply return 0...</para><para>The bound is a bound on the minimum distance between the center of the node and any edge of the shape that bounds all of the descendants of the node. So, if the bounding shape is a ball (as in a ball tree or a cover tree), then <computeroutput>MinimumBoundDistance()</computeroutput> should just return the radius of the ball. If the bounding shape is a hypercube (as in a generalized octree), then <computeroutput>MinimumBoundDistance()</computeroutput> should return the side length divided by two. If the bounding shape is a hyperrectangle (as in a kd-tree or a spill tree), then <computeroutput>MinimumBoundDistance()</computeroutput> should return half the side length of the hyperrectangle&apos;s smallest side.</para><para><programlisting><codeline><highlight class="normal">//<sp/>Return<sp/>a<sp/>lower<sp/>bound<sp/>on<sp/>the<sp/>minimum<sp/>distance<sp/>between<sp/>the<sp/>given<sp/>point<sp/>and</highlight></codeline>
<codeline><highlight class="normal">//<sp/>the<sp/>node.</highlight></codeline>
<codeline><highlight class="normal">template&lt;typename<sp/>VecType&gt;</highlight></codeline>
<codeline><highlight class="normal">double<sp/>MinDistance(VecType&amp;<sp/>point);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Return<sp/>a<sp/>lower<sp/>bound<sp/>on<sp/>the<sp/>minimum<sp/>distance<sp/>between<sp/>the<sp/>given<sp/>node<sp/>and</highlight></codeline>
<codeline><highlight class="normal">//<sp/>this<sp/>node.</highlight></codeline>
<codeline><highlight class="normal">double<sp/>MinDistance(ExampleTree&amp;<sp/>otherNode);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Return<sp/>an<sp/>upper<sp/>bound<sp/>on<sp/>the<sp/>maximum<sp/>distance<sp/>between<sp/>the<sp/>given<sp/>point<sp/>and</highlight></codeline>
<codeline><highlight class="normal">//<sp/>the<sp/>node.</highlight></codeline>
<codeline><highlight class="normal">template&lt;typename<sp/>VecType&gt;</highlight></codeline>
<codeline><highlight class="normal">double<sp/>MaxDistance(VecType&amp;<sp/>point);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Return<sp/>an<sp/>upper<sp/>bound<sp/>on<sp/>the<sp/>maximum<sp/>distance<sp/>between<sp/>the<sp/>given<sp/>node<sp/>and</highlight></codeline>
<codeline><highlight class="normal">//<sp/>this<sp/>node.</highlight></codeline>
<codeline><highlight class="normal">double<sp/>MaxDistance(ExampleTree&amp;<sp/>otherNode);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Return<sp/>the<sp/>combined<sp/>results<sp/>of<sp/>MinDistance()<sp/>and<sp/>MaxDistance().</highlight></codeline>
<codeline><highlight class="normal">template&lt;typename<sp/>VecType&gt;</highlight></codeline>
<codeline><highlight class="normal">math::Range<sp/>RangeDistance(VecType&amp;<sp/>point);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Return<sp/>the<sp/>combined<sp/>results<sp/>of<sp/>MinDistance()<sp/>and<sp/>MaxDistance().</highlight></codeline>
<codeline><highlight class="normal">math::Range<sp/>RangeDistance(ExampleTree&amp;<sp/>otherNode);</highlight></codeline>
</programlisting></para><para>These six functions are almost without a doubt the most important functionality of a tree. Therefore, it is preferable that these methods be implemented as efficiently as possible, as they may potentially be called many millions of times in a tree-based algorithm. It is also preferable that these bounds be as tight as possible. In tree-based algorithms, these are used for pruning away work, and tighter bounds mean that more pruning is possible.</para><para>Of these six functions, there are only really two bounds that are desired here: the <emphasis>minimum distance</emphasis> between a node and an object, and the <emphasis>maximum distance</emphasis> between a node and an object. The object may be either a vector (usually <computeroutput>arma::vec</computeroutput> ) or another tree node.</para><para>Consider the first case, where the object is a vector. The result of <computeroutput>MinDistance()</computeroutput> needs to be less than or equal to the true minimum distance, which could be calculated as below:</para><para><programlisting><codeline><highlight class="normal">//<sp/>We<sp/>assume<sp/>that<sp/>we<sp/>have<sp/>a<sp/>vector<sp/>&apos;vec&apos;,<sp/>and<sp/>a<sp/>tree<sp/>node<sp/>&apos;node&apos;.</highlight></codeline>
<codeline><highlight class="normal">double<sp/>trueMinDist<sp/>=<sp/>DBL_MAX;</highlight></codeline>
<codeline><highlight class="normal">for<sp/>(size_t<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>node.NumDescendants();<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>double<sp/>dist<sp/>=<sp/>node.Metric().Evaluate(vec,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>node.Dataset().col(node.Descendant(i)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(dist<sp/>&lt;<sp/>trueMinDist)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>trueMinDist<sp/>=<sp/>dist;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">//<sp/>At<sp/>the<sp/>end<sp/>of<sp/>the<sp/>loop,<sp/>trueMinDist<sp/>will<sp/>hold<sp/>the<sp/>true<sp/>minimum<sp/>distance</highlight></codeline>
<codeline><highlight class="normal">//<sp/>between<sp/>&apos;vec&apos;<sp/>and<sp/>any<sp/>descendant<sp/>point<sp/>of<sp/>&apos;node&apos;.</highlight></codeline>
</programlisting></para><para>Often the bounding shape of a node will allow a quick calculation that will make a reasonable bound. For instance, if the node&apos;s bounding shape is a ball with radius <computeroutput>r</computeroutput> and center <computeroutput>ctr</computeroutput>, the calculation is simply <computeroutput>&quot;(node.Metric().Evaluate(vec, ctr) - r)&quot;</computeroutput>. Usually a good <computeroutput>MinDistance()</computeroutput> or <computeroutput>MaxDistance()</computeroutput> function will make only one call to the <computeroutput>Evaluate()</computeroutput> function of the metric.</para><para>The <computeroutput>RangeDistance()</computeroutput> function allows a way for both bounds to be calculated at once. It is possible to implement this as a call to <computeroutput>MinDistance()</computeroutput> followed by a call to <computeroutput>MaxDistance()</computeroutput>, but this may incur more metric <computeroutput>Evaluate()</computeroutput> calls than necessary. Often calculating both bounds at once can be more efficient and can be done with fewer <computeroutput>Evaluate()</computeroutput> calls than calling both <computeroutput>MinDistance()</computeroutput> and <computeroutput>MaxDistance()</computeroutput>.</para></sect2>
<sect2 id="trees_1treetype_rigorous_serialization">
<title>Serialization</title>
<para>The last two public functions that the <computeroutput>TreeType</computeroutput> API requires are related to serialization and printing.</para><para><programlisting><codeline><highlight class="normal">//<sp/>Return<sp/>a<sp/>string<sp/>representation<sp/>of<sp/>the<sp/>tree.</highlight></codeline>
<codeline><highlight class="normal">std::string<sp/>ToString()<sp/>const;</highlight></codeline>
</programlisting></para><para>There are few restrictions on the precise way that the <computeroutput>ToString()</computeroutput> function should operate, but generally it should behave similarly to the <computeroutput>ToString()</computeroutput> function in other mlpack methods. Generally, a user will call <computeroutput>ToString()</computeroutput> when they want to inspect the object and see what it looks like. For a tree, printing the entire tree may be way more information than the user was expecting, so it may be a better option to print either only the node itself or the node plus one or two levels of children.</para><para><programlisting><codeline><highlight class="normal">//<sp/>Serialize<sp/>the<sp/>tree<sp/>(load<sp/>from<sp/>the<sp/>given<sp/>archive<sp/>/<sp/>save<sp/>to<sp/>the<sp/>given</highlight></codeline>
<codeline><highlight class="normal">//<sp/>archive,<sp/>depending<sp/>on<sp/>its<sp/>type).</highlight></codeline>
<codeline><highlight class="normal">template&lt;typename<sp/>Archive&gt;</highlight></codeline>
<codeline><highlight class="normal">void<sp/>serialize(Archive&amp;<sp/>ar);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">protected:</highlight></codeline>
<codeline><highlight class="normal">//<sp/>A<sp/>default<sp/>constructor;<sp/>only<sp/>meant<sp/>to<sp/>be<sp/>used<sp/>by<sp/>cereal.<sp/><sp/>This</highlight></codeline>
<codeline><highlight class="normal">//<sp/>must<sp/>be<sp/>protected<sp/>so<sp/>that<sp/>cereal<sp/>will<sp/>work;<sp/>it<sp/>does<sp/>not<sp/>need</highlight></codeline>
<codeline><highlight class="normal">//<sp/>to<sp/>return<sp/>a<sp/>valid<sp/>tree.</highlight></codeline>
<codeline><highlight class="normal">ExampleTree();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Friend<sp/>access<sp/>must<sp/>be<sp/>given<sp/>for<sp/>the<sp/>default<sp/>constructor.</highlight></codeline>
<codeline><highlight class="normal">friend<sp/>class<sp/>cereal::access;</highlight></codeline>
</programlisting></para><para>On the other hand, the specifics of the functionality required for the <computeroutput>Serialize()</computeroutput> function are somewhat more difficult. The <computeroutput>Serialize()</computeroutput> function will be called either when a tree is being saved to disk or loaded from disk. The <computeroutput>cereal</computeroutput> documentation is fairly comprehensive. when writing a <computeroutput>Serialize()</computeroutput> method for mlpack trees you should use <computeroutput>data::CreateNVP()</computeroutput> instead of <computeroutput>BOOST_SERIALIZATION_NVP()</computeroutput>. This is because mlpack classes implement <computeroutput>Serialize()</computeroutput> instead of <computeroutput>serialize()</computeroutput> in order to conform to the mlpack style guidelines, and making this work requires some interesting shim code, which is hidden inside of <computeroutput>data::CreateNVP()</computeroutput>. It may be useful to look at other <computeroutput>Serialize()</computeroutput> methods contained in other mlpack classes as an example.</para><para>An important note is that it is very difficult to use references with <computeroutput>cereal</computeroutput>, because <computeroutput>serialize()</computeroutput> may be called at any time during the object&apos;s lifetime, and references cannot be re-seated. In general this will require the use of pointers, which then require manual memory management. Therefore, be careful that <computeroutput>serialize()</computeroutput> (and the tree&apos;s destructor) properly handle memory management!</para></sect2>
</sect1>
<sect1 id="trees_1treetype_traits">
<title>The TreeTraits trait class</title>
<para>Some tree-based algorithms can specialize if the tree fulfills certain conditions. For instance, if the regions represented by two sibling nodes cannot overlap, an algorithm may be able to perform a simpler computation. Based on this reasoning, the <computeroutput>TreeTraits</computeroutput> trait class (much like the <ref refid="classmlpack_1_1kernel_1_1KernelTraits" kindref="compound">mlpack::kernel::KernelTraits</ref> class) exists in order to allow a tree to specify (via a <computeroutput>const</computeroutput> <computeroutput>static</computeroutput> <computeroutput>bool</computeroutput>) when these types of conditions are satisfied. <bold>Note that a TreeTraits class is not required,</bold> but may be helpful.</para><para>The <computeroutput>TreeTraits</computeroutput> trait class is a template class that takes a <computeroutput>TreeType</computeroutput> as a parameter, and exposes <computeroutput>const</computeroutput> <computeroutput>static</computeroutput> <computeroutput>bool</computeroutput> values that depend on the tree. Setting these values is achieved by specialization. The code below shows the default <computeroutput>TreeTraits</computeroutput> values (these are the values that will be used if no specialization is provided for a given <computeroutput>TreeType</computeroutput>).</para><para><programlisting><codeline><highlight class="normal">template&lt;typename<sp/>TreeType&gt;</highlight></codeline>
<codeline><highlight class="normal">class<sp/>TreeTraits</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>This<sp/>is<sp/>true<sp/>if<sp/>the<sp/>subspaces<sp/>represented<sp/>by<sp/>the<sp/>children<sp/>of<sp/>a<sp/>node<sp/>can</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>overlap.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>static<sp/>const<sp/>bool<sp/>HasOverlappingChildren<sp/>=<sp/>true;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>This<sp/>is<sp/>true<sp/>if<sp/>Point(0)<sp/>is<sp/>the<sp/>centroid<sp/>of<sp/>the<sp/>node.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>static<sp/>const<sp/>bool<sp/>FirstPointIsCentroid<sp/>=<sp/>false;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>This<sp/>is<sp/>true<sp/>if<sp/>the<sp/>points<sp/>contained<sp/>in<sp/>the<sp/>first<sp/>child<sp/>of<sp/>a<sp/>node</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>(Child(0))<sp/>are<sp/>also<sp/>contained<sp/>in<sp/>that<sp/>node.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>static<sp/>const<sp/>bool<sp/>HasSelfChildren<sp/>=<sp/>false;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>This<sp/>is<sp/>true<sp/>if<sp/>the<sp/>tree<sp/>rearranges<sp/>points<sp/>in<sp/>the<sp/>dataset<sp/>when<sp/>it<sp/>is<sp/>built.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>static<sp/>const<sp/>bool<sp/>RearrangesDataset<sp/>=<sp/>false;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>This<sp/>is<sp/>true<sp/>if<sp/>the<sp/>tree<sp/>always<sp/>has<sp/>only<sp/>two<sp/>children.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>static<sp/>const<sp/>bool<sp/>BinaryTree<sp/>=<sp/>false;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para><para>An example specialization for the <ref refid="namespacemlpack_1_1tree_1a73c2146f8d1da65d927c7746bfe7e750" kindref="member">mlpack::tree::KDTree</ref> class is given below. Note that <ref refid="namespacemlpack_1_1tree_1a73c2146f8d1da65d927c7746bfe7e750" kindref="member">mlpack::tree::KDTree</ref> is itself a template class (like every class satisfying the <computeroutput>TreeType</computeroutput> policy), so we are specializing to a template parameter.</para><para><programlisting><codeline><highlight class="normal">template&lt;typename<sp/>MetricType,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typename<sp/>StatisticType,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typename<sp/>MatType&gt;</highlight></codeline>
<codeline><highlight class="normal">template&lt;&gt;</highlight></codeline>
<codeline><highlight class="normal">class<sp/>TreeTraits&lt;KDTree&lt;MetricType,<sp/>StatisticType,<sp/>MatType&gt;&gt;</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>The<sp/>regions<sp/>represented<sp/>by<sp/>the<sp/>two<sp/>children<sp/>of<sp/>a<sp/>node<sp/>may<sp/>not<sp/>overlap.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>static<sp/>const<sp/>bool<sp/>HasOverlappingChildren<sp/>=<sp/>false;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>There<sp/>is<sp/>no<sp/>guarantee<sp/>that<sp/>the<sp/>first<sp/>point<sp/>of<sp/>a<sp/>node<sp/>is<sp/>the<sp/>centroid.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>static<sp/>const<sp/>bool<sp/>FirstPointIsCentroid<sp/>=<sp/>false;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Points<sp/>are<sp/>not<sp/>contained<sp/>at<sp/>multiple<sp/>levels<sp/>(only<sp/>at<sp/>the<sp/>leaves).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>static<sp/>const<sp/>bool<sp/>HasSelfChildren<sp/>=<sp/>false;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Points<sp/>are<sp/>rearranged<sp/>during<sp/>the<sp/>building<sp/>of<sp/>the<sp/>tree.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>static<sp/>const<sp/>bool<sp/>RearrangesDataset<sp/>=<sp/>true;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>The<sp/>tree<sp/>is<sp/>always<sp/>binary.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>static<sp/>const<sp/>bool<sp/>BinaryTree<sp/>=<sp/>true;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para><para>Currently, the traits available are each of the five detailed above. For more information, see the <ref refid="classmlpack_1_1tree_1_1TreeTraits" kindref="compound">mlpack::tree::TreeTraits</ref> documentation.</para></sect1>
<sect1 id="trees_1treetype_more">
<title>A list of trees in mlpack and more information</title>
<para>mlpack contains several ready-to-use implementations of trees that satisfy the TreeType policy API:</para><para><itemizedlist>
<listitem><para><ref refid="namespacemlpack_1_1tree_1a73c2146f8d1da65d927c7746bfe7e750" kindref="member">mlpack::tree::KDTree</ref></para></listitem><listitem><para><ref refid="namespacemlpack_1_1tree_1a1028e6acf1fc61997237d3677cae0947" kindref="member">mlpack::tree::MeanSplitKDTree</ref></para></listitem><listitem><para><ref refid="namespacemlpack_1_1tree_1a9d4905444011bbd045122cc985638b32" kindref="member">mlpack::tree::BallTree</ref></para></listitem><listitem><para><ref refid="namespacemlpack_1_1tree_1a530d041f3f210c6097891301478e10bd" kindref="member">mlpack::tree::MeanSplitBallTree</ref></para></listitem><listitem><para><ref refid="namespacemlpack_1_1tree_1ae4af35641769744ba680cc934e1c1f0e" kindref="member">mlpack::tree::RTree</ref></para></listitem><listitem><para><ref refid="namespacemlpack_1_1tree_1a879db9c5c88d62f13f4a1667bc5adf5c" kindref="member">mlpack::tree::RStarTree</ref></para></listitem><listitem><para><ref refid="namespacemlpack_1_1tree_1a6ed9d585969e7837af0d41e0c3975602" kindref="member">mlpack::tree::StandardCoverTree</ref></para></listitem></itemizedlist>
</para><para>Often, these are template typedefs of more flexible tree classes:</para><para><itemizedlist>
<listitem><para><ref refid="classmlpack_1_1tree_1_1BinarySpaceTree" kindref="compound">mlpack::tree::BinarySpaceTree</ref> <ndash/> binary trees, such as the KD-tree and ball tree</para></listitem><listitem><para><ref refid="namespacemlpack_1_1tree_1_1RectangleTree" kindref="compound">mlpack::tree::RectangleTree</ref> <ndash/> the R tree and variants</para></listitem><listitem><para><ref refid="classmlpack_1_1tree_1_1CoverTree" kindref="compound">mlpack::tree::CoverTree</ref> <ndash/> the cover tree and variants </para></listitem></itemizedlist>
</para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
