<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="namespacemlpack_1_1data" kind="namespace" language="C++">
    <compoundname>mlpack::data</compoundname>
    <innerclass refid="classmlpack_1_1data_1_1BagOfWordsEncodingPolicy" prot="public">mlpack::data::BagOfWordsEncodingPolicy</innerclass>
    <innerclass refid="classmlpack_1_1data_1_1CharExtract" prot="public">mlpack::data::CharExtract</innerclass>
    <innerclass refid="classmlpack_1_1data_1_1CustomImputation" prot="public">mlpack::data::CustomImputation</innerclass>
    <innerclass refid="classmlpack_1_1data_1_1DatasetMapper" prot="public">mlpack::data::DatasetMapper</innerclass>
    <innerclass refid="classmlpack_1_1data_1_1DictionaryEncodingPolicy" prot="public">mlpack::data::DictionaryEncodingPolicy</innerclass>
    <innerclass refid="structmlpack_1_1data_1_1HasSerialize" prot="public">mlpack::data::HasSerialize</innerclass>
    <innerclass refid="structmlpack_1_1data_1_1HasSerializeFunction" prot="public">mlpack::data::HasSerializeFunction</innerclass>
    <innerclass refid="classmlpack_1_1data_1_1ImageInfo" prot="public">mlpack::data::ImageInfo</innerclass>
    <innerclass refid="classmlpack_1_1data_1_1Imputer" prot="public">mlpack::data::Imputer</innerclass>
    <innerclass refid="classmlpack_1_1data_1_1IncrementPolicy" prot="public">mlpack::data::IncrementPolicy</innerclass>
    <innerclass refid="classmlpack_1_1data_1_1ListwiseDeletion" prot="public">mlpack::data::ListwiseDeletion</innerclass>
    <innerclass refid="classmlpack_1_1data_1_1LoadCSV" prot="public">mlpack::data::LoadCSV</innerclass>
    <innerclass refid="classmlpack_1_1data_1_1MaxAbsScaler" prot="public">mlpack::data::MaxAbsScaler</innerclass>
    <innerclass refid="classmlpack_1_1data_1_1MeanImputation" prot="public">mlpack::data::MeanImputation</innerclass>
    <innerclass refid="classmlpack_1_1data_1_1MeanNormalization" prot="public">mlpack::data::MeanNormalization</innerclass>
    <innerclass refid="classmlpack_1_1data_1_1MedianImputation" prot="public">mlpack::data::MedianImputation</innerclass>
    <innerclass refid="classmlpack_1_1data_1_1MinMaxScaler" prot="public">mlpack::data::MinMaxScaler</innerclass>
    <innerclass refid="classmlpack_1_1data_1_1MissingPolicy" prot="public">mlpack::data::MissingPolicy</innerclass>
    <innerclass refid="classmlpack_1_1data_1_1PCAWhitening" prot="public">mlpack::data::PCAWhitening</innerclass>
    <innerclass refid="classmlpack_1_1data_1_1ScalingModel" prot="public">mlpack::data::ScalingModel</innerclass>
    <innerclass refid="classmlpack_1_1data_1_1SplitByAnyOf" prot="public">mlpack::data::SplitByAnyOf</innerclass>
    <innerclass refid="classmlpack_1_1data_1_1StandardScaler" prot="public">mlpack::data::StandardScaler</innerclass>
    <innerclass refid="classmlpack_1_1data_1_1StringEncoding" prot="public">mlpack::data::StringEncoding</innerclass>
    <innerclass refid="classmlpack_1_1data_1_1StringEncodingDictionary" prot="public">mlpack::data::StringEncodingDictionary</innerclass>
    <innerclass refid="classmlpack_1_1data_1_1StringEncodingDictionary_3_01boost_1_1string__view_01_4" prot="public">mlpack::data::StringEncodingDictionary&lt; boost::string_view &gt;</innerclass>
    <innerclass refid="classmlpack_1_1data_1_1StringEncodingDictionary_3_01int_01_4" prot="public">mlpack::data::StringEncodingDictionary&lt; int &gt;</innerclass>
    <innerclass refid="structmlpack_1_1data_1_1StringEncodingPolicyTraits" prot="public">mlpack::data::StringEncodingPolicyTraits</innerclass>
    <innerclass refid="structmlpack_1_1data_1_1StringEncodingPolicyTraits_3_01DictionaryEncodingPolicy_01_4" prot="public">mlpack::data::StringEncodingPolicyTraits&lt; DictionaryEncodingPolicy &gt;</innerclass>
    <innerclass refid="classmlpack_1_1data_1_1TfIdfEncodingPolicy" prot="public">mlpack::data::TfIdfEncodingPolicy</innerclass>
    <innerclass refid="classmlpack_1_1data_1_1ZCAWhitening" prot="public">mlpack::data::ZCAWhitening</innerclass>
      <sectiondef kind="enum">
      <memberdef kind="enum" id="namespacemlpack_1_1data_1aa7714fa0b7efc7b31cbda21da607c5b6" prot="public" static="no">
        <name>Datatype</name>
        <enumvalue id="namespacemlpack_1_1data_1aa7714fa0b7efc7b31cbda21da607c5b6a1b5484703e716389553255e6f11f12ec" prot="public">
          <name>numeric</name>
          <initializer>= 0</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacemlpack_1_1data_1aa7714fa0b7efc7b31cbda21da607c5b6a2992a7ab833605792145cd40762644c7" prot="public">
          <name>categorical</name>
          <initializer>= 1</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>The Datatype enum specifies the types of data mlpack algorithms can use. </para>        </briefdescription>
        <detaileddescription>
<para>The vast majority of mlpack algorithms can only use numeric data (i.e. float/double/etc.), but some algorithms can use categorical data, specified via this Datatype enum and the <ref refid="classmlpack_1_1data_1_1DatasetMapper" kindref="compound">DatasetMapper</ref> class. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/data/map_policies/datatype.hpp" line="25" column="1" bodyfile="/home/aakash/mlpack/src/mlpack/core/data/map_policies/datatype.hpp" bodystart="24" bodyend="28"/>
      </memberdef>
      <memberdef kind="enum" id="namespacemlpack_1_1data_1a387137c43ed9616d39ba90e890d181eb" prot="public" static="no">
        <name>format</name>
        <enumvalue id="namespacemlpack_1_1data_1a387137c43ed9616d39ba90e890d181eba7038b9ea9dd309cf5cc8f7122f6c0cee" prot="public">
          <name>autodetect</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacemlpack_1_1data_1a387137c43ed9616d39ba90e890d181eba23ac0259f4d3527268c85207a3c2e1f0" prot="public">
          <name>json</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacemlpack_1_1data_1a387137c43ed9616d39ba90e890d181ebac0a194d2e3cadd6447861e57368c2581" prot="public">
          <name>xml</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacemlpack_1_1data_1a387137c43ed9616d39ba90e890d181eba4c41ae0ac8cc59e0caeaa4984dd5d469" prot="public">
          <name>binary</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Define the formats we can read through cereal. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/data/format.hpp" line="21" column="1" bodyfile="/home/aakash/mlpack/src/mlpack/core/data/format.hpp" bodystart="20" bodyend="26"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="typedef">
      <memberdef kind="typedef" id="namespacemlpack_1_1data_1a728f5dac92331960e1e5822919dd2a41" prot="public" static="no">
        <type><ref refid="classmlpack_1_1data_1_1StringEncoding" kindref="compound">StringEncoding</ref>&lt; <ref refid="classmlpack_1_1data_1_1BagOfWordsEncodingPolicy" kindref="compound">BagOfWordsEncodingPolicy</ref>, <ref refid="classmlpack_1_1data_1_1StringEncodingDictionary" kindref="compound">StringEncodingDictionary</ref>&lt; TokenType &gt; &gt;</type>
        <definition>using BagOfWordsEncoding =  StringEncoding&lt;BagOfWordsEncodingPolicy, StringEncodingDictionary&lt;TokenType&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>BagOfWordsEncoding</name>
        <briefdescription>
<para>A convenient alias for the <ref refid="classmlpack_1_1data_1_1StringEncoding" kindref="compound">StringEncoding</ref> class with <ref refid="classmlpack_1_1data_1_1BagOfWordsEncodingPolicy" kindref="compound">BagOfWordsEncodingPolicy</ref> and the default dictionary for the given token type. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>TokenType</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the tokens. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/data/string_encoding_policies/bag_of_words_encoding_policy.hpp" line="166" column="1" bodyfile="/home/aakash/mlpack/src/mlpack/core/data/string_encoding_policies/bag_of_words_encoding_policy.hpp" bodystart="167" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacemlpack_1_1data_1aa243ad7e4d29363b858bbc92b732921d" prot="public" static="no">
        <type><ref refid="classmlpack_1_1data_1_1DatasetMapper" kindref="compound">DatasetMapper</ref>&lt; <ref refid="classmlpack_1_1data_1_1IncrementPolicy" kindref="compound">data::IncrementPolicy</ref> &gt;</type>
        <definition>typedef DatasetMapper&lt; IncrementPolicy, std::string &gt; DatasetInfo</definition>
        <argsstring></argsstring>
        <name>DatasetInfo</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/data/dataset_mapper.hpp" line="196" column="1" bodyfile="/home/aakash/mlpack/src/mlpack/core/data/dataset_mapper.hpp" bodystart="196" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacemlpack_1_1data_1aaa7ca4dc9e2a0d1189d7717b98c01933" prot="public" static="no">
        <type><ref refid="classmlpack_1_1data_1_1StringEncoding" kindref="compound">StringEncoding</ref>&lt; <ref refid="classmlpack_1_1data_1_1DictionaryEncodingPolicy" kindref="compound">DictionaryEncodingPolicy</ref>, <ref refid="classmlpack_1_1data_1_1StringEncodingDictionary" kindref="compound">StringEncodingDictionary</ref>&lt; TokenType &gt; &gt;</type>
        <definition>using DictionaryEncoding =  StringEncoding&lt;DictionaryEncodingPolicy, StringEncodingDictionary&lt;TokenType&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>DictionaryEncoding</name>
        <briefdescription>
<para>A convenient alias for the <ref refid="classmlpack_1_1data_1_1StringEncoding" kindref="compound">StringEncoding</ref> class with <ref refid="classmlpack_1_1data_1_1DictionaryEncodingPolicy" kindref="compound">DictionaryEncodingPolicy</ref> and the default dictionary for the given token type. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>TokenType</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the tokens. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/data/string_encoding_policies/dictionary_encoding_policy.hpp" line="145" column="1" bodyfile="/home/aakash/mlpack/src/mlpack/core/data/string_encoding_policies/dictionary_encoding_policy.hpp" bodystart="146" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacemlpack_1_1data_1adc64c1431b690f470d4949729d31191f" prot="public" static="no">
        <type><ref refid="classmlpack_1_1data_1_1StringEncoding" kindref="compound">StringEncoding</ref>&lt; <ref refid="classmlpack_1_1data_1_1TfIdfEncodingPolicy" kindref="compound">TfIdfEncodingPolicy</ref>, <ref refid="classmlpack_1_1data_1_1StringEncodingDictionary" kindref="compound">StringEncodingDictionary</ref>&lt; TokenType &gt; &gt;</type>
        <definition>using TfIdfEncoding =  StringEncoding&lt;TfIdfEncodingPolicy, StringEncodingDictionary&lt;TokenType&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>TfIdfEncoding</name>
        <briefdescription>
<para>A convenient alias for the <ref refid="classmlpack_1_1data_1_1StringEncoding" kindref="compound">StringEncoding</ref> class with <ref refid="classmlpack_1_1data_1_1TfIdfEncodingPolicy" kindref="compound">TfIdfEncodingPolicy</ref> and the default dictionary for the given token type. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>TokenType</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the tokens. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/data/string_encoding_policies/tf_idf_encoding_policy.hpp" line="344" column="1" bodyfile="/home/aakash/mlpack/src/mlpack/core/data/string_encoding_policies/tf_idf_encoding_policy.hpp" bodystart="345" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="namespacemlpack_1_1data_1aa47724fc0e8e354c6ca18818d81705a3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>arma::file_type</type>
        <definition>arma::file_type mlpack::data::AutoDetect</definition>
        <argsstring>(std::fstream &amp;stream, const std::string &amp;filename)</argsstring>
        <name>AutoDetect</name>
        <param>
          <type>std::fstream &amp;</type>
          <declname>stream</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>filename</declname>
        </param>
        <briefdescription>
<para>Attempt to auto-detect the type of a file given its extension, and by inspecting the parts of the file to disambiguate between types when necessary. </para>        </briefdescription>
        <detaileddescription>
<para>(For instance, a .csv file could be delimited by spaces, commas, or tabs.) This is meant to be used during loading.</para><para>If the file is detected as a CSV, and the CSV is detected to have a header row, <computeroutput>stream</computeroutput> will be fast-forwarded to point at the second line of the file.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>stream</parametername>
</parameternamelist>
<parameterdescription>
<para>Opened file stream to look into for autodetection. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>filename</parametername>
</parameternamelist>
<parameterdescription>
<para>Name of the file. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The detected file type. arma::file_type_unknown if unknown. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/data/detect_file_type.hpp" line="54" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacemlpack_1_1data_1a28da72e55467d0872681827b30b490ac" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void mlpack::data::Binarize</definition>
        <argsstring>(const arma::Mat&lt; T &gt; &amp;input, arma::Mat&lt; T &gt; &amp;output, const double threshold)</argsstring>
        <name>Binarize</name>
        <param>
          <type>const arma::Mat&lt; T &gt; &amp;</type>
          <declname>input</declname>
        </param>
        <param>
          <type>arma::Mat&lt; T &gt; &amp;</type>
          <declname>output</declname>
        </param>
        <param>
          <type>const double</type>
          <declname>threshold</declname>
        </param>
        <briefdescription>
<para>Given an input dataset and threshold, set values greater than threshold to 1 and values less than or equal to the threshold to 0. </para>        </briefdescription>
        <detaileddescription>
<para>This overload applies the changes to all dimensions.</para><para><programlisting><codeline><highlight class="normal">arma::Mat&lt;double&gt;<sp/>input<sp/>=<sp/>loadData();</highlight></codeline>
<codeline><highlight class="normal">arma::Mat&lt;double&gt;<sp/>output;</highlight></codeline>
<codeline><highlight class="normal">double<sp/>threshold<sp/>=<sp/>0.5;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Binarize<sp/>the<sp/>whole<sp/>Matrix.<sp/>All<sp/>positive<sp/>values<sp/>in<sp/>will<sp/>be<sp/>set<sp/>to<sp/>1<sp/>and</highlight></codeline>
<codeline><highlight class="normal">//<sp/>the<sp/>values<sp/>less<sp/>than<sp/>or<sp/>equal<sp/>to<sp/>0.5<sp/>will<sp/>become<sp/>0.</highlight></codeline>
<codeline><highlight class="normal">Binarize&lt;double&gt;(input,<sp/>output,<sp/>threshold);</highlight></codeline>
</programlisting></para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>input</parametername>
</parameternamelist>
<parameterdescription>
<para>Input matrix to Binarize. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>output</parametername>
</parameternamelist>
<parameterdescription>
<para>Matrix you want to save binarized data into. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>threshold</parametername>
</parameternamelist>
<parameterdescription>
<para>Threshold can by any number. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/data/binarize.hpp" line="41" column="1" bodyfile="/home/aakash/mlpack/src/mlpack/core/data/binarize.hpp" bodystart="41" bodyend="53"/>
        <references refid="prereqs_8hpp_1aabfb1575af92c0bf8bcaafdf1bfffb87" compoundref="prereqs_8hpp" startline="137">omp_size_t</references>
      </memberdef>
      <memberdef kind="function" id="namespacemlpack_1_1data_1a39606420520e81f5e87d6ea1e64c27ae" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void mlpack::data::Binarize</definition>
        <argsstring>(const arma::Mat&lt; T &gt; &amp;input, arma::Mat&lt; T &gt; &amp;output, const double threshold, const size_t dimension)</argsstring>
        <name>Binarize</name>
        <param>
          <type>const arma::Mat&lt; T &gt; &amp;</type>
          <declname>input</declname>
        </param>
        <param>
          <type>arma::Mat&lt; T &gt; &amp;</type>
          <declname>output</declname>
        </param>
        <param>
          <type>const double</type>
          <declname>threshold</declname>
        </param>
        <param>
          <type>const size_t</type>
          <declname>dimension</declname>
        </param>
        <briefdescription>
<para>Given an input dataset and threshold, set values greater than threshold to 1 and values less than or equal to the threshold to 0. </para>        </briefdescription>
        <detaileddescription>
<para>This overload takes a dimension and applys the changes to the given dimension.</para><para><programlisting><codeline><highlight class="normal">arma::Mat&lt;double&gt;<sp/>input<sp/>=<sp/>loadData();</highlight></codeline>
<codeline><highlight class="normal">arma::Mat&lt;double&gt;<sp/>output;</highlight></codeline>
<codeline><highlight class="normal">double<sp/>threshold<sp/>=<sp/>0.5;</highlight></codeline>
<codeline><highlight class="normal">size_t<sp/>dimension<sp/>=<sp/>0;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Binarize<sp/>the<sp/>first<sp/>dimension.<sp/>All<sp/>positive<sp/>values<sp/>in<sp/>the<sp/>first<sp/>dimension</highlight></codeline>
<codeline><highlight class="normal">//<sp/>will<sp/>be<sp/>set<sp/>to<sp/>1<sp/>and<sp/>the<sp/>values<sp/>less<sp/>than<sp/>or<sp/>equal<sp/>to<sp/>0<sp/>will<sp/>become<sp/>0.</highlight></codeline>
<codeline><highlight class="normal">Binarize&lt;double&gt;(input,<sp/>output,<sp/>threshold,<sp/>dimension);</highlight></codeline>
</programlisting></para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>input</parametername>
</parameternamelist>
<parameterdescription>
<para>Input matrix to Binarize. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>output</parametername>
</parameternamelist>
<parameterdescription>
<para>Matrix you want to save binarized data into. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>threshold</parametername>
</parameternamelist>
<parameterdescription>
<para>Threshold can by any number. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dimension</parametername>
</parameternamelist>
<parameterdescription>
<para>Feature to apply the Binarize function. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/data/binarize.hpp" line="77" column="1" bodyfile="/home/aakash/mlpack/src/mlpack/core/data/binarize.hpp" bodystart="77" bodyend="87"/>
        <references refid="prereqs_8hpp_1aabfb1575af92c0bf8bcaafdf1bfffb87" compoundref="prereqs_8hpp" startline="137">omp_size_t</references>
      </memberdef>
      <memberdef kind="function" id="namespacemlpack_1_1data_1a3bb1b3de86790e53265efa63e5965d41" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename eT</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void mlpack::data::ConfusionMatrix</definition>
        <argsstring>(const arma::Row&lt; size_t &gt; predictors, const arma::Row&lt; size_t &gt; responses, arma::Mat&lt; eT &gt; &amp;output, const size_t numClasses)</argsstring>
        <name>ConfusionMatrix</name>
        <param>
          <type>const arma::Row&lt; size_t &gt;</type>
          <declname>predictors</declname>
        </param>
        <param>
          <type>const arma::Row&lt; size_t &gt;</type>
          <declname>responses</declname>
        </param>
        <param>
          <type>arma::Mat&lt; eT &gt; &amp;</type>
          <declname>output</declname>
        </param>
        <param>
          <type>const size_t</type>
          <declname>numClasses</declname>
        </param>
        <briefdescription>
<para>A confusion matrix is a summary of prediction results on a classification problem. </para>        </briefdescription>
        <detaileddescription>
<para>The number of correct and incorrect predictions are summarized by count and broken down by each class. For example, for 2 classes, the function call will be</para><para><programlisting><codeline><highlight class="normal">ConfusionMatrix(predictors,<sp/>responses,<sp/>output,<sp/>2)</highlight></codeline>
</programlisting></para><para>In this case, the output matrix will be of size 2 * 2:</para><para><programlisting><codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>0<sp/><sp/><sp/><sp/><sp/>1</highlight></codeline>
<codeline><highlight class="normal">0<sp/><sp/><sp/><sp/>TP<sp/><sp/><sp/><sp/>FN</highlight></codeline>
<codeline><highlight class="normal">1<sp/><sp/><sp/><sp/>FP<sp/><sp/><sp/><sp/>TN</highlight></codeline>
</programlisting></para><para>The confusion matrix for two labels will look like what is shown above. In this confusion matrix, TP represents the number of true positives, FP represents the number of false positives, FN represents the number of false negatives, and TN represents the number of true negatives.</para><para>When generalizing to 2 or more classes, the row index of the confusion matrix represents the predicted classes and column index represents the actual class.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>predictors</parametername>
</parameternamelist>
<parameterdescription>
<para>Vector of data points. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>responses</parametername>
</parameternamelist>
<parameterdescription>
<para>The measured data for each point. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>output</parametername>
</parameternamelist>
<parameterdescription>
<para>Matrix which is represented as confusion matrix. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>numClasses</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of classes. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/data/confusion_matrix.hpp" line="54" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacemlpack_1_1data_1ac3115b81a148283970b530603b3f2aaa" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>arma::file_type</type>
        <definition>arma::file_type mlpack::data::DetectFromExtension</definition>
        <argsstring>(const std::string &amp;filename)</argsstring>
        <name>DetectFromExtension</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>filename</declname>
        </param>
        <briefdescription>
<para>Return the type based only on the extension. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>filename</parametername>
</parameternamelist>
<parameterdescription>
<para>Name of the file whose type we should detect. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Detected type of file. arma::file_type_unknown if unknown. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/data/detect_file_type.hpp" line="63" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacemlpack_1_1data_1a5a13b28050a64b446916c067e1466951" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string mlpack::data::Extension</definition>
        <argsstring>(const std::string &amp;filename)</argsstring>
        <name>Extension</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>filename</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/data/extension.hpp" line="21" column="1" bodyfile="/home/aakash/mlpack/src/mlpack/core/data/extension.hpp" bodystart="21" bodyend="33"/>
      </memberdef>
      <memberdef kind="function" id="namespacemlpack_1_1data_1a898633566d45ba664faacc815915e416" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string mlpack::data::GetStringType</definition>
        <argsstring>(const arma::file_type &amp;type)</argsstring>
        <name>GetStringType</name>
        <param>
          <type>const arma::file_type &amp;</type>
          <declname>type</declname>
        </param>
        <briefdescription>
<para>Given a file type, return a logical name corresponding to that file type. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>type</parametername>
</parameternamelist>
<parameterdescription>
<para>Type to get the logical name of. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/data/detect_file_type.hpp" line="26" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacemlpack_1_1data_1aa2f0956c373bd666d19e70551fecaf90" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>arma::file_type</type>
        <definition>arma::file_type mlpack::data::GuessFileType</definition>
        <argsstring>(std::istream &amp;f)</argsstring>
        <name>GuessFileType</name>
        <param>
          <type>std::istream &amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>Given an istream, attempt to guess the file type. </para>        </briefdescription>
        <detaileddescription>
<para>This is taken originally from Armadillo&apos;s function guess_file_type_internal(), but we avoid using internal Armadillo functionality.</para><para>If the file is detected as a CSV, and the CSV is detected to have a header row, the stream <computeroutput>f</computeroutput> will be fast-forwarded to point at the second line of the file.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>Opened istream to look into to guess the file type. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/data/detect_file_type.hpp" line="39" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacemlpack_1_1data_1acb5cb8a6b868db7d521f8efbe03b6728" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>mlpack::data::HAS_EXACT_METHOD_FORM</definition>
        <argsstring>(serialize, HasSerializeCheck)</argsstring>
        <name>HAS_EXACT_METHOD_FORM</name>
        <param>
          <type>serialize</type>
        </param>
        <param>
          <type>HasSerializeCheck</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/data/has_serialize.hpp" line="27" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacemlpack_1_1data_1a6814f77346f5af80d2c25ef3206713cb" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool mlpack::data::ImageFormatSupported</definition>
        <argsstring>(const std::string &amp;fileName, const bool save=false)</argsstring>
        <name>ImageFormatSupported</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>fileName</declname>
        </param>
        <param>
          <type>const bool</type>
          <declname>save</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para>Checks if the given image filename is supported. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>fileName</parametername>
</parameternamelist>
<parameterdescription>
<para>Name of the image file. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>save</parametername>
</parameternamelist>
<parameterdescription>
<para>Set to true to check if the file format can be saved, else loaded. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Boolean value indicating success if it is an image. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/data/image_info.hpp" line="29" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacemlpack_1_1data_1a3799ea79b454b97c5f79a82db6958a1b" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool mlpack::data::IsNaNInf</definition>
        <argsstring>(T &amp;val, const std::string &amp;token)</argsstring>
        <name>IsNaNInf</name>
        <param>
          <type>T &amp;</type>
          <declname>val</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>token</declname>
        </param>
        <briefdescription>
<para>See if the token is a NaN or an Inf, and if so, set the value accordingly and return a boolean representing whether or not it is. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/data/is_naninf.hpp" line="27" column="1" bodyfile="/home/aakash/mlpack/src/mlpack/core/data/is_naninf.hpp" bodystart="27" bodyend="67"/>
      </memberdef>
      <memberdef kind="function" id="namespacemlpack_1_1data_1abbff2a667bf247e00b1fc09b7ca5f831" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename eT</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool mlpack::data::Load</definition>
        <argsstring>(const std::string &amp;filename, arma::Mat&lt; eT &gt; &amp;matrix, const bool fatal=false, const bool transpose=true, const arma::file_type inputLoadType=arma::auto_detect)</argsstring>
        <name>Load</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>filename</declname>
        </param>
        <param>
          <type>arma::Mat&lt; eT &gt; &amp;</type>
          <declname>matrix</declname>
        </param>
        <param>
          <type>const bool</type>
          <declname>fatal</declname>
          <defval>false</defval>
        </param>
        <param>
          <type>const bool</type>
          <declname>transpose</declname>
          <defval>true</defval>
        </param>
        <param>
          <type>const arma::file_type</type>
          <declname>inputLoadType</declname>
          <defval>arma::auto_detect</defval>
        </param>
        <briefdescription>
<para>Loads a matrix from file, guessing the filetype from the extension. </para>        </briefdescription>
        <detaileddescription>
<para>This will transpose the matrix at load time (unless the transpose parameter is set to false).</para><para>The supported types of files are the same as found in Armadillo:</para><para><itemizedlist>
<listitem><para>CSV (arma::csv_ascii), denoted by .csv, or optionally .txt</para></listitem><listitem><para>TSV (arma::raw_ascii), denoted by .tsv, .csv, or .txt</para></listitem><listitem><para>ASCII (arma::raw_ascii), denoted by .txt</para></listitem><listitem><para>Armadillo ASCII (arma::arma_ascii), also denoted by .txt</para></listitem><listitem><para>PGM (arma::pgm_binary), denoted by .pgm</para></listitem><listitem><para>PPM (arma::ppm_binary), denoted by .ppm</para></listitem><listitem><para>Raw binary (arma::raw_binary), denoted by .bin</para></listitem><listitem><para>Armadillo binary (arma::arma_binary), denoted by .bin</para></listitem><listitem><para>HDF5 (arma::hdf5_binary), denoted by .hdf, .hdf5, .h5, or .he5</para></listitem></itemizedlist>
</para><para>By default, this function will try to automatically determine the type of file to load based on its extension and by inspecting the file. If you know the file type and want to specify it manually, override the default <computeroutput>inputLoadType</computeroutput> parameter with the correct type above (e.g. <computeroutput>arma::csv_ascii</computeroutput>.)</para><para>If the detected file type is CSV (<computeroutput>arma::csv_ascii</computeroutput>), the first row will be checked for a CSV header. If a CSV header is not detected, the first row will be treated as data; otherwise, the first row will be skipped.</para><para>If the parameter &apos;fatal&apos; is set to true, a std::runtime_error exception will be thrown if the matrix does not load successfully. The parameter &apos;transpose&apos; controls whether or not the matrix is transposed after loading. In most cases, because data is generally stored in a row-major format and mlpack requires column-major matrices, this should be left at its default value of &apos;true&apos;.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>filename</parametername>
</parameternamelist>
<parameterdescription>
<para>Name of file to load. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>matrix</parametername>
</parameternamelist>
<parameterdescription>
<para>Matrix to load contents of file into. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fatal</parametername>
</parameternamelist>
<parameterdescription>
<para>If an error should be reported as fatal (default false). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>transpose</parametername>
</parameternamelist>
<parameterdescription>
<para>If true, transpose the matrix after loading (default true). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>inputLoadType</parametername>
</parameternamelist>
<parameterdescription>
<para>Used to determine the type of file to load (default arma::auto_detect). </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Boolean value indicating success or failure of load. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/data/load.hpp" line="70" column="1"/>
        <referencedby refid="test__function__tools_8hpp_1af3fc11802c7a2b757836cbf80a027155" compoundref="test__function__tools_8hpp" startline="85" endline="106">LoadBostonHousingDataset</referencedby>
      </memberdef>
      <memberdef kind="function" id="namespacemlpack_1_1data_1a7bfd894be870a3409cc7d3b10b08d689" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename eT</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool mlpack::data::Load</definition>
        <argsstring>(const std::string &amp;filename, arma::SpMat&lt; eT &gt; &amp;matrix, const bool fatal=false, const bool transpose=true)</argsstring>
        <name>Load</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>filename</declname>
        </param>
        <param>
          <type>arma::SpMat&lt; eT &gt; &amp;</type>
          <declname>matrix</declname>
        </param>
        <param>
          <type>const bool</type>
          <declname>fatal</declname>
          <defval>false</defval>
        </param>
        <param>
          <type>const bool</type>
          <declname>transpose</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
<para>Loads a sparse matrix from file, using arma::coord_ascii format. </para>        </briefdescription>
        <detaileddescription>
<para>This will transpose the matrix at load time (unless the transpose parameter is set to false). If the filetype cannot be determined, an error will be given.</para><para>The supported types of files are the same as found in Armadillo:</para><para><itemizedlist>
<listitem><para>TSV (coord_ascii), denoted by .tsv or .txt</para></listitem><listitem><para>TXT (coord_ascii), denoted by .txt</para></listitem><listitem><para>Raw binary (raw_binary), denoted by .bin</para></listitem><listitem><para>Armadillo binary (arma_binary), denoted by .bin</para></listitem></itemizedlist>
</para><para>If the file extension is not one of those types, an error will be given. This is preferable to Armadillo&apos;s default behavior of loading an unknown filetype as raw_binary, which can have very confusing effects.</para><para>If the parameter &apos;fatal&apos; is set to true, a std::runtime_error exception will be thrown if the matrix does not load successfully. The parameter &apos;transpose&apos; controls whether or not the matrix is transposed after loading. In most cases, because data is generally stored in a row-major format and mlpack requires column-major matrices, this should be left at its default value of &apos;true&apos;.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>filename</parametername>
</parameternamelist>
<parameterdescription>
<para>Name of file to load. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>matrix</parametername>
</parameternamelist>
<parameterdescription>
<para>Sparse matrix to load contents of file into. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fatal</parametername>
</parameternamelist>
<parameterdescription>
<para>If an error should be reported as fatal (default false). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>transpose</parametername>
</parameternamelist>
<parameterdescription>
<para>If true, transpose the matrix after loading (default true). </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Boolean value indicating success or failure of load. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/data/load.hpp" line="106" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacemlpack_1_1data_1adb0c6adf83024427e47a03bd7fbfb885" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename eT</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool mlpack::data::Load</definition>
        <argsstring>(const std::string &amp;filename, arma::Col&lt; eT &gt; &amp;vec, const bool fatal=false)</argsstring>
        <name>Load</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>filename</declname>
        </param>
        <param>
          <type>arma::Col&lt; eT &gt; &amp;</type>
          <declname>vec</declname>
        </param>
        <param>
          <type>const bool</type>
          <declname>fatal</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para>Don&apos;t document these with doxygen; these declarations aren&apos;t helpful to users. </para>        </briefdescription>
        <detaileddescription>
<para>Load a column vector from a file, guessing the filetype from the extension.</para><para>The supported types of files are the same as found in Armadillo:</para><para><itemizedlist>
<listitem><para>CSV (csv_ascii), denoted by .csv, or optionally .txt</para></listitem><listitem><para>TSV (raw_ascii), denoted by .tsv, .csv, or .txt</para></listitem><listitem><para>ASCII (raw_ascii), denoted by .txt</para></listitem><listitem><para>Armadillo ASCII (arma_ascii), also denoted by .txt</para></listitem><listitem><para>PGM (pgm_binary), denoted by .pgm</para></listitem><listitem><para>PPM (ppm_binary), denoted by .ppm</para></listitem><listitem><para>Raw binary (raw_binary), denoted by .bin</para></listitem><listitem><para>Armadillo binary (arma_binary), denoted by .bin</para></listitem><listitem><para>HDF5, denoted by .hdf, .hdf5, .h5, or .he5</para></listitem></itemizedlist>
</para><para>If the file extension is not one of those types, an error will be given. This is preferable to Armadillo&apos;s default behavior of loading an unknown filetype as raw_binary, which can have very confusing effects.</para><para>If the parameter &apos;fatal&apos; is set to true, a std::runtime_error exception will be thrown if the matrix does not load successfully.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>filename</parametername>
</parameternamelist>
<parameterdescription>
<para>Name of file to load. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>vec</parametername>
</parameternamelist>
<parameterdescription>
<para>Column vector to load contents of file into. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fatal</parametername>
</parameternamelist>
<parameterdescription>
<para>If an error should be reported as fatal (default false). </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Boolean value indicating success or failure of load. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/data/load.hpp" line="218" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacemlpack_1_1data_1ac5679a4dc8c6129e3895a1089855d25d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename eT</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool mlpack::data::Load</definition>
        <argsstring>(const std::string &amp;filename, arma::Row&lt; eT &gt; &amp;rowvec, const bool fatal=false)</argsstring>
        <name>Load</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>filename</declname>
        </param>
        <param>
          <type>arma::Row&lt; eT &gt; &amp;</type>
          <declname>rowvec</declname>
        </param>
        <param>
          <type>const bool</type>
          <declname>fatal</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para>Load a row vector from a file, guessing the filetype from the extension. </para>        </briefdescription>
        <detaileddescription>
<para>The supported types of files are the same as found in Armadillo:</para><para><itemizedlist>
<listitem><para>CSV (csv_ascii), denoted by .csv, or optionally .txt</para></listitem><listitem><para>TSV (raw_ascii), denoted by .tsv, .csv, or .txt</para></listitem><listitem><para>ASCII (raw_ascii), denoted by .txt</para></listitem><listitem><para>Armadillo ASCII (arma_ascii), also denoted by .txt</para></listitem><listitem><para>PGM (pgm_binary), denoted by .pgm</para></listitem><listitem><para>PPM (ppm_binary), denoted by .ppm</para></listitem><listitem><para>Raw binary (raw_binary), denoted by .bin</para></listitem><listitem><para>Armadillo binary (arma_binary), denoted by .bin</para></listitem><listitem><para>HDF5, denoted by .hdf, .hdf5, .h5, or .he5</para></listitem></itemizedlist>
</para><para>If the file extension is not one of those types, an error will be given. This is preferable to Armadillo&apos;s default behavior of loading an unknown filetype as raw_binary, which can have very confusing effects.</para><para>If the parameter &apos;fatal&apos; is set to true, a std::runtime_error exception will be thrown if the matrix does not load successfully.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>filename</parametername>
</parameternamelist>
<parameterdescription>
<para>Name of file to load. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rowvec</parametername>
</parameternamelist>
<parameterdescription>
<para>Row vector to load contents of file into. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fatal</parametername>
</parameternamelist>
<parameterdescription>
<para>If an error should be reported as fatal (default false). </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Boolean value indicating success or failure of load. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/data/load.hpp" line="250" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacemlpack_1_1data_1a9af06d46f91871c42f38e30aac5d4666" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename eT</type>
          </param>
          <param>
            <type>typename PolicyType</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool mlpack::data::Load</definition>
        <argsstring>(const std::string &amp;filename, arma::Mat&lt; eT &gt; &amp;matrix, DatasetMapper&lt; PolicyType &gt; &amp;info, const bool fatal=false, const bool transpose=true)</argsstring>
        <name>Load</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>filename</declname>
        </param>
        <param>
          <type>arma::Mat&lt; eT &gt; &amp;</type>
          <declname>matrix</declname>
        </param>
        <param>
          <type><ref refid="classmlpack_1_1data_1_1DatasetMapper" kindref="compound">DatasetMapper</ref>&lt; PolicyType &gt; &amp;</type>
          <declname>info</declname>
        </param>
        <param>
          <type>const bool</type>
          <declname>fatal</declname>
          <defval>false</defval>
        </param>
        <param>
          <type>const bool</type>
          <declname>transpose</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
<para>Loads a matrix from a file, guessing the filetype from the extension and mapping categorical features with a <ref refid="classmlpack_1_1data_1_1DatasetMapper" kindref="compound">DatasetMapper</ref> object. </para>        </briefdescription>
        <detaileddescription>
<para>This will transpose the matrix (unless the transpose parameter is set to false). This particular overload of <ref refid="namespacemlpack_1_1data_1abbff2a667bf247e00b1fc09b7ca5f831" kindref="member">Load()</ref> can only load text-based formats, such as those given below:</para><para><itemizedlist>
<listitem><para>CSV (csv_ascii), denoted by .csv, or optionally .txt</para></listitem><listitem><para>TSV (raw_ascii), denoted by .tsv, .csv, or .txt</para></listitem><listitem><para>ASCII (raw_ascii), denoted by .txt</para></listitem></itemizedlist>
</para><para>If the file extension is not one of those types, an error will be given. This is preferable to Armadillo&apos;s default behavior of loading an unknown filetype as raw_binary, which can have very confusing effects.</para><para>If the parameter &apos;fatal&apos; is set to true, a std::runtime_error exception will be thrown if the matrix does not load successfully. The parameter &apos;transpose&apos; controls whether or not the matrix is transposed after loading. In most cases, because data is generally stored in a row-major format and mlpack requires column-major matrices, this should be left at its default value of &apos;true&apos;.</para><para>If the given <computeroutput>info</computeroutput> has already been used with a different <computeroutput><ref refid="namespacemlpack_1_1data_1abbff2a667bf247e00b1fc09b7ca5f831" kindref="member">data::Load()</ref></computeroutput> call where the dataset has the same dimensionality, then the mappings and dimension types inside of <computeroutput>info</computeroutput> will be <emphasis>re-used</emphasis>. If the given <computeroutput>info</computeroutput> is a new <computeroutput><ref refid="classmlpack_1_1data_1_1DatasetMapper" kindref="compound">DatasetMapper</ref></computeroutput> object (e.g. its dimensionality is 0), then new mappings will be created. If the given <computeroutput>info</computeroutput> has a different dimensionality of data than what is present in <computeroutput>filename</computeroutput>, an exception will be thrown.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>filename</parametername>
</parameternamelist>
<parameterdescription>
<para>Name of file to load. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>matrix</parametername>
</parameternamelist>
<parameterdescription>
<para>Matrix to load contents of file into. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>info</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classmlpack_1_1data_1_1DatasetMapper" kindref="compound">DatasetMapper</ref> object to populate with mappings and data types. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fatal</parametername>
</parameternamelist>
<parameterdescription>
<para>If an error should be reported as fatal (default false). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>transpose</parametername>
</parameternamelist>
<parameterdescription>
<para>If true, transpose the matrix after loading. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Boolean value indicating success or failure of load. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/data/load.hpp" line="291" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacemlpack_1_1data_1ac0441d5f7e76f0fcdeec487d4a9732ac" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool mlpack::data::Load</definition>
        <argsstring>(const std::string &amp;filename, const std::string &amp;name, T &amp;t, const bool fatal=false, format f=format::autodetect)</argsstring>
        <name>Load</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>filename</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>name</declname>
        </param>
        <param>
          <type>T &amp;</type>
          <declname>t</declname>
        </param>
        <param>
          <type>const bool</type>
          <declname>fatal</declname>
          <defval>false</defval>
        </param>
        <param>
          <type><ref refid="namespacemlpack_1_1data_1a387137c43ed9616d39ba90e890d181eb" kindref="member">format</ref></type>
          <declname>f</declname>
          <defval>format::autodetect</defval>
        </param>
        <briefdescription>
<para>Don&apos;t document these with doxygen; they aren&apos;t helpful for users to know about. </para>        </briefdescription>
        <detaileddescription>
<para>Load a model from a file, guessing the filetype from the extension, or, optionally, loading the specified format. If automatic extension detection is used and the filetype cannot be determined, an error will be given.</para><para>The supported types of files are the same as what is supported by the cereal library:</para><para><itemizedlist>
<listitem><para>json, denoted by .json</para></listitem><listitem><para>xml, denoted by .xml</para></listitem><listitem><para>binary, denoted by .bin</para></listitem></itemizedlist>
</para><para>The format parameter can take any of the values in the &apos;format&apos; enum: &apos;format::autodetect&apos;, &apos;format::json&apos;, &apos;format::xml&apos;, and &apos;format::binary&apos;. The autodetect functionality operates on the file extension (so, &quot;file.txt&quot; would be autodetected as text).</para><para>The name parameter should be specified to indicate the name of the structure to be loaded. This should be the same as the name that was used to save the structure (otherwise, the loading procedure will fail).</para><para>If the parameter &apos;fatal&apos; is set to true, then an exception will be thrown in the event of load failure. Otherwise, the method will return false and the relevant error information will be printed to Log::Warn. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/data/load.hpp" line="369" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacemlpack_1_1data_1aa05aba27ed8693c1c4ed538240a549b1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename eT</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool mlpack::data::Load</definition>
        <argsstring>(const std::string &amp;filename, arma::Mat&lt; eT &gt; &amp;matrix, ImageInfo &amp;info, const bool fatal=false)</argsstring>
        <name>Load</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>filename</declname>
        </param>
        <param>
          <type>arma::Mat&lt; eT &gt; &amp;</type>
          <declname>matrix</declname>
        </param>
        <param>
          <type><ref refid="classmlpack_1_1data_1_1ImageInfo" kindref="compound">ImageInfo</ref> &amp;</type>
          <declname>info</declname>
        </param>
        <param>
          <type>const bool</type>
          <declname>fatal</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para>Image load/save interfaces. </para>        </briefdescription>
        <detaileddescription>
<para>Load the image file into the given matrix.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>filename</parametername>
</parameternamelist>
<parameterdescription>
<para>Name of the image file. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>matrix</parametername>
</parameternamelist>
<parameterdescription>
<para>Matrix to load the image into. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>info</parametername>
</parameternamelist>
<parameterdescription>
<para>An object of <ref refid="classmlpack_1_1data_1_1ImageInfo" kindref="compound">ImageInfo</ref> class. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fatal</parametername>
</parameternamelist>
<parameterdescription>
<para>If an error should be reported as fatal (default false). </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Boolean value indicating success or failure of load. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/data/load.hpp" line="389" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacemlpack_1_1data_1adf6afb44303645116a32d1ed168e0ff1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename eT</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool mlpack::data::Load</definition>
        <argsstring>(const std::vector&lt; std::string &gt; &amp;files, arma::Mat&lt; eT &gt; &amp;matrix, ImageInfo &amp;info, const bool fatal=false)</argsstring>
        <name>Load</name>
        <param>
          <type>const std::vector&lt; std::string &gt; &amp;</type>
          <declname>files</declname>
        </param>
        <param>
          <type>arma::Mat&lt; eT &gt; &amp;</type>
          <declname>matrix</declname>
        </param>
        <param>
          <type><ref refid="classmlpack_1_1data_1_1ImageInfo" kindref="compound">ImageInfo</ref> &amp;</type>
          <declname>info</declname>
        </param>
        <param>
          <type>const bool</type>
          <declname>fatal</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para>Load the image file into the given matrix. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>files</parametername>
</parameternamelist>
<parameterdescription>
<para>A vector consisting of filenames. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>matrix</parametername>
</parameternamelist>
<parameterdescription>
<para>Matrix to save the image from. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>info</parametername>
</parameternamelist>
<parameterdescription>
<para>An object of <ref refid="classmlpack_1_1data_1_1ImageInfo" kindref="compound">ImageInfo</ref> class. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fatal</parametername>
</parameternamelist>
<parameterdescription>
<para>If an error should be reported as fatal (default false). </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Boolean value indicating success or failure of load. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/data/load.hpp" line="404" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacemlpack_1_1data_1a951a7dc1fd86524b8dd245bb91841731" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename eT</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void mlpack::data::LoadARFF</definition>
        <argsstring>(const std::string &amp;filename, arma::Mat&lt; eT &gt; &amp;matrix)</argsstring>
        <name>LoadARFF</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>filename</declname>
        </param>
        <param>
          <type>arma::Mat&lt; eT &gt; &amp;</type>
          <declname>matrix</declname>
        </param>
        <briefdescription>
<para>A utility function to load an ARFF dataset as numeric features (that is, as an Armadillo matrix without any modification). </para>        </briefdescription>
        <detaileddescription>
<para>An exception will be thrown if any features are non-numeric. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/data/load_arff.hpp" line="28" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacemlpack_1_1data_1aa2a4a09a274c068e08373200fe611422" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename eT</type>
          </param>
          <param>
            <type>typename PolicyType</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void mlpack::data::LoadARFF</definition>
        <argsstring>(const std::string &amp;filename, arma::Mat&lt; eT &gt; &amp;matrix, DatasetMapper&lt; PolicyType &gt; &amp;info)</argsstring>
        <name>LoadARFF</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>filename</declname>
        </param>
        <param>
          <type>arma::Mat&lt; eT &gt; &amp;</type>
          <declname>matrix</declname>
        </param>
        <param>
          <type><ref refid="classmlpack_1_1data_1_1DatasetMapper" kindref="compound">DatasetMapper</ref>&lt; PolicyType &gt; &amp;</type>
          <declname>info</declname>
        </param>
        <briefdescription>
<para>A utility function to load an ARFF dataset as numeric and categorical features, using the DatasetInfo structure for mapping. </para>        </briefdescription>
        <detaileddescription>
<para>An exception will be thrown upon failure.</para><para>A pre-existing DatasetInfo object can be passed in, but if the dimensionality of the given DatasetInfo object (info.Dimensionality()) does not match the dimensionality of the data, a std::invalid_argument exception will be thrown. If an empty DatasetInfo object is given (constructed with the default constructor or otherwise, so that info.Dimensionality() is 0), it will be set to the right dimensionality.</para><para>This ability to pass in pre-existing DatasetInfo objects is very necessary when, e.g., loading a test set after training. If the same DatasetInfo from loading the training set is not used, then the test set may be loaded with different mappings<mdash/>which can cause horrible problems!</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>filename</parametername>
</parameternamelist>
<parameterdescription>
<para>Name of ARFF file to load. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>matrix</parametername>
</parameternamelist>
<parameterdescription>
<para>Matrix to load data into. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>info</parametername>
</parameternamelist>
<parameterdescription>
<para>DatasetInfo object; can be default-constructed or pre-existing from another call to <ref refid="namespacemlpack_1_1data_1a951a7dc1fd86524b8dd245bb91841731" kindref="member">LoadARFF()</ref>. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/data/load_arff.hpp" line="53" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacemlpack_1_1data_1a01155770d761c5cf686a666f3622caa5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool mlpack::data::LoadImage</definition>
        <argsstring>(const std::string &amp;filename, arma::Mat&lt; unsigned char &gt; &amp;matrix, ImageInfo &amp;info, const bool fatal=false)</argsstring>
        <name>LoadImage</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>filename</declname>
        </param>
        <param>
          <type>arma::Mat&lt; unsigned char &gt; &amp;</type>
          <declname>matrix</declname>
        </param>
        <param>
          <type><ref refid="classmlpack_1_1data_1_1ImageInfo" kindref="compound">ImageInfo</ref> &amp;</type>
          <declname>info</declname>
        </param>
        <param>
          <type>const bool</type>
          <declname>fatal</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/data/load.hpp" line="410" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacemlpack_1_1data_1a664b3fa5243889e2aed47ee750f840ed" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename eT</type>
          </param>
          <param>
            <type>typename RowType</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void mlpack::data::NormalizeLabels</definition>
        <argsstring>(const RowType &amp;labelsIn, arma::Row&lt; size_t &gt; &amp;labels, arma::Col&lt; eT &gt; &amp;mapping)</argsstring>
        <name>NormalizeLabels</name>
        <param>
          <type>const RowType &amp;</type>
          <declname>labelsIn</declname>
        </param>
        <param>
          <type>arma::Row&lt; size_t &gt; &amp;</type>
          <declname>labels</declname>
        </param>
        <param>
          <type>arma::Col&lt; eT &gt; &amp;</type>
          <declname>mapping</declname>
        </param>
        <briefdescription>
<para>Given a set of labels of a particular datatype, convert them to unsigned labels in the range [0, n) where n is the number of different labels. </para>        </briefdescription>
        <detaileddescription>
<para>Also, a reverse mapping from the new label to the old value is stored in the &apos;mapping&apos; vector.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>labelsIn</parametername>
</parameternamelist>
<parameterdescription>
<para>Input labels of arbitrary datatype. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>labels</parametername>
</parameternamelist>
<parameterdescription>
<para>Vector that unsigned labels will be stored in. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mapping</parametername>
</parameternamelist>
<parameterdescription>
<para>Reverse mapping to convert new labels back to old labels. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/data/normalize_labels.hpp" line="33" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacemlpack_1_1data_1a0d41d92266983ceb192346478a54ec23" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename RowType</type>
          </param>
          <param>
            <type>typename MatType</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void mlpack::data::OneHotEncoding</definition>
        <argsstring>(const RowType &amp;labelsIn, MatType &amp;output)</argsstring>
        <name>OneHotEncoding</name>
        <param>
          <type>const RowType &amp;</type>
          <declname>labelsIn</declname>
        </param>
        <param>
          <type>MatType &amp;</type>
          <declname>output</declname>
        </param>
        <briefdescription>
<para>Given a set of labels of a particular datatype, convert them to binary vector. </para>        </briefdescription>
        <detaileddescription>
<para>The categorical values be mapped to integer values. Then, each integer value is represented as a binary vector that is all zero values except the index of the integer, which is marked with a 1.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>labelsIn</parametername>
</parameternamelist>
<parameterdescription>
<para>Input labels of arbitrary datatype. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>output</parametername>
</parameternamelist>
<parameterdescription>
<para>Binary matrix. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/data/one_hot_encoding.hpp" line="33" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacemlpack_1_1data_1a91f3e880da9955942bd129414fe617a9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename eT</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void mlpack::data::OneHotEncoding</definition>
        <argsstring>(const arma::Mat&lt; eT &gt; &amp;input, const arma::Col&lt; size_t &gt; &amp;indices, arma::Mat&lt; eT &gt; &amp;output)</argsstring>
        <name>OneHotEncoding</name>
        <param>
          <type>const arma::Mat&lt; eT &gt; &amp;</type>
          <declname>input</declname>
        </param>
        <param>
          <type>const arma::Col&lt; size_t &gt; &amp;</type>
          <declname>indices</declname>
        </param>
        <param>
          <type>arma::Mat&lt; eT &gt; &amp;</type>
          <declname>output</declname>
        </param>
        <briefdescription>
<para>Overloaded function for the above function, which takes a matrix as input and also a vector of indices to encode and outputs a matrix. </para>        </briefdescription>
        <detaileddescription>
<para>Indices represent the IDs of the dimensions to be one-hot encoded.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>input</parametername>
</parameternamelist>
<parameterdescription>
<para>Input dataset to be encoded. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>indices</parametername>
</parameternamelist>
<parameterdescription>
<para>Index of rows to be encoded. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>output</parametername>
</parameternamelist>
<parameterdescription>
<para>Encoded matrix. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/data/one_hot_encoding.hpp" line="46" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacemlpack_1_1data_1a007765ae6ce1f59513e6644bd2c66988" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename eT</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void mlpack::data::OneHotEncoding</definition>
        <argsstring>(const arma::Mat&lt; eT &gt; &amp;input, arma::Mat&lt; eT &gt; &amp;output, const data::DatasetInfo &amp;datasetInfo)</argsstring>
        <name>OneHotEncoding</name>
        <param>
          <type>const arma::Mat&lt; eT &gt; &amp;</type>
          <declname>input</declname>
        </param>
        <param>
          <type>arma::Mat&lt; eT &gt; &amp;</type>
          <declname>output</declname>
        </param>
        <param>
          <type>const <ref refid="namespacemlpack_1_1data_1aa243ad7e4d29363b858bbc92b732921d" kindref="member">data::DatasetInfo</ref> &amp;</type>
          <declname>datasetInfo</declname>
        </param>
        <briefdescription>
<para>Overloaded function for the above function, which takes a matrix as input and also a DatasetInfo object and outputs a matrix. </para>        </briefdescription>
        <detaileddescription>
<para>This function encodes all the dimensions marked <computeroutput>Datatype::categorical</computeroutput> in the <ref refid="namespacemlpack_1_1data_1aa243ad7e4d29363b858bbc92b732921d" kindref="member">data::DatasetInfo</ref>.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>input</parametername>
</parameternamelist>
<parameterdescription>
<para>Input dataset to be encoded. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>output</parametername>
</parameternamelist>
<parameterdescription>
<para>Encoded matrix. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>datasetInfo</parametername>
</parameternamelist>
<parameterdescription>
<para>DatasetInfo object that has information about data. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/data/one_hot_encoding.hpp" line="61" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacemlpack_1_1data_1a901fe08dcdc58734f64a864dbdef0a28" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename eT</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void mlpack::data::RevertLabels</definition>
        <argsstring>(const arma::Row&lt; size_t &gt; &amp;labels, const arma::Col&lt; eT &gt; &amp;mapping, arma::Row&lt; eT &gt; &amp;labelsOut)</argsstring>
        <name>RevertLabels</name>
        <param>
          <type>const arma::Row&lt; size_t &gt; &amp;</type>
          <declname>labels</declname>
        </param>
        <param>
          <type>const arma::Col&lt; eT &gt; &amp;</type>
          <declname>mapping</declname>
        </param>
        <param>
          <type>arma::Row&lt; eT &gt; &amp;</type>
          <declname>labelsOut</declname>
        </param>
        <briefdescription>
<para>Given a set of labels that have been mapped to the range [0, n), map them back to the original labels given by the &apos;mapping&apos; vector. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>labels</parametername>
</parameternamelist>
<parameterdescription>
<para>Set of normalized labels to convert. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mapping</parametername>
</parameternamelist>
<parameterdescription>
<para>Mapping to use to convert labels. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>labelsOut</parametername>
</parameternamelist>
<parameterdescription>
<para>Vector to store new labels in. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/data/normalize_labels.hpp" line="46" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacemlpack_1_1data_1accd1605a1d160c09ee75c93a587dc313" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename eT</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool mlpack::data::Save</definition>
        <argsstring>(const std::string &amp;filename, const arma::Mat&lt; eT &gt; &amp;matrix, const bool fatal=false, bool transpose=true, arma::file_type inputSaveType=arma::auto_detect)</argsstring>
        <name>Save</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>filename</declname>
        </param>
        <param>
          <type>const arma::Mat&lt; eT &gt; &amp;</type>
          <declname>matrix</declname>
        </param>
        <param>
          <type>const bool</type>
          <declname>fatal</declname>
          <defval>false</defval>
        </param>
        <param>
          <type>bool</type>
          <declname>transpose</declname>
          <defval>true</defval>
        </param>
        <param>
          <type>arma::file_type</type>
          <declname>inputSaveType</declname>
          <defval>arma::auto_detect</defval>
        </param>
        <briefdescription>
<para>Saves a matrix to file, guessing the filetype from the extension. </para>        </briefdescription>
        <detaileddescription>
<para>This will transpose the matrix at save time. If the filetype cannot be determined, an error will be given.</para><para>The supported types of files are the same as found in Armadillo:</para><para><itemizedlist>
<listitem><para>CSV (arma::csv_ascii), denoted by .csv, or optionally .txt</para></listitem><listitem><para>ASCII (arma::raw_ascii), denoted by .txt</para></listitem><listitem><para>Armadillo ASCII (arma::arma_ascii), also denoted by .txt</para></listitem><listitem><para>PGM (arma::pgm_binary), denoted by .pgm</para></listitem><listitem><para>PPM (arma::ppm_binary), denoted by .ppm</para></listitem><listitem><para>Raw binary (arma::raw_binary), denoted by .bin</para></listitem><listitem><para>Armadillo binary (arma::arma_binary), denoted by .bin</para></listitem><listitem><para>HDF5 (arma::hdf5_binary), denoted by .hdf5, .hdf, .h5, or .he5</para></listitem></itemizedlist>
</para><para>By default, this function will try to automatically determine the format to save with based only on the filename&apos;s extension. If you would prefer to specify a file type manually, override the default <computeroutput>inputSaveType</computeroutput> parameter with the correct type above (e.g. <computeroutput>arma::csv_ascii</computeroutput>.)</para><para>If the &apos;fatal&apos; parameter is set to true, a std::runtime_error exception will be thrown upon failure. If the &apos;transpose&apos; parameter is set to true, the matrix will be transposed before saving. Generally, because mlpack stores matrices in a column-major format and most datasets are stored on disk as row-major, this parameter should be left at its default value of &apos;true&apos;.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>filename</parametername>
</parameternamelist>
<parameterdescription>
<para>Name of file to save to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>matrix</parametername>
</parameternamelist>
<parameterdescription>
<para>Matrix to save into file. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fatal</parametername>
</parameternamelist>
<parameterdescription>
<para>If an error should be reported as fatal (default false). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>transpose</parametername>
</parameternamelist>
<parameterdescription>
<para>If true, transpose the matrix before saving (default true). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>inputSaveType</parametername>
</parameternamelist>
<parameterdescription>
<para>File type to save to (defaults to arma::auto_detect). </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Boolean value indicating success or failure of save. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/data/save.hpp" line="63" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacemlpack_1_1data_1ad5510cd863171eb3bc1dec000a78b482" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename eT</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool mlpack::data::Save</definition>
        <argsstring>(const std::string &amp;filename, const arma::SpMat&lt; eT &gt; &amp;matrix, const bool fatal=false, bool transpose=true)</argsstring>
        <name>Save</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>filename</declname>
        </param>
        <param>
          <type>const arma::SpMat&lt; eT &gt; &amp;</type>
          <declname>matrix</declname>
        </param>
        <param>
          <type>const bool</type>
          <declname>fatal</declname>
          <defval>false</defval>
        </param>
        <param>
          <type>bool</type>
          <declname>transpose</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
<para>Saves a sparse matrix to file, guessing the filetype from the extension. </para>        </briefdescription>
        <detaileddescription>
<para>This will transpose the matrix at save time. If the filetype cannot be determined, an error will be given.</para><para>The supported types of files are the same as found in Armadillo:</para><para><itemizedlist>
<listitem><para>TSV (coord_ascii), denoted by .tsv or .txt</para></listitem><listitem><para>TXT (coord_ascii), denoted by .txt</para></listitem><listitem><para>Raw binary (raw_binary), denoted by .bin</para></listitem><listitem><para>Armadillo binary (arma_binary), denoted by .bin</para></listitem></itemizedlist>
</para><para>If the file extension is not one of those types, an error will be given. If the &apos;fatal&apos; parameter is set to true, a std::runtime_error exception will be thrown upon failure. If the &apos;transpose&apos; parameter is set to true, the matrix will be transposed before saving. Generally, because mlpack stores matrices in a column-major format and most datasets are stored on disk as row-major, this parameter should be left at its default value of &apos;true&apos;.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>filename</parametername>
</parameternamelist>
<parameterdescription>
<para>Name of file to save to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>matrix</parametername>
</parameternamelist>
<parameterdescription>
<para>Sparse matrix to save into file. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fatal</parametername>
</parameternamelist>
<parameterdescription>
<para>If an error should be reported as fatal (default false). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>transpose</parametername>
</parameternamelist>
<parameterdescription>
<para>If true, transpose the matrix before saving (default true). </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Boolean value indicating success or failure of save. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/data/save.hpp" line="95" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacemlpack_1_1data_1af30f8bfca9b924d6d935c9f1fae91778" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool mlpack::data::Save</definition>
        <argsstring>(const std::string &amp;filename, const std::string &amp;name, T &amp;t, const bool fatal=false, format f=format::autodetect)</argsstring>
        <name>Save</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>filename</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>name</declname>
        </param>
        <param>
          <type>T &amp;</type>
          <declname>t</declname>
        </param>
        <param>
          <type>const bool</type>
          <declname>fatal</declname>
          <defval>false</defval>
        </param>
        <param>
          <type><ref refid="namespacemlpack_1_1data_1a387137c43ed9616d39ba90e890d181eb" kindref="member">format</ref></type>
          <declname>f</declname>
          <defval>format::autodetect</defval>
        </param>
        <briefdescription>
<para>Saves a model to file, guessing the filetype from the extension, or, optionally, saving the specified format. </para>        </briefdescription>
        <detaileddescription>
<para>If automatic extension detection is used and the filetype cannot be determined, and error will be given.</para><para>The supported types of files are the same as what is supported by the cereal library:</para><para><itemizedlist>
<listitem><para>json, denoted by .json</para></listitem><listitem><para>xml, denoted by .xml</para></listitem><listitem><para>binary, denoted by .bin</para></listitem></itemizedlist>
</para><para>The format parameter can take any of the values in the &apos;format&apos; enum: &apos;format::autodetect&apos;, &apos;format::json&apos;, &apos;format::xml&apos;, and &apos;format::binary&apos;. The autodetect functionality operates on the file extension (so, &quot;file.txt&quot; would be autodetected as text).</para><para>The name parameter should be specified to indicate the name of the structure to be saved. If <ref refid="namespacemlpack_1_1data_1abbff2a667bf247e00b1fc09b7ca5f831" kindref="member">Load()</ref> is later called on the generated file, the name used to load should be the same as the name used for this call to <ref refid="namespacemlpack_1_1data_1accd1605a1d160c09ee75c93a587dc313" kindref="member">Save()</ref>.</para><para>If the parameter &apos;fatal&apos; is set to true, then an exception will be thrown in the event of a save failure. Otherwise, the method will return false and the relevant error information will be printed to Log::Warn. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/data/save.hpp" line="126" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacemlpack_1_1data_1a255acca42390d66faaed4521eb502de8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename eT</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool mlpack::data::Save</definition>
        <argsstring>(const std::string &amp;filename, arma::Mat&lt; eT &gt; &amp;matrix, ImageInfo &amp;info, const bool fatal=false)</argsstring>
        <name>Save</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>filename</declname>
        </param>
        <param>
          <type>arma::Mat&lt; eT &gt; &amp;</type>
          <declname>matrix</declname>
        </param>
        <param>
          <type><ref refid="classmlpack_1_1data_1_1ImageInfo" kindref="compound">ImageInfo</ref> &amp;</type>
          <declname>info</declname>
        </param>
        <param>
          <type>const bool</type>
          <declname>fatal</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para>Save the image file from the given matrix. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>filename</parametername>
</parameternamelist>
<parameterdescription>
<para>Name of the image file. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>matrix</parametername>
</parameternamelist>
<parameterdescription>
<para>Matrix to save the image from. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>info</parametername>
</parameternamelist>
<parameterdescription>
<para>An object of <ref refid="classmlpack_1_1data_1_1ImageInfo" kindref="compound">ImageInfo</ref> class. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fatal</parametername>
</parameternamelist>
<parameterdescription>
<para>If an error should be reported as fatal (default false). </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Boolean value indicating success or failure of load. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/data/save.hpp" line="142" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacemlpack_1_1data_1a9402b433306b2735be417a07d8397d9c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename eT</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool mlpack::data::Save</definition>
        <argsstring>(const std::vector&lt; std::string &gt; &amp;files, arma::Mat&lt; eT &gt; &amp;matrix, ImageInfo &amp;info, const bool fatal=false)</argsstring>
        <name>Save</name>
        <param>
          <type>const std::vector&lt; std::string &gt; &amp;</type>
          <declname>files</declname>
        </param>
        <param>
          <type>arma::Mat&lt; eT &gt; &amp;</type>
          <declname>matrix</declname>
        </param>
        <param>
          <type><ref refid="classmlpack_1_1data_1_1ImageInfo" kindref="compound">ImageInfo</ref> &amp;</type>
          <declname>info</declname>
        </param>
        <param>
          <type>const bool</type>
          <declname>fatal</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para>Save the image file from the given matrix. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>files</parametername>
</parameternamelist>
<parameterdescription>
<para>A vector consisting of filenames. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>matrix</parametername>
</parameternamelist>
<parameterdescription>
<para>Matrix to save the image from. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>info</parametername>
</parameternamelist>
<parameterdescription>
<para>An object of <ref refid="classmlpack_1_1data_1_1ImageInfo" kindref="compound">ImageInfo</ref> class. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fatal</parametername>
</parameternamelist>
<parameterdescription>
<para>If an error should be reported as fatal (default false). </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Boolean value indicating success or failure of load. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/data/save.hpp" line="157" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacemlpack_1_1data_1a5053734839d456ce3bfe20b16a467d0c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool mlpack::data::SaveImage</definition>
        <argsstring>(const std::string &amp;filename, arma::Mat&lt; unsigned char &gt; &amp;image, ImageInfo &amp;info, const bool fatal=false)</argsstring>
        <name>SaveImage</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>filename</declname>
        </param>
        <param>
          <type>arma::Mat&lt; unsigned char &gt; &amp;</type>
          <declname>image</declname>
        </param>
        <param>
          <type><ref refid="classmlpack_1_1data_1_1ImageInfo" kindref="compound">ImageInfo</ref> &amp;</type>
          <declname>info</declname>
        </param>
        <param>
          <type>const bool</type>
          <declname>fatal</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para>Helper function to save files. </para>        </briefdescription>
        <detaileddescription>
<para>Implementation in save_image.cpp. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/data/save.hpp" line="165" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacemlpack_1_1data_1a32f749a2ac526fd90ab112400fad6ef2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename LabelsType</type>
          </param>
          <param>
            <type>typename</type>
            <defval><ref refid="namespacestd_1a93e9cb7fadbcfaa2afb5b94058b8e34c" kindref="member">std::enable_if_t</ref>&lt;arma::is_arma_type&lt;LabelsType&gt;::value&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void mlpack::data::Split</definition>
        <argsstring>(const arma::Mat&lt; T &gt; &amp;input, const LabelsType &amp;inputLabel, arma::Mat&lt; T &gt; &amp;trainData, arma::Mat&lt; T &gt; &amp;testData, LabelsType &amp;trainLabel, LabelsType &amp;testLabel, const double testRatio, const bool shuffleData=true)</argsstring>
        <name>Split</name>
        <param>
          <type>const arma::Mat&lt; T &gt; &amp;</type>
          <declname>input</declname>
        </param>
        <param>
          <type>const LabelsType &amp;</type>
          <declname>inputLabel</declname>
        </param>
        <param>
          <type>arma::Mat&lt; T &gt; &amp;</type>
          <declname>trainData</declname>
        </param>
        <param>
          <type>arma::Mat&lt; T &gt; &amp;</type>
          <declname>testData</declname>
        </param>
        <param>
          <type>LabelsType &amp;</type>
          <declname>trainLabel</declname>
        </param>
        <param>
          <type>LabelsType &amp;</type>
          <declname>testLabel</declname>
        </param>
        <param>
          <type>const double</type>
          <declname>testRatio</declname>
        </param>
        <param>
          <type>const bool</type>
          <declname>shuffleData</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
<para>Given an input dataset and labels, split into a training set and test set. </para>        </briefdescription>
        <detaileddescription>
<para>Example usage below. This overload places the split dataset into the four output parameters given (trainData, testData, trainLabel, and testLabel).</para><para><programlisting><codeline><highlight class="normal">arma::mat<sp/>input<sp/>=<sp/>loadData();</highlight></codeline>
<codeline><highlight class="normal">arma::Row&lt;size_t&gt;<sp/>label<sp/>=<sp/>loadLabel();</highlight></codeline>
<codeline><highlight class="normal">arma::mat<sp/>trainData;</highlight></codeline>
<codeline><highlight class="normal">arma::mat<sp/>testData;</highlight></codeline>
<codeline><highlight class="normal">arma::Row&lt;size_t&gt;<sp/>trainLabel;</highlight></codeline>
<codeline><highlight class="normal">arma::Row&lt;size_t&gt;<sp/>testLabel;</highlight></codeline>
<codeline><highlight class="normal">math::RandomSeed(100);<sp/>//<sp/>Set<sp/>the<sp/>seed<sp/>if<sp/>you<sp/>like.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Split<sp/>the<sp/>dataset<sp/>into<sp/>a<sp/>training<sp/>and<sp/>test<sp/>set,<sp/>with<sp/>30%<sp/>of<sp/>the<sp/>data<sp/>being</highlight></codeline>
<codeline><highlight class="normal">//<sp/>held<sp/>out<sp/>for<sp/>the<sp/>test<sp/>set.</highlight></codeline>
<codeline><highlight class="normal">Split(input,<sp/>label,<sp/>trainData,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>testData,<sp/>trainLabel,<sp/>testLabel,<sp/>0.3);</highlight></codeline>
</programlisting></para><para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the elements of the input matrix. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>LabelsType</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of input labels. It can be arma::Mat, arma::Row, arma::Cube or arma::SpMat. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>input</parametername>
</parameternamelist>
<parameterdescription>
<para>Input dataset to split. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>inputLabel</parametername>
</parameternamelist>
<parameterdescription>
<para>Input labels to split. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>trainData</parametername>
</parameternamelist>
<parameterdescription>
<para>Matrix to store training data into. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>testData</parametername>
</parameternamelist>
<parameterdescription>
<para>Matrix to store test data into. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>trainLabel</parametername>
</parameternamelist>
<parameterdescription>
<para>Vector to store training labels into. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>testLabel</parametername>
</parameternamelist>
<parameterdescription>
<para>Vector to store test labels into. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>testRatio</parametername>
</parameternamelist>
<parameterdescription>
<para>Percentage of dataset to use for test set (between 0 and 1). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>shuffleData</parametername>
</parameternamelist>
<parameterdescription>
<para>If true, the sample order is shuffled; otherwise, each sample is visited in linear order. (Default true.) </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/data/split_data.hpp" line="255" column="1" bodyfile="/home/aakash/mlpack/src/mlpack/core/data/split_data.hpp" bodystart="255" bodyend="276"/>
        <references refid="namespacemlpack_1_1data_1aa8ba4ec838f0ac7dd92c69b6c60dfb22" compoundref="split__data_8hpp" startline="27" endline="63">SplitHelper</references>
        <referencedby refid="test__function__tools_8hpp_1af3fc11802c7a2b757836cbf80a027155" compoundref="test__function__tools_8hpp" startline="85" endline="106">LoadBostonHousingDataset</referencedby>
        <referencedby refid="namespacemlpack_1_1data_1a38ad55a3d28296d823078fe7d0ced9b2" compoundref="split__data_8hpp" startline="351" endline="377">Split</referencedby>
      </memberdef>
      <memberdef kind="function" id="namespacemlpack_1_1data_1a0ac4c8b737e134361d49d5c1c3f9f6ba" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void mlpack::data::Split</definition>
        <argsstring>(const arma::Mat&lt; T &gt; &amp;input, arma::Mat&lt; T &gt; &amp;trainData, arma::Mat&lt; T &gt; &amp;testData, const double testRatio, const bool shuffleData=true)</argsstring>
        <name>Split</name>
        <param>
          <type>const arma::Mat&lt; T &gt; &amp;</type>
          <declname>input</declname>
        </param>
        <param>
          <type>arma::Mat&lt; T &gt; &amp;</type>
          <declname>trainData</declname>
        </param>
        <param>
          <type>arma::Mat&lt; T &gt; &amp;</type>
          <declname>testData</declname>
        </param>
        <param>
          <type>const double</type>
          <declname>testRatio</declname>
        </param>
        <param>
          <type>const bool</type>
          <declname>shuffleData</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
<para>Given an input dataset, split into a training set and test set. </para>        </briefdescription>
        <detaileddescription>
<para>Example usage below. This overload places the split dataset into the two output parameters given (trainData, testData).</para><para><programlisting><codeline><highlight class="normal">arma::mat<sp/>input<sp/>=<sp/>loadData();</highlight></codeline>
<codeline><highlight class="normal">arma::mat<sp/>trainData;</highlight></codeline>
<codeline><highlight class="normal">arma::mat<sp/>testData;</highlight></codeline>
<codeline><highlight class="normal">math::RandomSeed(100);<sp/>//<sp/>Set<sp/>the<sp/>seed<sp/>if<sp/>you<sp/>like.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Split<sp/>the<sp/>dataset<sp/>into<sp/>a<sp/>training<sp/>and<sp/>test<sp/>set,<sp/>with<sp/>30%<sp/>of<sp/>the<sp/>data<sp/>being</highlight></codeline>
<codeline><highlight class="normal">//<sp/>held<sp/>out<sp/>for<sp/>the<sp/>test<sp/>set.</highlight></codeline>
<codeline><highlight class="normal">Split(input,<sp/>trainData,<sp/>testData,<sp/>0.3);</highlight></codeline>
</programlisting></para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>input</parametername>
</parameternamelist>
<parameterdescription>
<para>Input dataset to split. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>trainData</parametername>
</parameternamelist>
<parameterdescription>
<para>Matrix to store training data into. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>testData</parametername>
</parameternamelist>
<parameterdescription>
<para>Matrix to store test data into. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>testRatio</parametername>
</parameternamelist>
<parameterdescription>
<para>Percentage of dataset to use for test set (between 0 and 1). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>shuffleData</parametername>
</parameternamelist>
<parameterdescription>
<para>If true, the sample order is shuffled; otherwise, each sample is visited in linear order. (Default true). </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/data/split_data.hpp" line="302" column="1" bodyfile="/home/aakash/mlpack/src/mlpack/core/data/split_data.hpp" bodystart="302" bodyend="318"/>
        <references refid="namespacemlpack_1_1data_1aa8ba4ec838f0ac7dd92c69b6c60dfb22" compoundref="split__data_8hpp" startline="27" endline="63">SplitHelper</references>
      </memberdef>
      <memberdef kind="function" id="namespacemlpack_1_1data_1a38ad55a3d28296d823078fe7d0ced9b2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename LabelsType</type>
          </param>
          <param>
            <type>typename</type>
            <defval><ref refid="namespacestd_1a93e9cb7fadbcfaa2afb5b94058b8e34c" kindref="member">std::enable_if_t</ref>&lt;arma::is_arma_type&lt;LabelsType&gt;::value&gt;</defval>
          </param>
        </templateparamlist>
        <type>std::tuple&lt; arma::Mat&lt; T &gt;, arma::Mat&lt; T &gt;, LabelsType, LabelsType &gt;</type>
        <definition>std::tuple&lt;arma::Mat&lt;T&gt;, arma::Mat&lt;T&gt;, LabelsType, LabelsType&gt; mlpack::data::Split</definition>
        <argsstring>(const arma::Mat&lt; T &gt; &amp;input, const LabelsType &amp;inputLabel, const double testRatio, const bool shuffleData=true, const bool stratifyData=false)</argsstring>
        <name>Split</name>
        <param>
          <type>const arma::Mat&lt; T &gt; &amp;</type>
          <declname>input</declname>
        </param>
        <param>
          <type>const LabelsType &amp;</type>
          <declname>inputLabel</declname>
        </param>
        <param>
          <type>const double</type>
          <declname>testRatio</declname>
        </param>
        <param>
          <type>const bool</type>
          <declname>shuffleData</declname>
          <defval>true</defval>
        </param>
        <param>
          <type>const bool</type>
          <declname>stratifyData</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para>Given an input dataset and labels, split into a training set and test set. </para>        </briefdescription>
        <detaileddescription>
<para>Example usage below. This overload returns the split dataset as a std::tuple with four elements: an arma::Mat&lt;T&gt; containing the training data, an arma::Mat&lt;T&gt; containing the test data, an arma::Row&lt;U&gt; containing the training labels, and an arma::Row&lt;U&gt; containing the test labels.</para><para><programlisting><codeline><highlight class="normal">arma::mat<sp/>input<sp/>=<sp/>loadData();</highlight></codeline>
<codeline><highlight class="normal">arma::Row&lt;size_t&gt;<sp/>label<sp/>=<sp/>loadLabel();</highlight></codeline>
<codeline><highlight class="normal">auto<sp/>splitResult<sp/>=<sp/>Split(input,<sp/>label,<sp/>0.2);</highlight></codeline>
</programlisting></para><para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the elements of the input matrix. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>LabelsType</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of input labels. It can be arma::Mat, arma::Row, arma::Cube or arma::SpMat. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>input</parametername>
</parameternamelist>
<parameterdescription>
<para>Input dataset to split. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>inputLabel</parametername>
</parameternamelist>
<parameterdescription>
<para>Input labels to split. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>testRatio</parametername>
</parameternamelist>
<parameterdescription>
<para>Percentage of dataset to use for test set (between 0 and 1). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>shuffleData</parametername>
</parameternamelist>
<parameterdescription>
<para>If true, the sample order is shuffled; otherwise, each sample is visited in linear order. (Default true). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>stratifyData</parametername>
</parameternamelist>
<parameterdescription>
<para>If true, the train and test splits are stratified so that the ratio of each class in the training and test sets is the same as in the original dataset. Expects labels to be of type arma::Row&lt;&gt; or arma::Col&lt;&gt;. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>std::tuple containing trainData (arma::Mat&lt;T&gt;), testData (arma::Mat&lt;T&gt;), trainLabel (arma::Row&lt;U&gt;), and testLabel (arma::Row&lt;U&gt;). </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/data/split_data.hpp" line="351" column="1" bodyfile="/home/aakash/mlpack/src/mlpack/core/data/split_data.hpp" bodystart="351" bodyend="377"/>
        <references refid="namespacemlpack_1_1data_1a32f749a2ac526fd90ab112400fad6ef2" compoundref="split__data_8hpp" startline="255" endline="276">Split</references>
        <references refid="namespacemlpack_1_1data_1ae5943effbe5980ae3af45b5e62240fc8" compoundref="split__data_8hpp" startline="103" endline="218">StratifiedSplit</references>
      </memberdef>
      <memberdef kind="function" id="namespacemlpack_1_1data_1a91a5ecc1018b88a9cbe745e67d1e8672" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>std::tuple&lt; arma::Mat&lt; T &gt;, arma::Mat&lt; T &gt; &gt;</type>
        <definition>std::tuple&lt;arma::Mat&lt;T&gt;, arma::Mat&lt;T&gt; &gt; mlpack::data::Split</definition>
        <argsstring>(const arma::Mat&lt; T &gt; &amp;input, const double testRatio, const bool shuffleData=true)</argsstring>
        <name>Split</name>
        <param>
          <type>const arma::Mat&lt; T &gt; &amp;</type>
          <declname>input</declname>
        </param>
        <param>
          <type>const double</type>
          <declname>testRatio</declname>
        </param>
        <param>
          <type>const bool</type>
          <declname>shuffleData</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
<para>Given an input dataset, split into a training set and test set. </para>        </briefdescription>
        <detaileddescription>
<para>Example usage below. This overload returns the split dataset as a std::tuple with two elements: an arma::Mat&lt;T&gt; containing the training data and an arma::Mat&lt;T&gt; containing the test data.</para><para><programlisting><codeline><highlight class="normal">arma::mat<sp/>input<sp/>=<sp/>loadData();</highlight></codeline>
<codeline><highlight class="normal">auto<sp/>splitResult<sp/>=<sp/>Split(input,<sp/>0.2);</highlight></codeline>
</programlisting></para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>input</parametername>
</parameternamelist>
<parameterdescription>
<para>Input dataset to split. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>testRatio</parametername>
</parameternamelist>
<parameterdescription>
<para>Percentage of dataset to use for test set (between 0 and 1). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>shuffleData</parametername>
</parameternamelist>
<parameterdescription>
<para>If true, the sample order is shuffled; otherwise, each sample is visited in linear order. (Default true). </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>std::tuple containing trainData (arma::Mat&lt;T&gt;) and testData (arma::Mat&lt;T&gt;). </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/data/split_data.hpp" line="399" column="1" bodyfile="/home/aakash/mlpack/src/mlpack/core/data/split_data.hpp" bodystart="399" bodyend="409"/>
        <references refid="namespacemlpack_1_1data_1a32f749a2ac526fd90ab112400fad6ef2" compoundref="split__data_8hpp" startline="255" endline="276">Split</references>
      </memberdef>
      <memberdef kind="function" id="namespacemlpack_1_1data_1a7bca254ee313ff590e7d1bcada13d72a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename FieldType</type>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename</type>
            <defval><ref refid="namespacestd_1a93e9cb7fadbcfaa2afb5b94058b8e34c" kindref="member">std::enable_if_t</ref>&lt;              arma::is_Col&lt;typename FieldType::object_type&gt;::value ||              arma::is_Mat_only&lt;typename FieldType::object_type&gt;::value&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void mlpack::data::Split</definition>
        <argsstring>(const FieldType &amp;input, const arma::field&lt; T &gt; &amp;inputLabel, FieldType &amp;trainData, arma::field&lt; T &gt; &amp;trainLabel, FieldType &amp;testData, arma::field&lt; T &gt; &amp;testLabel, const double testRatio, const bool shuffleData=true)</argsstring>
        <name>Split</name>
        <param>
          <type>const FieldType &amp;</type>
          <declname>input</declname>
        </param>
        <param>
          <type>const arma::field&lt; T &gt; &amp;</type>
          <declname>inputLabel</declname>
        </param>
        <param>
          <type>FieldType &amp;</type>
          <declname>trainData</declname>
        </param>
        <param>
          <type>arma::field&lt; T &gt; &amp;</type>
          <declname>trainLabel</declname>
        </param>
        <param>
          <type>FieldType &amp;</type>
          <declname>testData</declname>
        </param>
        <param>
          <type>arma::field&lt; T &gt; &amp;</type>
          <declname>testLabel</declname>
        </param>
        <param>
          <type>const double</type>
          <declname>testRatio</declname>
        </param>
        <param>
          <type>const bool</type>
          <declname>shuffleData</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
<para>Given an input dataset and labels, split into a training set and test set. </para>        </briefdescription>
        <detaileddescription>
<para>Example usage below. This overload places the split dataset into the four output parameters given (trainData, testData, trainLabel, and testLabel).</para><para>The input dataset must be of type arma::field. It should have the shape - (n_rows = 1, n_cols = Number of samples, n_slices = 1).</para><para>NOTE: Here FieldType could be arma::field&lt;arma::mat&gt; or arma::field&lt;arma::vec&gt;.</para><para><programlisting><codeline><highlight class="normal">arma::field&lt;arma::mat&gt;<sp/>input<sp/>=<sp/>loadData();</highlight></codeline>
<codeline><highlight class="normal">arma::field&lt;arma::vec&gt;<sp/>label<sp/>=<sp/>loadLabel();</highlight></codeline>
<codeline><highlight class="normal">arma::field&lt;arma::mat&gt;<sp/>trainData;</highlight></codeline>
<codeline><highlight class="normal">arma::field&lt;arma::mat&gt;<sp/>testData;</highlight></codeline>
<codeline><highlight class="normal">arma::field&lt;arma::vec&gt;<sp/>trainLabel;</highlight></codeline>
<codeline><highlight class="normal">arma::field&lt;arma::vec&gt;<sp/>testLabel;</highlight></codeline>
<codeline><highlight class="normal">math::RandomSeed(100);<sp/>//<sp/>Set<sp/>the<sp/>seed<sp/>if<sp/>you<sp/>like.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Split<sp/>the<sp/>dataset<sp/>into<sp/>a<sp/>training<sp/>and<sp/>test<sp/>set,<sp/>with<sp/>30%<sp/>of<sp/>the<sp/>data<sp/>being</highlight></codeline>
<codeline><highlight class="normal">//<sp/>held<sp/>out<sp/>for<sp/>the<sp/>test<sp/>set.</highlight></codeline>
<codeline><highlight class="normal">Split(input,<sp/>label,<sp/>trainData,<sp/>testData,<sp/>trainLabel,<sp/>testLabel,<sp/>0.3);</highlight></codeline>
</programlisting></para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>input</parametername>
</parameternamelist>
<parameterdescription>
<para>Input dataset to split. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>inputLabel</parametername>
</parameternamelist>
<parameterdescription>
<para>Input labels to split. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>trainData</parametername>
</parameternamelist>
<parameterdescription>
<para>FieldType to store training data into. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>testData</parametername>
</parameternamelist>
<parameterdescription>
<para>FieldType test data into. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>trainLabel</parametername>
</parameternamelist>
<parameterdescription>
<para>Field vector to store training labels into. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>testLabel</parametername>
</parameternamelist>
<parameterdescription>
<para>Field vector to store test labels into. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>testRatio</parametername>
</parameternamelist>
<parameterdescription>
<para>Percentage of dataset to use for test set (between 0 and 1). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>shuffleData</parametername>
</parameternamelist>
<parameterdescription>
<para>If true, the sample order is shuffled; otherwise, each sample is visited in linear order. (Default true.) </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/data/split_data.hpp" line="449" column="1" bodyfile="/home/aakash/mlpack/src/mlpack/core/data/split_data.hpp" bodystart="449" bodyend="470"/>
        <references refid="namespacemlpack_1_1data_1aa8ba4ec838f0ac7dd92c69b6c60dfb22" compoundref="split__data_8hpp" startline="27" endline="63">SplitHelper</references>
      </memberdef>
      <memberdef kind="function" id="namespacemlpack_1_1data_1a0baaf8bcdf473761f7c59c9e1577d1f1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class FieldType</type>
          </param>
          <param>
            <type>class</type>
            <defval><ref refid="namespacestd_1a93e9cb7fadbcfaa2afb5b94058b8e34c" kindref="member">std::enable_if_t</ref>&lt;              arma::is_Col&lt;typename FieldType::object_type&gt;::value ||              arma::is_Mat_only&lt;typename FieldType::object_type&gt;::value&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void mlpack::data::Split</definition>
        <argsstring>(const FieldType &amp;input, FieldType &amp;trainData, FieldType &amp;testData, const double testRatio, const bool shuffleData=true)</argsstring>
        <name>Split</name>
        <param>
          <type>const FieldType &amp;</type>
          <declname>input</declname>
        </param>
        <param>
          <type>FieldType &amp;</type>
          <declname>trainData</declname>
        </param>
        <param>
          <type>FieldType &amp;</type>
          <declname>testData</declname>
        </param>
        <param>
          <type>const double</type>
          <declname>testRatio</declname>
        </param>
        <param>
          <type>const bool</type>
          <declname>shuffleData</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
<para>Given an input dataset, split into a training set and test set. </para>        </briefdescription>
        <detaileddescription>
<para>Example usage below. This overload places the split dataset into the two output parameters given (trainData, testData).</para><para>The input dataset must be of type arma::field. It should have the shape - (n_rows = 1, n_cols = Number of samples, n_slices = 1)</para><para>NOTE: Here FieldType could be arma::field&lt;arma::mat&gt; or arma::field&lt;arma::vec&gt;</para><para><programlisting><codeline><highlight class="normal">arma::field&lt;arma::mat&gt;<sp/>input<sp/>=<sp/>loadData();</highlight></codeline>
<codeline><highlight class="normal">arma::field&lt;arma::mat&gt;<sp/>trainData;</highlight></codeline>
<codeline><highlight class="normal">arma::field&lt;arma::mat&gt;<sp/>testData;</highlight></codeline>
<codeline><highlight class="normal">math::RandomSeed(100);<sp/>//<sp/>Set<sp/>the<sp/>seed<sp/>if<sp/>you<sp/>like.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Split<sp/>the<sp/>dataset<sp/>into<sp/>a<sp/>training<sp/>and<sp/>test<sp/>set,<sp/>with<sp/>30%<sp/>of<sp/>the<sp/>data<sp/>being</highlight></codeline>
<codeline><highlight class="normal">//<sp/>held<sp/>out<sp/>for<sp/>the<sp/>test<sp/>set.</highlight></codeline>
<codeline><highlight class="normal">Split(input,<sp/>trainData,<sp/>testData,<sp/>0.3);</highlight></codeline>
</programlisting></para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>input</parametername>
</parameternamelist>
<parameterdescription>
<para>Input dataset to split. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>trainData</parametername>
</parameternamelist>
<parameterdescription>
<para>FieldType to store training data into. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>testData</parametername>
</parameternamelist>
<parameterdescription>
<para>FieldType test data into. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>testRatio</parametername>
</parameternamelist>
<parameterdescription>
<para>Percentage of dataset to use for test set (between 0 and 1). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>shuffleData</parametername>
</parameternamelist>
<parameterdescription>
<para>If true, the sample order is shuffled; otherwise, each sample is visited in linear order. (Default true). </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/data/split_data.hpp" line="504" column="1" bodyfile="/home/aakash/mlpack/src/mlpack/core/data/split_data.hpp" bodystart="504" bodyend="520"/>
        <references refid="namespacemlpack_1_1data_1aa8ba4ec838f0ac7dd92c69b6c60dfb22" compoundref="split__data_8hpp" startline="27" endline="63">SplitHelper</references>
      </memberdef>
      <memberdef kind="function" id="namespacemlpack_1_1data_1a744850e5ad47df5e0af6f5845009a4d2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class FieldType</type>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>class</type>
            <defval><ref refid="namespacestd_1a93e9cb7fadbcfaa2afb5b94058b8e34c" kindref="member">std::enable_if_t</ref>&lt;              arma::is_Col&lt;typename FieldType::object_type&gt;::value ||              arma::is_Mat_only&lt;typename FieldType::object_type&gt;::value&gt;</defval>
          </param>
        </templateparamlist>
        <type>std::tuple&lt; FieldType, FieldType, arma::field&lt; T &gt;, arma::field&lt; T &gt; &gt;</type>
        <definition>std::tuple&lt;FieldType, FieldType, arma::field&lt;T&gt;, arma::field&lt;T&gt; &gt; mlpack::data::Split</definition>
        <argsstring>(const FieldType &amp;input, const arma::field&lt; T &gt; &amp;inputLabel, const double testRatio, const bool shuffleData=true)</argsstring>
        <name>Split</name>
        <param>
          <type>const FieldType &amp;</type>
          <declname>input</declname>
        </param>
        <param>
          <type>const arma::field&lt; T &gt; &amp;</type>
          <declname>inputLabel</declname>
        </param>
        <param>
          <type>const double</type>
          <declname>testRatio</declname>
        </param>
        <param>
          <type>const bool</type>
          <declname>shuffleData</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
<para>Given an input dataset and labels, split into a training set and test set. </para>        </briefdescription>
        <detaileddescription>
<para>Example usage below. This overload returns the split dataset as a std::tuple with four elements: an FieldType containing the training data, an FieldType containing the test data, an arma::field&lt;arma::vec&gt; containing the training labels, and an arma::field&lt;arma::vec&gt; containing the test labels.</para><para>The input dataset must be of type arma::field. It should have the shape - (n_rows = 1, n_cols = Number of samples, n_slices = 1)</para><para>NOTE: Here FieldType could be arma::field&lt;arma::mat&gt; or arma::field&lt;arma::vec&gt;</para><para><programlisting><codeline><highlight class="normal">arma::field&lt;arma::mat&gt;<sp/>input<sp/>=<sp/>loadData();</highlight></codeline>
<codeline><highlight class="normal">arma::field&lt;arma::vec&gt;<sp/>label<sp/>=<sp/>loadLabel();</highlight></codeline>
<codeline><highlight class="normal">auto<sp/>splitResult<sp/>=<sp/>Split(input,<sp/>label,<sp/>0.2);</highlight></codeline>
</programlisting></para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>input</parametername>
</parameternamelist>
<parameterdescription>
<para>Input dataset to split. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>inputLabel</parametername>
</parameternamelist>
<parameterdescription>
<para>Input labels to split. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>testRatio</parametername>
</parameternamelist>
<parameterdescription>
<para>Percentage of dataset to use for test set (between 0 and 1). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>shuffleData</parametername>
</parameternamelist>
<parameterdescription>
<para>If true, the sample order is shuffled; otherwise, each sample is visited in linear order. (Default true). </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>std::tuple containing trainData (FieldType), testData (FieldType), trainLabel (arma::field&lt;arma::vec&gt;), and testLabel (arma::field&lt;arma::vec&gt;). </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/data/split_data.hpp" line="554" column="1" bodyfile="/home/aakash/mlpack/src/mlpack/core/data/split_data.hpp" bodystart="554" bodyend="571"/>
        <references refid="namespacemlpack_1_1data_1a32f749a2ac526fd90ab112400fad6ef2" compoundref="split__data_8hpp" startline="255" endline="276">Split</references>
      </memberdef>
      <memberdef kind="function" id="namespacemlpack_1_1data_1af9b163f42a48fdc8993c2165f9089494" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class FieldType</type>
          </param>
          <param>
            <type>class</type>
            <defval><ref refid="namespacestd_1a93e9cb7fadbcfaa2afb5b94058b8e34c" kindref="member">std::enable_if_t</ref>&lt;              arma::is_Col&lt;typename FieldType::object_type&gt;::value ||              arma::is_Mat_only&lt;typename FieldType::object_type&gt;::value&gt;</defval>
          </param>
        </templateparamlist>
        <type>std::tuple&lt; FieldType, FieldType &gt;</type>
        <definition>std::tuple&lt;FieldType, FieldType&gt; mlpack::data::Split</definition>
        <argsstring>(const FieldType &amp;input, const double testRatio, const bool shuffleData=true)</argsstring>
        <name>Split</name>
        <param>
          <type>const FieldType &amp;</type>
          <declname>input</declname>
        </param>
        <param>
          <type>const double</type>
          <declname>testRatio</declname>
        </param>
        <param>
          <type>const bool</type>
          <declname>shuffleData</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
<para>Given an input dataset, split into a training set and test set. </para>        </briefdescription>
        <detaileddescription>
<para>Example usage below. This overload returns the split dataset as a std::tuple with two elements: an FieldType containing the training data and an FieldType containing the test data.</para><para>The input dataset must be of type arma::field. It should have the shape - (n_rows = 1, n_cols = Number of samples, n_slices = 1)</para><para>NOTE: Here FieldType could be arma::field&lt;arma::mat&gt; or arma::field&lt;arma::vec&gt;</para><para><programlisting><codeline><highlight class="normal">arma::field&lt;arma::mat&gt;<sp/>input<sp/>=<sp/>loadData();</highlight></codeline>
<codeline><highlight class="normal">auto<sp/>splitResult<sp/>=<sp/>Split(input,<sp/>0.2);</highlight></codeline>
</programlisting></para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>input</parametername>
</parameternamelist>
<parameterdescription>
<para>Input dataset to split. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>testRatio</parametername>
</parameternamelist>
<parameterdescription>
<para>Percentage of dataset to use for test set (between 0 and 1). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>shuffleData</parametername>
</parameternamelist>
<parameterdescription>
<para>If true, the sample order is shuffled; otherwise, each sample is visited in linear order. (Default true). </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>std::tuple containing trainData (FieldType) and testData (FieldType). </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/data/split_data.hpp" line="601" column="1" bodyfile="/home/aakash/mlpack/src/mlpack/core/data/split_data.hpp" bodystart="601" bodyend="611"/>
        <references refid="namespacemlpack_1_1data_1a32f749a2ac526fd90ab112400fad6ef2" compoundref="split__data_8hpp" startline="255" endline="276">Split</references>
      </memberdef>
      <memberdef kind="function" id="namespacemlpack_1_1data_1aa8ba4ec838f0ac7dd92c69b6c60dfb22" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename InputType</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void mlpack::data::SplitHelper</definition>
        <argsstring>(const InputType &amp;input, InputType &amp;train, InputType &amp;test, const double testRatio, const arma::uvec &amp;order=arma::uvec())</argsstring>
        <name>SplitHelper</name>
        <param>
          <type>const InputType &amp;</type>
          <declname>input</declname>
        </param>
        <param>
          <type>InputType &amp;</type>
          <declname>train</declname>
        </param>
        <param>
          <type>InputType &amp;</type>
          <declname>test</declname>
        </param>
        <param>
          <type>const double</type>
          <declname>testRatio</declname>
        </param>
        <param>
          <type>const arma::uvec &amp;</type>
          <declname>order</declname>
          <defval>arma::uvec()</defval>
        </param>
        <briefdescription>
<para>This helper function splits any <computeroutput>input</computeroutput> data into training and testing parts. </para>        </briefdescription>
        <detaileddescription>
<para>In order to shuffle the input data before spliting, an array of shuffled indices of the input data is passed in the form of argument <computeroutput>order</computeroutput>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/data/split_data.hpp" line="27" column="1" bodyfile="/home/aakash/mlpack/src/mlpack/core/data/split_data.hpp" bodystart="27" bodyend="63"/>
        <referencedby refid="namespacemlpack_1_1data_1a32f749a2ac526fd90ab112400fad6ef2" compoundref="split__data_8hpp" startline="255" endline="276">Split</referencedby>
      </memberdef>
      <memberdef kind="function" id="namespacemlpack_1_1data_1ae5943effbe5980ae3af45b5e62240fc8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename LabelsType</type>
          </param>
          <param>
            <type>typename</type>
            <defval><ref refid="namespacestd_1a93e9cb7fadbcfaa2afb5b94058b8e34c" kindref="member">std::enable_if_t</ref>&lt;arma::is_arma_type&lt;LabelsType&gt;::value&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void mlpack::data::StratifiedSplit</definition>
        <argsstring>(const arma::Mat&lt; T &gt; &amp;input, const LabelsType &amp;inputLabel, arma::Mat&lt; T &gt; &amp;trainData, arma::Mat&lt; T &gt; &amp;testData, LabelsType &amp;trainLabel, LabelsType &amp;testLabel, const double testRatio, const bool shuffleData=true)</argsstring>
        <name>StratifiedSplit</name>
        <param>
          <type>const arma::Mat&lt; T &gt; &amp;</type>
          <declname>input</declname>
        </param>
        <param>
          <type>const LabelsType &amp;</type>
          <declname>inputLabel</declname>
        </param>
        <param>
          <type>arma::Mat&lt; T &gt; &amp;</type>
          <declname>trainData</declname>
        </param>
        <param>
          <type>arma::Mat&lt; T &gt; &amp;</type>
          <declname>testData</declname>
        </param>
        <param>
          <type>LabelsType &amp;</type>
          <declname>trainLabel</declname>
        </param>
        <param>
          <type>LabelsType &amp;</type>
          <declname>testLabel</declname>
        </param>
        <param>
          <type>const double</type>
          <declname>testRatio</declname>
        </param>
        <param>
          <type>const bool</type>
          <declname>shuffleData</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
<para>Given an input dataset and labels, stratify into a training set and test set. </para>        </briefdescription>
        <detaileddescription>
<para>It is recommended to have the input labels between the range [0, n) where n is the number of different labels. The <ref refid="namespacemlpack_1_1data_1a664b3fa5243889e2aed47ee750f840ed" kindref="member">NormalizeLabels()</ref> function in <ref refid="namespacemlpack_1_1data" kindref="compound">mlpack::data</ref> can be used for this. Expects labels to be of type arma::Row&lt;&gt; or arma::Col&lt;&gt;. Throws a runtime error if this is not the case. Example usage below. This overload places the stratified dataset into the four output parameters given (trainData, testData, trainLabel, and testLabel).</para><para><programlisting><codeline><highlight class="normal">arma::mat<sp/>input<sp/>=<sp/>loadData();</highlight></codeline>
<codeline><highlight class="normal">arma::Row&lt;size_t&gt;<sp/>label<sp/>=<sp/>loadLabel();</highlight></codeline>
<codeline><highlight class="normal">arma::mat<sp/>trainData;</highlight></codeline>
<codeline><highlight class="normal">arma::mat<sp/>testData;</highlight></codeline>
<codeline><highlight class="normal">arma::Row&lt;size_t&gt;<sp/>trainLabel;</highlight></codeline>
<codeline><highlight class="normal">arma::Row&lt;size_t&gt;<sp/>testLabel;</highlight></codeline>
<codeline><highlight class="normal">math::RandomSeed(100);<sp/>//<sp/>Set<sp/>the<sp/>seed<sp/>if<sp/>you<sp/>like.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Stratify<sp/>the<sp/>dataset<sp/>into<sp/>a<sp/>training<sp/>and<sp/>test<sp/>set,<sp/>with<sp/>30%<sp/>of<sp/>the<sp/>data</highlight></codeline>
<codeline><highlight class="normal">//<sp/>being<sp/>held<sp/>out<sp/>for<sp/>the<sp/>test<sp/>set.</highlight></codeline>
<codeline><highlight class="normal">StratifiedSplit(input,<sp/>label,<sp/>trainData,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>testData,<sp/>trainLabel,<sp/>testLabel,<sp/>0.3);</highlight></codeline>
</programlisting></para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>input</parametername>
</parameternamelist>
<parameterdescription>
<para>Input dataset to stratify. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>inputLabel</parametername>
</parameternamelist>
<parameterdescription>
<para>Input labels to stratify. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>trainData</parametername>
</parameternamelist>
<parameterdescription>
<para>Matrix to store training data into. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>testData</parametername>
</parameternamelist>
<parameterdescription>
<para>Matrix to store test data into. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>trainLabel</parametername>
</parameternamelist>
<parameterdescription>
<para>Vector to store training labels into. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>testLabel</parametername>
</parameternamelist>
<parameterdescription>
<para>Vector to store test labels into. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>testRatio</parametername>
</parameternamelist>
<parameterdescription>
<para>Percentage of dataset to use for test set (between 0 and 1). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>shuffleData</parametername>
</parameternamelist>
<parameterdescription>
<para>If true, the sample order is shuffled; otherwise, each sample is visited in linear order. (Default true.) </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
<para>Basic idea: Let us say we have to stratify a dataset based on labels: 0 0 0 0 0 (5 0s) 1 1 1 1 1 1 1 1 1 1 1 (11 1s)</para><para>Let our test ratio be 0.2. Then, the number of 0 labels in our test set = floor(5 * 0.2) = 1. The number of 1 labels in our test set = floor(11 * 0.2) = 2.</para><para>In our first pass over the dataset, We visit each label and keep count of each label in our &apos;labelCounts&apos; uvec.</para><para>We then take a second pass over the dataset. We now maintain an additional uvec &apos;testLabelCounts&apos; to hold the label counts of our test set.</para><para>In this pass, when we encounter a label we check the &apos;testLabelCounts&apos; uvec for the count of this label in the test set. If this count is less than the required number of labels in the test set, we add the data to the test set and increment the label count in the uvec. If this count is equal to or more than the required count in the test set, we add this data to the train set.</para><para>Based on the above steps, we get the following labels in the split set: Train set (4 0s, 9 1s) 0 0 0 0 1 1 1 1 1 1 1 1 1</para><para>Test set (1 0s, 2 1s) 0 1 1</para>        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/data/split_data.hpp" line="103" column="1" bodyfile="/home/aakash/mlpack/src/mlpack/core/data/split_data.hpp" bodystart="103" bodyend="218"/>
        <referencedby refid="namespacemlpack_1_1data_1a38ad55a3d28296d823078fe7d0ced9b2" compoundref="split__data_8hpp" startline="351" endline="377">Split</referencedby>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>Functions to load and save matrices and models. </para>    </briefdescription>
    <detaileddescription>
<para>Functions to load and save matrices.</para>    </detaileddescription>
    <location file="/home/aakash/mlpack/src/mlpack/core/data/binarize.hpp" line="19" column="1"/>
  </compounddef>
</doxygen>
