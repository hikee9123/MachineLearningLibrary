<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="cv" kind="page">
    <compoundname>cv</compoundname>
    <title>Cross-Validation</title>
    <detaileddescription>
<sect1 id="cv_1cvintro">
<title>Introduction</title>
<para><bold>mlpack</bold> implements cross-validation support for its learning algorithms, for a variety of performance measures. Cross-validation is useful for determining an estimate of how well the learner will generalize to un-seen test data. It is a commonly used part of the data science pipeline.</para><para>In short, given some learner and some performance measure, we wish to get an average of the performance measure given different splits of the dataset into training data and validation data. The learner is trained on the training data, and the performance measure is evaluated on the validation data.</para><para>mlpack currently implements two easy-to-use forms of cross-validation:</para><para><itemizedlist>
<listitem><para><bold>simple</bold> <bold>cross-validation</bold>, where we simply desire the performance measure on a single split of the data into a training set and validation set</para></listitem><listitem><para><bold>k-fold</bold> <bold>cross-validation</bold>, where we split the data k ways and desire the average performance measure on each of the k splits of the data</para></listitem></itemizedlist>
</para><para>In this tutorial we will see the usage examples and details of the cross-validation module. Because the cross-validation code is generic and can be used with any learner and performance measure, any use of the cross-validation code in mlpack has to be in C++.</para><para>This tutorial is split into the following sections:</para><para><itemizedlist>
<listitem><para><ref refid="cv_1cvbasic" kindref="member">Simple cross-validation examples</ref> Simple cross-validation examples<itemizedlist>
<listitem><para><ref refid="cv_1cvbasic_ex_1" kindref="member">10-fold cross-validation on softmax regression</ref> 10-fold cross-validation on softmax regression</para></listitem><listitem><para><ref refid="cv_1cvbasic_ex_2" kindref="member">10-fold cross-validation on weighted decision trees</ref> 10-fold cross-validation on weighted decision trees</para></listitem><listitem><para><ref refid="cv_1cvbasic_ex_3" kindref="member">10-fold cross-validation with categorical decision trees</ref> 10-fold cross-validation with categorical decision trees</para></listitem><listitem><para><ref refid="cv_1cvbasic_ex_4" kindref="member">Simple cross-validation for linear regression</ref> Simple cross-validation for linear regression</para></listitem></itemizedlist>
</para></listitem><listitem><para><ref refid="cv_1cvbasic_metrics" kindref="member">Performance measures</ref> Performance measures</para></listitem><listitem><para><ref refid="cv_1cvbasic_api" kindref="member">The KFoldCV and SimpleCV classes</ref> The <computeroutput><ref refid="classmlpack_1_1cv_1_1KFoldCV" kindref="compound">KFoldCV</ref></computeroutput> and <computeroutput><ref refid="classmlpack_1_1cv_1_1SimpleCV" kindref="compound">SimpleCV</ref></computeroutput> classes</para></listitem><listitem><para><ref refid="cv_1cvbasic_further" kindref="member">Further references</ref> Further reference</para></listitem></itemizedlist>
</para></sect1>
<sect1 id="cv_1cvbasic">
<title>Simple cross-validation examples</title>
<sect2 id="cv_1cvbasic_ex_1">
<title>10-fold cross-validation on softmax regression</title>
<para>Suppose we have some data to train and validate on, as defined below:</para><para><programlisting><codeline><highlight class="normal">//<sp/>100-point<sp/>6-dimensional<sp/>random<sp/>dataset.</highlight></codeline>
<codeline><highlight class="normal">arma::mat<sp/>data<sp/>=<sp/>arma::randu&lt;arma::mat&gt;(6,<sp/>100);</highlight></codeline>
<codeline><highlight class="normal">//<sp/>Random<sp/>labels<sp/>in<sp/>the<sp/>[0,<sp/>4]<sp/>interval.</highlight></codeline>
<codeline><highlight class="normal">arma::Row&lt;size_t&gt;<sp/>labels<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>arma::randi&lt;arma::Row&lt;size_t&gt;&gt;(100,<sp/>arma::distr_param(0,<sp/>4));</highlight></codeline>
<codeline><highlight class="normal">size_t<sp/>numClasses<sp/>=<sp/>5;</highlight></codeline>
</programlisting></para><para>The code above generates an 100-point random 6-dimensional dataset with 5 classes.</para><para>To run 10-fold cross-validation for softmax regression with accuracy as a performance measure, we can write the following piece of code.</para><para><programlisting><codeline><highlight class="normal">KFoldCV&lt;SoftmaxRegression,<sp/>Accuracy&gt;<sp/>cv(10,<sp/>data,<sp/>labels,<sp/>numClasses);</highlight></codeline>
<codeline><highlight class="normal">double<sp/>lambda<sp/>=<sp/>0.1;</highlight></codeline>
<codeline><highlight class="normal">double<sp/>softmaxAccuracy<sp/>=<sp/>cv.Evaluate(lambda);</highlight></codeline>
</programlisting></para><para>Note that the <computeroutput>Evaluate</computeroutput> method of <computeroutput><ref refid="classmlpack_1_1cv_1_1KFoldCV" kindref="compound">KFoldCV</ref></computeroutput> takes any hyperparameters of an algorithm<mdash/>that is, anything that is not <computeroutput>data</computeroutput>, <computeroutput>labels</computeroutput>, <computeroutput>numClasses</computeroutput>, <computeroutput>datasetInfo</computeroutput>, or <computeroutput>weights</computeroutput> (those last three may not be present for every algorithm type). To be more specific, in this example the <computeroutput>Evaluate</computeroutput> method relies on the following <ref refid="classmlpack_1_1regression_1_1SoftmaxRegression" kindref="compound">SoftmaxRegression</ref> constructor:</para><para><programlisting><codeline><highlight class="normal">template&lt;typename<sp/>OptimizerType<sp/>=<sp/>mlpack::optimization::L_BFGS&gt;</highlight></codeline>
<codeline><highlight class="normal">SoftmaxRegression(const<sp/>arma::mat&amp;<sp/>data,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>arma::Row&lt;size_t&gt;&amp;<sp/>labels,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>size_t<sp/>numClasses,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>double<sp/>lambda<sp/>=<sp/>0.0001,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>bool<sp/>fitIntercept<sp/>=<sp/>false,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>OptimizerType<sp/>optimizer<sp/>=<sp/>OptimizerType());</highlight></codeline>
</programlisting></para><para>which has the parameter <computeroutput>lambda</computeroutput> after three conventional arguments (<computeroutput>data</computeroutput>, <computeroutput>labels</computeroutput> and <computeroutput>numClasses</computeroutput>). We can skip passing <computeroutput>fitIntercept</computeroutput> and <computeroutput>optimizer</computeroutput> since there are the default values. (Technically, we don&apos;t even need to pass <computeroutput>lambda</computeroutput> since there is a default value.)</para><para>In general to cross-validate you need to specify what machine learning algorithm and metric you are going to use, and then to pass some conventional data-related parameters into one of the cross-validation constructors and all other parameters (which are generally hyperparameters) into the <computeroutput>Evaluate</computeroutput> method.</para></sect2>
<sect2 id="cv_1cvbasic_ex_2">
<title>10-fold cross-validation on weighted decision trees</title>
<para>In the following example we will cross-validate <ref refid="classmlpack_1_1tree_1_1DecisionTree" kindref="compound">DecisionTree</ref> with weights. This is very similar to the previous example, except that we also have instance weights for each point in the dataset. We can generate weights for the dataset from the previous example with the code below:</para><para><programlisting><codeline><highlight class="normal">//<sp/>Random<sp/>weights<sp/>for<sp/>every<sp/>point<sp/>from<sp/>the<sp/>code<sp/>snippet<sp/>above.</highlight></codeline>
<codeline><highlight class="normal">arma::rowvec<sp/>weights<sp/>=<sp/>arma::randu&lt;arma::mat&gt;(1,<sp/>100);</highlight></codeline>
</programlisting></para><para>Given those weights for each point, we can now perform cross-validation by also passing the weights to the constructor of <computeroutput><ref refid="classmlpack_1_1cv_1_1KFoldCV" kindref="compound">KFoldCV</ref>:</computeroutput> </para><para><programlisting><codeline><highlight class="normal">KFoldCV&lt;DecisionTree&lt;&gt;,<sp/>Accuracy&gt;<sp/>cv2(10,<sp/>data,<sp/>labels,<sp/>numClasses,<sp/>weights);</highlight></codeline>
<codeline><highlight class="normal">size_t<sp/>minimumLeafSize<sp/>=<sp/>8;</highlight></codeline>
<codeline><highlight class="normal">double<sp/>weightedDecisionTreeAccuracy<sp/>=<sp/>cv2.Evaluate(minimumLeafSize);</highlight></codeline>
</programlisting></para><para>As with the previous example, internally this call to <computeroutput>cv2.Evaluate()</computeroutput> relies on the following <ref refid="classmlpack_1_1tree_1_1DecisionTree" kindref="compound">DecisionTree</ref> constructor:</para><para><programlisting><codeline><highlight class="normal">template&lt;typename<sp/>MatType,<sp/>typename<sp/>LabelsType,<sp/>typename<sp/>WeightsType&gt;</highlight></codeline>
<codeline><highlight class="normal">DecisionTree(MatType&amp;&amp;<sp/>data,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>LabelsType&amp;&amp;<sp/>labels,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>size_t<sp/>numClasses,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>WeightsType&amp;&amp;<sp/>weights,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>size_t<sp/>minimumLeafSize<sp/>=<sp/>10,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>std::enable_if_t&lt;arma::is_arma_type&lt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typename<sp/>std::remove_reference&lt;WeightsType&gt;::type&gt;::value&gt;*</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>0);</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="cv_1cvbasic_ex_3">
<title>10-fold cross-validation with categorical decision trees</title>
<para><ref refid="classmlpack_1_1tree_1_1DecisionTree" kindref="compound">DecisionTree</ref> models can be constructed in multiple other ways. For example, if we have a dataset with both categorical and numerical features, we can also perform cross-validation by using the associated <computeroutput><ref refid="namespacemlpack_1_1data_1aa243ad7e4d29363b858bbc92b732921d" kindref="member">data::DatasetInfo</ref></computeroutput> object. Thus, given some <computeroutput><ref refid="namespacemlpack_1_1data_1aa243ad7e4d29363b858bbc92b732921d" kindref="member">data::DatasetInfo</ref></computeroutput> object called <computeroutput>datasetInfo</computeroutput> (that perhaps was produced by a call to <computeroutput><ref refid="namespacemlpack_1_1data_1abbff2a667bf247e00b1fc09b7ca5f831" kindref="member">data::Load()</ref></computeroutput> ), we can perform k-fold cross-validation in a similar manner to the other examples:</para><para><programlisting><codeline><highlight class="normal">KFoldCV&lt;DecisionTree&lt;&gt;,<sp/>Accuracy&gt;<sp/>cv3(10,<sp/>data,<sp/>datasetInfo,<sp/>labels,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>numClasses);</highlight></codeline>
<codeline><highlight class="normal">double<sp/>decisionTreeWithDIAccuracy<sp/>=<sp/>cv3.Evaluate(minimumLeafSize);</highlight></codeline>
</programlisting></para><para>This particular call to <computeroutput>cv3.Evaluate()</computeroutput> relies on the following <ref refid="classmlpack_1_1tree_1_1DecisionTree" kindref="compound">DecisionTree</ref> constructor:</para><para><programlisting><codeline><highlight class="normal">template&lt;typename<sp/>MatType,<sp/>typename<sp/>LabelsType&gt;</highlight></codeline>
<codeline><highlight class="normal">DecisionTree(MatType&amp;&amp;<sp/>data,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>data::DatasetInfo&amp;<sp/>datasetInfo,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>LabelsType&amp;&amp;<sp/>labels,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>size_t<sp/>numClasses,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>size_t<sp/>minimumLeafSize<sp/>=<sp/>10);</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="cv_1cvbasic_ex_4">
<title>Simple cross-validation for linear regression</title>
<para><computeroutput><ref refid="classmlpack_1_1cv_1_1SimpleCV" kindref="compound">SimpleCV</ref></computeroutput> has the same interface as <computeroutput><ref refid="classmlpack_1_1cv_1_1KFoldCV" kindref="compound">KFoldCV</ref></computeroutput>, except it takes as one of its arguments a proportion (from 0 to 1) of data used as a validation set. For example, to validate <ref refid="classmlpack_1_1regression_1_1LinearRegression" kindref="compound">LinearRegression</ref> with 20% of the data used in the validation set we can write the following code.</para><para><programlisting><codeline><highlight class="normal">//<sp/>Random<sp/>responses<sp/>for<sp/>every<sp/>point<sp/>from<sp/>the<sp/>code<sp/>snippet<sp/>in<sp/>the<sp/>beginning<sp/>of</highlight></codeline>
<codeline><highlight class="normal">//<sp/>the<sp/>tutorial.</highlight></codeline>
<codeline><highlight class="normal">arma::rowvec<sp/>responses<sp/>=<sp/>arma::randu&lt;arma::rowvec&gt;(100);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">SimpleCV&lt;LinearRegression,<sp/>MSE&gt;<sp/>cv4(0.2,<sp/>data,<sp/>responses);</highlight></codeline>
<codeline><highlight class="normal">double<sp/>lrLambda<sp/>=<sp/>0.05;</highlight></codeline>
<codeline><highlight class="normal">double<sp/>lrMSE<sp/>=<sp/>cv4.Evaluate(lrLambda);</highlight></codeline>
</programlisting></para></sect2>
</sect1>
<sect1 id="cv_1cvbasic_metrics">
<title>Performance measures</title>
<para>The cross-validation classes require a performance measure to be specified. <bold>mlpack</bold> has a number of performance measures implemented; below is a list:</para><para><itemizedlist>
<listitem><para><ref refid="classmlpack_1_1cv_1_1Accuracy" kindref="compound">mlpack::cv::Accuracy</ref>: a simple measure of accuracy</para></listitem><listitem><para><ref refid="classmlpack_1_1cv_1_1F1" kindref="compound">mlpack::cv::F1</ref>: the <ref refid="classmlpack_1_1cv_1_1F1" kindref="compound">F1</ref> score; depends on an averaging strategy</para></listitem><listitem><para><ref refid="classmlpack_1_1cv_1_1MSE" kindref="compound">mlpack::cv::MSE</ref>: minimum squared error (for regression problems)</para></listitem><listitem><para><ref refid="classmlpack_1_1cv_1_1Precision" kindref="compound">mlpack::cv::Precision</ref>: the precision, for classification problems</para></listitem><listitem><para><ref refid="classmlpack_1_1cv_1_1Recall" kindref="compound">mlpack::cv::Recall</ref>: the recall, for classification problems</para></listitem></itemizedlist>
</para><para>In addition, it is not difficult to implement a custom performance measure. A class following the structure below can be used:</para><para><programlisting><codeline><highlight class="normal">class<sp/>CustomMeasure</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>This<sp/>evaluates<sp/>the<sp/>metric<sp/>given<sp/>a<sp/>trained<sp/>model<sp/>and<sp/>a<sp/>set<sp/>of<sp/>data<sp/>(with</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>labels<sp/>or<sp/>responses)<sp/>to<sp/>evaluate<sp/>on.<sp/><sp/>The<sp/>data<sp/>parameter<sp/>will<sp/>be<sp/>a<sp/>type<sp/>of</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Armadillo<sp/>matrix,<sp/>and<sp/>the<sp/>labels<sp/>will<sp/>be<sp/>the<sp/>labels<sp/>that<sp/>go<sp/>with<sp/>the<sp/>model.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>If<sp/>you<sp/>know<sp/>that<sp/>your<sp/>model<sp/>is<sp/>a<sp/>classification<sp/>model<sp/>(and<sp/>thus<sp/>that</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>ResponsesType<sp/>will<sp/>be<sp/>arma::Row&lt;size_t&gt;),<sp/>it<sp/>is<sp/>ok<sp/>to<sp/>replace<sp/>the</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>ResponsesType<sp/>template<sp/>parameter<sp/>with<sp/>arma::Row&lt;size_t&gt;.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>template&lt;typename<sp/>MLAlgorithm,<sp/>typename<sp/>DataType,<sp/>typename<sp/>ResponsesType&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>static<sp/>double<sp/>Evaluate(MLAlgorithm&amp;<sp/>model,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>DataType&amp;<sp/>data,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>ResponsesType&amp;<sp/>labels)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Inside<sp/>the<sp/>method<sp/>you<sp/>should<sp/>call<sp/>model.Predict()<sp/>and<sp/>compare<sp/>the</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>values<sp/>with<sp/>the<sp/>labels,<sp/>in<sp/>order<sp/>to<sp/>get<sp/>the<sp/>desired<sp/>performance<sp/>measure</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>and<sp/>return<sp/>it.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para><para>Once this is implemented, then <computeroutput>CustomMeasure</computeroutput> (or whatever the class is called) is easy to use as a custom performance measure with <computeroutput><ref refid="classmlpack_1_1cv_1_1KFoldCV" kindref="compound">KFoldCV</ref></computeroutput> or <computeroutput><ref refid="classmlpack_1_1cv_1_1SimpleCV" kindref="compound">SimpleCV</ref></computeroutput>.</para></sect1>
<sect1 id="cv_1cvbasic_api">
<title>The KFoldCV and SimpleCV classes</title>
<para>This section provides details about the <computeroutput><ref refid="classmlpack_1_1cv_1_1KFoldCV" kindref="compound">KFoldCV</ref></computeroutput> and <computeroutput><ref refid="classmlpack_1_1cv_1_1SimpleCV" kindref="compound">SimpleCV</ref></computeroutput> classes. The cross-validation infrastructure is based on heavy amounts of template metaprogramming, so that any <bold>mlpack</bold> learner and any performance measure can be used. Both classes have two required template parameters and one optional parameter:</para><para><itemizedlist>
<listitem><para><computeroutput>MLAlgorithm:</computeroutput> the type of learner to be used</para></listitem><listitem><para><computeroutput>Metric:</computeroutput> the performance measure to be evaluated</para></listitem><listitem><para><computeroutput>MatType:</computeroutput> the type of matrix used to store the data</para></listitem></itemizedlist>
</para><para>In addition, there are two more template parameters, but these are automatically extracted from the given <computeroutput>MLAlgorithm</computeroutput> class, and users should not need to specify these parameters except when using an unconventional type like <computeroutput>arma::fmat</computeroutput> for data points.</para><para>The general structure of the <computeroutput><ref refid="classmlpack_1_1cv_1_1KFoldCV" kindref="compound">KFoldCV</ref></computeroutput> and <computeroutput><ref refid="classmlpack_1_1cv_1_1SimpleCV" kindref="compound">SimpleCV</ref></computeroutput> classes is split into two parts:</para><para><itemizedlist>
<listitem><para>The constructor: create the object, and store the data for the <computeroutput>MLAlgorithm</computeroutput> training.</para></listitem><listitem><para>The <computeroutput>Evaluate()</computeroutput> method: take any non-data parameters for the <computeroutput>MLAlgorithm</computeroutput> and calculate the desired performance measure.</para></listitem></itemizedlist>
</para><para>This split is important because it defines the API: all data-related parameters are passed to the constructor, whereas algorithm hyperparameters are passed to the <computeroutput>Evaluate()</computeroutput> method.</para><sect2 id="cv_1cvbasic_api_constructor">
<title>The KFoldCV and SimpleCV constructors</title>
<para>There are six constructors available for <computeroutput><ref refid="classmlpack_1_1cv_1_1KFoldCV" kindref="compound">KFoldCV</ref></computeroutput> and <computeroutput><ref refid="classmlpack_1_1cv_1_1SimpleCV" kindref="compound">SimpleCV</ref></computeroutput>, each tailored for a different learning situation. Each is given below for the <computeroutput><ref refid="classmlpack_1_1cv_1_1KFoldCV" kindref="compound">KFoldCV</ref></computeroutput> class, but the same constructors are also available for the <computeroutput><ref refid="classmlpack_1_1cv_1_1SimpleCV" kindref="compound">SimpleCV</ref></computeroutput> class, with the exception that instead of specifying <computeroutput>k</computeroutput>, the number of folds, the <computeroutput><ref refid="classmlpack_1_1cv_1_1SimpleCV" kindref="compound">SimpleCV</ref></computeroutput> class takes a parameter between 0 and 1 specifying the percentage of the dataset to use as a validation set.</para><para><itemizedlist>
<listitem><para><computeroutput>KFoldCV(k, xs, ys)</computeroutput>: this is for unweighted regression applications and two-class classification applications; <computeroutput>xs</computeroutput> is the dataset and <computeroutput>ys</computeroutput> are the responses or labels for each point in the dataset.</para></listitem><listitem><para><computeroutput>KFoldCV(k, xs, ys, numClasses)</computeroutput>: this is for unweighted classification applications; <computeroutput>xs</computeroutput> is the dataset, <computeroutput>ys</computeroutput> are the class labels for each data point, and <computeroutput>numClasses</computeroutput> is the number of classes in the dataset.</para></listitem><listitem><para><computeroutput>KFoldCV(k, xs, datasetInfo, ys, numClasses)</computeroutput>: this is for unweighted categorical/numeric classification applications; <computeroutput>xs</computeroutput> is the dataset, <computeroutput>datasetInfo</computeroutput> is a <ref refid="namespacemlpack_1_1data_1aa243ad7e4d29363b858bbc92b732921d" kindref="member">data::DatasetInfo</ref> object that holds the types of each dimension in the dataset, <computeroutput>ys</computeroutput> are the class labels for each data point, and <computeroutput>numClasses</computeroutput> is the number of classes in the dataset.</para></listitem><listitem><para><computeroutput>KFoldCV(k, xs, ys, weights)</computeroutput>: this is for weighted regression or two-class classification applications; <computeroutput>xs</computeroutput> is the dataset, <computeroutput>ys</computeroutput> are the responses or labels for each point in the dataset, and <computeroutput>weights</computeroutput> are the weights for each point in the dataset.</para></listitem><listitem><para><computeroutput>KFoldCV(k, xs, ys, numClasses, weights)</computeroutput>: this is for weighted classification applications; <computeroutput>xs</computeroutput> is the dataset, <computeroutput>ys</computeroutput> are the class labels for each point in the dataset; <computeroutput>numClasses</computeroutput> is the number of classes in the dataset, and <computeroutput>weights</computeroutput> holds the weights for each point in the dataset.</para></listitem><listitem><para><computeroutput>KFoldCV(k, xs, datasetInfo, ys, numClasses, weights)</computeroutput>: this is for weighted cateogrical/numeric classification applications; <computeroutput>xs</computeroutput> is the dataset, <computeroutput>datasetInfo</computeroutput> is a <ref refid="namespacemlpack_1_1data_1aa243ad7e4d29363b858bbc92b732921d" kindref="member">data::DatasetInfo</ref> object that holds the types of each dimension in the dataset, <computeroutput>ys</computeroutput> are the class labels for each data point, <computeroutput>numClasses</computeroutput> is the number of classes in each dataset, and <computeroutput>weights</computeroutput> holds the weights for each point in the dataset.</para></listitem></itemizedlist>
</para><para>Note that the constructor you should use is the constructor that most closely matches the constructor of the machine learning algorithm you would like performance measures of. So, for instance, if you are doing multi-class softmax regression, you could call the constructor <computeroutput>&quot;SoftmaxRegression(xs, ys, numClasses)&quot;</computeroutput>. Therefore, for <computeroutput><ref refid="classmlpack_1_1cv_1_1KFoldCV" kindref="compound">KFoldCV</ref></computeroutput> you would call the constructor <computeroutput>&quot;KFoldCV(k, xs, ys, numClasses)&quot;</computeroutput> and for <computeroutput><ref refid="classmlpack_1_1cv_1_1SimpleCV" kindref="compound">SimpleCV</ref></computeroutput> you would call the constructor <computeroutput>&quot;SimpleCV(pct, xs, ys, numClasses)&quot;</computeroutput>.</para></sect2>
<sect2 id="cv_1cvbasic_api_evaluate">
<title>The Evaluate() method</title>
<para>The other method that <computeroutput><ref refid="classmlpack_1_1cv_1_1KFoldCV" kindref="compound">KFoldCV</ref></computeroutput> and <computeroutput><ref refid="classmlpack_1_1cv_1_1SimpleCV" kindref="compound">SimpleCV</ref></computeroutput> have is the method to actually calculate the performance measure: <computeroutput>Evaluate()</computeroutput>. The <computeroutput>Evaluate()</computeroutput> method takes any hyperparameters that would follow the data arguments to the constructor or <computeroutput>Train()</computeroutput> method of the given <computeroutput>MLAlgorithm</computeroutput>. The <computeroutput>Evaluate()</computeroutput> method takes no more arguments than that, and returns the desired performance measure on the dataset.</para><para>Therefore, let us suppose that we are interested in cross-validating the performance of a softmax regression model, and that we have constructed the appropriate <computeroutput><ref refid="classmlpack_1_1cv_1_1KFoldCV" kindref="compound">KFoldCV</ref></computeroutput> object using the code below:</para><para><programlisting><codeline><highlight class="normal">KFoldCV&lt;SoftmaxRegression,<sp/>Precision&gt;<sp/>cv(k,<sp/>data,<sp/>labels,<sp/>numClasses);</highlight></codeline>
</programlisting></para><para>The <ref refid="classmlpack_1_1regression_1_1SoftmaxRegression" kindref="compound">SoftmaxRegression</ref> class has the constructor</para><para><programlisting><codeline><highlight class="normal">template&lt;typename<sp/>OptimizerType<sp/>=<sp/>mlpack::optimization::L_BFGS&gt;</highlight></codeline>
<codeline><highlight class="normal">SoftmaxRegression(const<sp/>arma::mat&amp;<sp/>data,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>arma::Row&lt;size_t&gt;&amp;<sp/>labels,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>size_t<sp/>numClasses,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>double<sp/>lambda<sp/>=<sp/>0.0001,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>bool<sp/>fitIntercept<sp/>=<sp/>false,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>OptimizerType<sp/>optimizer<sp/>=<sp/>OptimizerType());</highlight></codeline>
</programlisting></para><para>Note that all parameters after are <computeroutput>numClasses</computeroutput> are optional. This means that we can specify none or any of them in our call to <computeroutput>Evaluate()</computeroutput>. Below is some example code showing three different ways we can call <computeroutput>Evaluate()</computeroutput> with the <computeroutput>cv</computeroutput> object from the code snippet above.</para><para><programlisting><codeline><highlight class="normal">//<sp/>First,<sp/>call<sp/>with<sp/>all<sp/>defaults.</highlight></codeline>
<codeline><highlight class="normal">double<sp/>result1<sp/>=<sp/>cv.Evaluate();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Next,<sp/>call<sp/>with<sp/>lambda<sp/>set<sp/>to<sp/>0.1<sp/>and<sp/>fitIntercept<sp/>set<sp/>to<sp/>true.</highlight></codeline>
<codeline><highlight class="normal">double<sp/>result2<sp/>=<sp/>cv.Evaluate(0.1,<sp/>true);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Lastly,<sp/>create<sp/>a<sp/>custom<sp/>optimizer<sp/>to<sp/>use<sp/>for<sp/>optimization,<sp/>and<sp/>use<sp/>a<sp/>lambda</highlight></codeline>
<codeline><highlight class="normal">//<sp/>value<sp/>of<sp/>0.5<sp/>and<sp/>fit<sp/>no<sp/>intercept.</highlight></codeline>
<codeline><highlight class="normal">optimization::SGD&lt;&gt;<sp/>sgd(0.05,<sp/>50000);<sp/>//<sp/>Step<sp/>size<sp/>of<sp/>0.05,<sp/>50k<sp/>max<sp/>iterations.</highlight></codeline>
<codeline><highlight class="normal">double<sp/>result3<sp/>=<sp/>cv.Evaluate(0.5,<sp/>false,<sp/>sgd);</highlight></codeline>
</programlisting></para><para>The same general idea applies to any <computeroutput>MLAlgorithm:</computeroutput> all hyperparameters must be passed to the <computeroutput>Evaluate()</computeroutput> method of <computeroutput><ref refid="classmlpack_1_1cv_1_1KFoldCV" kindref="compound">KFoldCV</ref></computeroutput> or <computeroutput><ref refid="classmlpack_1_1cv_1_1SimpleCV" kindref="compound">SimpleCV</ref></computeroutput>.</para></sect2>
</sect1>
<sect1 id="cv_1cvbasic_further">
<title>Further references</title>
<para>For further documentation, please see the associated Doxygen documentation for each of the relevant classes:</para><para><itemizedlist>
<listitem><para><ref refid="classmlpack_1_1cv_1_1SimpleCV" kindref="compound">mlpack::cv::SimpleCV</ref></para></listitem><listitem><para><ref refid="classmlpack_1_1cv_1_1KFoldCV" kindref="compound">mlpack::cv::KFoldCV</ref></para></listitem><listitem><para><ref refid="classmlpack_1_1cv_1_1Accuracy" kindref="compound">mlpack::cv::Accuracy</ref></para></listitem><listitem><para><ref refid="classmlpack_1_1cv_1_1F1" kindref="compound">mlpack::cv::F1</ref></para></listitem><listitem><para><ref refid="classmlpack_1_1cv_1_1MSE" kindref="compound">mlpack::cv::MSE</ref></para></listitem><listitem><para><ref refid="classmlpack_1_1cv_1_1Precision" kindref="compound">mlpack::cv::Precision</ref></para></listitem><listitem><para><ref refid="classmlpack_1_1cv_1_1Recall" kindref="compound">mlpack::cv::Recall</ref></para></listitem></itemizedlist>
</para><para>If you are interested in implementing a different cross-validation strategy than k-fold cross-validation or simple cross-validation, take a look at the implementations of each of those classes to guide your implementation.</para><para>In addition, the <ref refid="namespacemlpack_1_1hpt" kindref="compound">hyperparameter tuner</ref> documentation may also be relevant. </para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
