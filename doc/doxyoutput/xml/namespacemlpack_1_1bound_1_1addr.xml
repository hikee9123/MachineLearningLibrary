<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="namespacemlpack_1_1bound_1_1addr" kind="namespace" language="C++">
    <compoundname>mlpack::bound::addr</compoundname>
      <sectiondef kind="func">
      <memberdef kind="function" id="namespacemlpack_1_1bound_1_1addr_1a55e57f732bc2f6f587b58e59d6fb918a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename AddressType</type>
          </param>
          <param>
            <type>typename VecType</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void mlpack::bound::addr::AddressToPoint</definition>
        <argsstring>(VecType &amp;point, const AddressType &amp;address)</argsstring>
        <name>AddressToPoint</name>
        <param>
          <type>VecType &amp;</type>
          <declname>point</declname>
        </param>
        <param>
          <type>const AddressType &amp;</type>
          <declname>address</declname>
        </param>
        <briefdescription>
<para>Translate the address to the point. </para>        </briefdescription>
        <detaileddescription>
<para>Be careful, the point and the address variables should be equal-sized and the type of the address should correspond to the type of the vector.</para><para>The function makes the backward transform to the function above.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>address</parametername>
</parameternamelist>
<parameterdescription>
<para>An address to translate. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>point</parametername>
</parameternamelist>
<parameterdescription>
<para>The point that corresponds to the address. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/tree/address.hpp" line="153" column="1" bodyfile="/home/aakash/mlpack/src/mlpack/core/tree/address.hpp" bodystart="153" bodyend="225"/>
      </memberdef>
      <memberdef kind="function" id="namespacemlpack_1_1bound_1_1addr_1ad39b49870fa074ad011a4d4c0ee93665" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename AddressType1</type>
          </param>
          <param>
            <type>typename AddressType2</type>
          </param>
        </templateparamlist>
        <type>int</type>
        <definition>int mlpack::bound::addr::CompareAddresses</definition>
        <argsstring>(const AddressType1 &amp;addr1, const AddressType2 &amp;addr2)</argsstring>
        <name>CompareAddresses</name>
        <param>
          <type>const AddressType1 &amp;</type>
          <declname>addr1</declname>
        </param>
        <param>
          <type>const AddressType2 &amp;</type>
          <declname>addr2</declname>
        </param>
        <briefdescription>
<para>Compare two addresses. </para>        </briefdescription>
        <detaileddescription>
<para>The function returns 1 if the first address is greater than the second one, -1 if the first address is less than the second one, otherwise the function returns 0. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/tree/address.hpp" line="233" column="1" bodyfile="/home/aakash/mlpack/src/mlpack/core/tree/address.hpp" bodystart="233" bodyend="250"/>
        <referencedby refid="namespacemlpack_1_1bound_1_1addr_1a64110a8c86f23288f4fef77ff8ac63a4" compoundref="address_8hpp" startline="256" endline="261">Contains</referencedby>
      </memberdef>
      <memberdef kind="function" id="namespacemlpack_1_1bound_1_1addr_1a64110a8c86f23288f4fef77ff8ac63a4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename AddressType1</type>
          </param>
          <param>
            <type>typename AddressType2</type>
          </param>
          <param>
            <type>typename AddressType3</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool mlpack::bound::addr::Contains</definition>
        <argsstring>(const AddressType1 &amp;address, const AddressType2 &amp;loBound, const AddressType3 &amp;hiBound)</argsstring>
        <name>Contains</name>
        <param>
          <type>const AddressType1 &amp;</type>
          <declname>address</declname>
        </param>
        <param>
          <type>const AddressType2 &amp;</type>
          <declname>loBound</declname>
        </param>
        <param>
          <type>const AddressType3 &amp;</type>
          <declname>hiBound</declname>
        </param>
        <briefdescription>
<para>Returns true if an address is contained between two other addresses. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/tree/address.hpp" line="256" column="1" bodyfile="/home/aakash/mlpack/src/mlpack/core/tree/address.hpp" bodystart="256" bodyend="261"/>
        <references refid="namespacemlpack_1_1bound_1_1addr_1ad39b49870fa074ad011a4d4c0ee93665" compoundref="address_8hpp" startline="233" endline="250">CompareAddresses</references>
        <referencedby refid="classmlpack_1_1bound_1_1HRectBound_1acc71d930ed90e73b2bc0c360835c5371" compoundref="hrectbound_8hpp" startline="113" endline="113">HRectBound&lt; MetricType &gt;::Metric</referencedby>
      </memberdef>
      <memberdef kind="function" id="namespacemlpack_1_1bound_1_1addr_1acfd59826c56bc489ec735101a942eb79" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename AddressType</type>
          </param>
          <param>
            <type>typename VecType</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void mlpack::bound::addr::PointToAddress</definition>
        <argsstring>(AddressType &amp;address, const VecType &amp;point)</argsstring>
        <name>PointToAddress</name>
        <param>
          <type>AddressType &amp;</type>
          <declname>address</declname>
        </param>
        <param>
          <type>const VecType &amp;</type>
          <declname>point</declname>
        </param>
        <briefdescription>
<para>Calculate the address of a point. </para>        </briefdescription>
        <detaileddescription>
<para>Be careful, the point and the address variables should be equal-sized and the type of the address should correspond to the type of the vector.</para><para>The function maps each floating point coordinate to an equal-sized unsigned integer datatype in such a way that the transform preserves the ordering (i.e. lower floating point values correspond to lower integers). Thus, the mapping saves the exponent and the mantissa of each floating point value consequently, furthermore the exponent is stored before the mantissa. In the case of negative numbers the resulting integer value should be inverted. In the multi-dimensional case, after we transform the representation, we have to interleave the bits of the new representation across all the elements in the address vector.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>address</parametername>
</parameternamelist>
<parameterdescription>
<para>The resulting address. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>point</parametername>
</parameternamelist>
<parameterdescription>
<para>The point that is being translated to the address.</para></parameterdescription>
</parameteritem>
</parameterlist>
mlpack is free software; you may redistribute it and/or modify it under the terms of the 3-clause BSD license. You should have received a copy of the 3-clause BSD license along with mlpack. If not, see <ulink url="http://www.opensource.org/licenses/BSD-3-Clause">http://www.opensource.org/licenses/BSD-3-Clause</ulink> for more information. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/aakash/mlpack/src/mlpack/core/tree/address.hpp" line="57" column="1" bodyfile="/home/aakash/mlpack/src/mlpack/core/tree/address.hpp" bodystart="57" bodyend="140"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="/home/aakash/mlpack/src/mlpack/core/tree/address.hpp" line="31" column="1"/>
  </compounddef>
</doxygen>
