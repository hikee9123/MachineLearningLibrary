<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="function" kind="page">
    <compoundname>function</compoundname>
    <title>The FunctionType policy in mlpack</title>
    <detaileddescription>
<sect1 id="function_1Overview">
<title>Overview</title>
<para>To represent the various types of loss functions encountered in machine learning problems, mlpack provides the <computeroutput>FunctionType</computeroutput> template parameter in the optimizer interface. The various optimizers available in the core library rely on this policy to gain the necessary information required by the optimizing algorithm.</para><para>The <computeroutput>FunctionType</computeroutput> template parameter required by the Optimizer class can have additional requirements imposed on it, depending on the type of optimizer used.</para></sect1>
<sect1 id="function_1requirements">
<title>Interface requirements</title>
<para>The most basic requirements for the <computeroutput>FunctionType</computeroutput> parameter are the implementations of two public member functions, with the following interface and semantics</para><para><programlisting><codeline><highlight class="normal">//<sp/>Evaluate<sp/>the<sp/>loss<sp/>function<sp/>at<sp/>the<sp/>given<sp/>coordinates.</highlight></codeline>
<codeline><highlight class="normal">double<sp/>Evaluate(const<sp/>arma::mat&amp;<sp/>coordinates);</highlight></codeline>
</programlisting></para><para><programlisting><codeline><highlight class="normal">//<sp/>Evaluate<sp/>the<sp/>gradient<sp/>at<sp/>the<sp/>given<sp/>coordinates,<sp/>where<sp/>&apos;gradient&apos;<sp/>is<sp/>an</highlight></codeline>
<codeline><highlight class="normal">//<sp/>output<sp/>parameter<sp/>for<sp/>the<sp/>required<sp/>gradient.</highlight></codeline>
<codeline><highlight class="normal">void<sp/>Gradient(const<sp/>arma::mat&amp;<sp/>coordinates,<sp/>arma::mat&amp;<sp/>gradient);</highlight></codeline>
</programlisting></para><para>Optimizers like SGD and RMSProp require a <computeroutput>DecomposableFunctionType</computeroutput> having the following requirements</para><para><programlisting><codeline><highlight class="normal">//<sp/>Return<sp/>the<sp/>number<sp/>of<sp/>functions.<sp/>In<sp/>a<sp/>data-dependent<sp/>function,<sp/>this<sp/>would</highlight></codeline>
<codeline><highlight class="normal">//<sp/>return<sp/>the<sp/>number<sp/>of<sp/>points<sp/>in<sp/>the<sp/>dataset.</highlight></codeline>
<codeline><highlight class="normal">size_t<sp/>NumFunctions();</highlight></codeline>
</programlisting></para><para><programlisting><codeline><highlight class="normal">//<sp/>Evaluate<sp/>the<sp/>&apos;i&apos;<sp/>th<sp/>loss<sp/>function.<sp/>For<sp/>example,<sp/>for<sp/>a<sp/>data-dependent</highlight></codeline>
<codeline><highlight class="normal">//<sp/>function,<sp/>Evaluate(coordinates,<sp/>0)<sp/>should<sp/>evaluate<sp/>the<sp/>loss<sp/>function<sp/>at<sp/>the</highlight></codeline>
<codeline><highlight class="normal">//<sp/>first<sp/>point<sp/>in<sp/>the<sp/>dataset.</highlight></codeline>
<codeline><highlight class="normal">double<sp/>Evaluate(const<sp/>arma::mat&amp;<sp/>coordinates,<sp/>const<sp/>size_t<sp/>i);</highlight></codeline>
</programlisting></para><para><programlisting><codeline><highlight class="normal">//<sp/>Evaluate<sp/>the<sp/>gradient<sp/>of<sp/>the<sp/>&apos;i&apos;<sp/>th<sp/>loss<sp/>function<sp/>at<sp/>the<sp/>given<sp/>coordinates,</highlight></codeline>
<codeline><highlight class="normal">//<sp/>where<sp/>&apos;gradient&apos;<sp/>is<sp/>an<sp/>output<sp/>parameter<sp/>for<sp/>the<sp/>required<sp/>gradient.</highlight></codeline>
<codeline><highlight class="normal">void<sp/>Gradient(const<sp/>arma::mat&amp;<sp/>coordinates,<sp/>const<sp/>size_t<sp/>i,<sp/>arma::mat&amp;<sp/>gradient);</highlight></codeline>
</programlisting></para><para><computeroutput>ParallelSGD</computeroutput> optimizer requires a <computeroutput>SparseFunctionType</computeroutput> interface. <computeroutput>SparseFunctionType</computeroutput> requires the gradient to be in a sparse matrix (<computeroutput>arma::sp_mat</computeroutput>), as ParallelSGD, implemented with the HOGWILD! scheme of unsynchronised updates, is expected to be relevant only in situations where the individual gradients are sparse. So, the interface requires function with the following signatures</para><para><programlisting><codeline><highlight class="normal">//<sp/>Return<sp/>the<sp/>number<sp/>of<sp/>functions.<sp/>In<sp/>a<sp/>data-dependent<sp/>function,<sp/>this<sp/>would</highlight></codeline>
<codeline><highlight class="normal">//<sp/>return<sp/>the<sp/>number<sp/>of<sp/>points<sp/>in<sp/>the<sp/>dataset.</highlight></codeline>
<codeline><highlight class="normal">size_t<sp/>NumFunctions();</highlight></codeline>
</programlisting></para><para><programlisting><codeline><highlight class="normal">//<sp/>Evaluate<sp/>the<sp/>loss<sp/>function<sp/>at<sp/>the<sp/>given<sp/>coordinates.</highlight></codeline>
<codeline><highlight class="normal">double<sp/>Evaluate(const<sp/>arma::mat&amp;<sp/>coordinates);</highlight></codeline>
</programlisting></para><para><programlisting><codeline><highlight class="normal">//<sp/>Evaluate<sp/>the<sp/>(sparse)<sp/>gradient<sp/>of<sp/>the<sp/>&apos;i&apos;<sp/>th<sp/>loss<sp/>function<sp/>at<sp/>the<sp/>given</highlight></codeline>
<codeline><highlight class="normal">//<sp/>coordinates,<sp/>where<sp/>&apos;gradient&apos;<sp/>is<sp/>an<sp/>output<sp/>parameter<sp/>for<sp/>the<sp/>required</highlight></codeline>
<codeline><highlight class="normal">//<sp/>gradient.</highlight></codeline>
<codeline><highlight class="normal">void<sp/>Gradient(const<sp/>arma::mat&amp;<sp/>coordinates,<sp/>const<sp/>size_t<sp/>i,<sp/>arma::sp_mat&amp;<sp/>gradient);</highlight></codeline>
</programlisting></para><para>The <computeroutput>SCD</computeroutput> optimizer requires a <computeroutput>ResolvableFunctionType</computeroutput> interface, to calculate partial gradients with respect to individual features. The optimizer requires the decision variable to be arranged in a particular fashion to allow for disjoint updates. The features should be arranged columnwise in the decision variable. For example, in <computeroutput>SoftmaxRegressionFunction</computeroutput> the decision variable has size <computeroutput>numClasses</computeroutput> x <computeroutput>featureSize</computeroutput> (+ 1 if an intercept also needs to be fit). Similarly, for <computeroutput>LogisticRegression</computeroutput>, the decision variable is a row vector, with the number of columns determined by the dimensionality of the dataset.</para><para>The interface expects the following member functions from the function class</para><para><programlisting><codeline><highlight class="normal">//<sp/>Return<sp/>the<sp/>number<sp/>of<sp/>features<sp/>in<sp/>the<sp/>decision<sp/>variable.</highlight></codeline>
<codeline><highlight class="normal">size_t<sp/>NumFeatures();</highlight></codeline>
</programlisting></para><para><programlisting><codeline><highlight class="normal">//<sp/>Evaluate<sp/>the<sp/>loss<sp/>function<sp/>at<sp/>the<sp/>given<sp/>coordinates.</highlight></codeline>
<codeline><highlight class="normal">double<sp/>Evaluate(const<sp/>arma::mat&amp;<sp/>coordinates);</highlight></codeline>
</programlisting></para><para><programlisting><codeline><highlight class="normal">//<sp/>Evaluate<sp/>the<sp/>partial<sp/>gradient<sp/>of<sp/>the<sp/>loss<sp/>function<sp/>with<sp/>respect<sp/>to<sp/>the<sp/>&apos;j&apos;<sp/>th</highlight></codeline>
<codeline><highlight class="normal">//<sp/>coordinate<sp/>at<sp/>the<sp/>given<sp/>coordinates,<sp/>where<sp/>&apos;gradient&apos;<sp/>is<sp/>an<sp/>output<sp/>parameter</highlight></codeline>
<codeline><highlight class="normal">//<sp/>for<sp/>the<sp/>required<sp/>gradient.<sp/>The<sp/>&apos;gradient&apos;<sp/>matrix<sp/>is<sp/>supposed<sp/>to<sp/>be<sp/>non-zero</highlight></codeline>
<codeline><highlight class="normal">//<sp/>in<sp/>the<sp/>jth<sp/>column,<sp/>which<sp/>contains<sp/>the<sp/>relevant<sp/>partial<sp/>gradient.</highlight></codeline>
<codeline><highlight class="normal">void<sp/>PartialGradient(const<sp/>arma::mat&amp;<sp/>coordinates,<sp/>const<sp/>size_t<sp/>j,<sp/>arma::sp_mat&amp;<sp/>gradient);</highlight></codeline>
</programlisting> </para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
