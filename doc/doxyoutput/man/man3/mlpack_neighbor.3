.TH "mlpack::neighbor" 3 "Thu Jun 24 2021" "Version 3.4.2" "mlpack" \" -*- nroff -*-
.ad l
.nh
.SH NAME
mlpack::neighbor
.SH SYNOPSIS
.br
.PP
.SS "Classes"

.in +1c
.ti -1c
.RI "class \fBDrusillaSelect\fP"
.br
.ti -1c
.RI "class \fBFurthestNS\fP"
.br
.RI "This class implements the necessary methods for the SortPolicy template parameter of the \fBNeighborSearch\fP class\&. "
.ti -1c
.RI "class \fBLeafSizeNSWrapper\fP"
.br
.RI "\fBLeafSizeNSWrapper\fP wraps any \fBNeighborSearch\fP types that take a leaf size for tree construction\&. "
.ti -1c
.RI "class \fBLeafSizeRAWrapper\fP"
.br
.RI "\fBLeafSizeRAWrapper\fP wraps any \fBRASearch\fP type that needs to be able to take the leaf size into account when building trees\&. "
.ti -1c
.RI "class \fBLSHSearch\fP"
.br
.RI "The \fBLSHSearch\fP class; this class builds a hash on the reference set and uses this hash to compute the distance-approximate nearest-neighbors of the given queries\&. "
.ti -1c
.RI "class \fBNearestNS\fP"
.br
.RI "This class implements the necessary methods for the SortPolicy template parameter of the \fBNeighborSearch\fP class\&. "
.ti -1c
.RI "class \fBNeighborSearch\fP"
.br
.RI "The \fBNeighborSearch\fP class is a template class for performing distance-based neighbor searches\&. "
.ti -1c
.RI "class \fBNeighborSearchRules\fP"
.br
.RI "The \fBNeighborSearchRules\fP class is a template helper class used by \fBNeighborSearch\fP class when performing distance-based neighbor searches\&. "
.ti -1c
.RI "class \fBNeighborSearchStat\fP"
.br
.RI "Extra data for each node in the tree\&. "
.ti -1c
.RI "class \fBNSModel\fP"
.br
.RI "The \fBNSModel\fP class provides an easy way to serialize a model, abstracts away the different types of trees, and also reflects the \fBNeighborSearch\fP API\&. "
.ti -1c
.RI "class \fBNSWrapper\fP"
.br
.RI "\fBNSWrapper\fP is a wrapper class for most \fBNeighborSearch\fP types\&. "
.ti -1c
.RI "class \fBNSWrapperBase\fP"
.br
.RI "\fBNSWrapperBase\fP is a base wrapper class for holding all \fBNeighborSearch\fP types supported by \fBNSModel\fP\&. "
.ti -1c
.RI "class \fBQDAFN\fP"
.br
.ti -1c
.RI "class \fBRAModel\fP"
.br
.RI "The \fBRAModel\fP class provides an abstraction for the \fBRASearch\fP class, abstracting away the TreeType parameter and allowing it to be specified at runtime in this class\&. "
.ti -1c
.RI "class \fBRAQueryStat\fP"
.br
.RI "Extra data for each node in the tree\&. "
.ti -1c
.RI "class \fBRASearch\fP"
.br
.RI "The \fBRASearch\fP class: This class provides a generic manner to perform rank-approximate search via random-sampling\&. "
.ti -1c
.RI "class \fBRASearchRules\fP"
.br
.RI "The \fBRASearchRules\fP class is a template helper class used by \fBRASearch\fP class when performing rank-approximate search via random-sampling\&. "
.ti -1c
.RI "class \fBRAUtil\fP"
.br
.ti -1c
.RI "class \fBRAWrapper\fP"
.br
.RI "\fBRAWrapper\fP is a wrapper class for most \fBRASearch\fP types\&. "
.ti -1c
.RI "class \fBRAWrapperBase\fP"
.br
.RI "\fBRAWrapperBase\fP is a base wrapper class for holding all \fBRASearch\fP types supported by \fBRAModel\fP\&. "
.ti -1c
.RI "class \fBSpillNSWrapper\fP"
.br
.RI "The \fBSpillNSWrapper\fP class wraps the \fBNeighborSearch\fP class when the spill tree is used\&. "
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "template<template< typename TreeMetricType, typename TreeStatType, typename TreeMatType > class TreeType = tree::SPTree> using \fBDefeatistKNN\fP = \fBNeighborSearch\fP< \fBNearestNeighborSort\fP, \fBmetric::EuclideanDistance\fP, arma::mat, TreeType, TreeType< \fBmetric::EuclideanDistance\fP, \fBNeighborSearchStat\fP< \fBNearestNeighborSort\fP >, arma::mat >::template DefeatistDualTreeTraverser, TreeType< \fBmetric::EuclideanDistance\fP, \fBNeighborSearchStat\fP< \fBNearestNeighborSort\fP >, arma::mat >::template DefeatistSingleTreeTraverser >"
.br
.RI "The DefeatistKNN class is the k-nearest-neighbors method considering defeatist search\&. "
.ti -1c
.RI "using \fBFurthestNeighborSort\fP = \fBFurthestNS\fP"
.br
.ti -1c
.RI "typedef \fBNeighborSearch\fP< \fBFurthestNeighborSort\fP, \fBmetric::EuclideanDistance\fP > \fBKFN\fP"
.br
.RI "The KFN class is the k-furthest-neighbors method\&. "
.ti -1c
.RI "typedef \fBNeighborSearch\fP< \fBNearestNeighborSort\fP, \fBmetric::EuclideanDistance\fP > \fBKNN\fP"
.br
.RI "The KNN class is the k-nearest-neighbors method\&. "
.ti -1c
.RI "typedef \fBRASearch\fP< \fBFurthestNeighborSort\fP > \fBKRAFN\fP"
.br
.RI "The KRAFN class is the k-rank-approximate-farthest-neighbors method\&. "
.ti -1c
.RI "typedef \fBRASearch\fP \fBKRANN\fP"
.br
.RI "The KRANN class is the k-rank-approximate-nearest-neighbors method\&. "
.ti -1c
.RI "using \fBNearestNeighborSort\fP = \fBNearestNS\fP"
.br
.ti -1c
.RI "typedef \fBDefeatistKNN\fP< \fBtree::SPTree\fP > \fBSpillKNN\fP"
.br
.RI "The SpillKNN class is the k-nearest-neighbors method considering defeatist search on SPTree\&. "
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBNeighborSearchMode\fP { \fBNAIVE_MODE\fP, \fBSINGLE_TREE_MODE\fP, \fBDUAL_TREE_MODE\fP, \fBGREEDY_SINGLE_TREE_MODE\fP }
.RI "NeighborSearchMode represents the different neighbor search modes available\&. ""
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBUnmap\fP (const arma::Mat< size_t > &neighbors, const arma::mat &distances, const std::vector< size_t > &referenceMap, const std::vector< size_t > &queryMap, arma::Mat< size_t > &neighborsOut, arma::mat &distancesOut, const bool squareRoot=false)"
.br
.RI "Assuming that the datasets have been mapped using the referenceMap and the queryMap (such as during kd-tree construction), unmap the columns of the distances and neighbors matrices into neighborsOut and distancesOut, and also unmap the entries in each row of neighbors\&. "
.ti -1c
.RI "void \fBUnmap\fP (const arma::Mat< size_t > &neighbors, const arma::mat &distances, const std::vector< size_t > &referenceMap, arma::Mat< size_t > &neighborsOut, arma::mat &distancesOut, const bool squareRoot=false)"
.br
.RI "Assuming that the datasets have been mapped using referenceMap (such as during kd-tree construction), unmap the columns of the distances and neighbors matrices into neighborsOut and distancesOut, and also unmap the entries in each row of neighbors\&. "
.in -1c
.SH "Typedef Documentation"
.PP 
.SS "using \fBDefeatistKNN\fP =  \fBNeighborSearch\fP< \fBNearestNeighborSort\fP, \fBmetric::EuclideanDistance\fP, arma::mat, TreeType, TreeType<\fBmetric::EuclideanDistance\fP, \fBNeighborSearchStat\fP<\fBNearestNeighborSort\fP>, arma::mat>::template DefeatistDualTreeTraverser, TreeType<\fBmetric::EuclideanDistance\fP, \fBNeighborSearchStat\fP<\fBNearestNeighborSort\fP>, arma::mat>::template DefeatistSingleTreeTraverser>"

.PP
The DefeatistKNN class is the k-nearest-neighbors method considering defeatist search\&. It returns L2 distances (Euclidean distances) for each of the k nearest neighbors found\&. 
.PP
\fBTemplate Parameters:\fP
.RS 4
\fITreeType\fP The tree type to use; must adhere to the TreeType API, and implement Defeatist Traversers\&. 
.RE
.PP

.PP
Definition at line 60 of file typedef\&.hpp\&.
.SS "using \fBFurthestNeighborSort\fP =  \fBFurthestNS\fP"

.PP
Definition at line 201 of file furthest_neighbor_sort\&.hpp\&.
.SS "typedef \fBNeighborSearch\fP<\fBFurthestNeighborSort\fP, \fBmetric::EuclideanDistance\fP> \fBKFN\fP"

.PP
The KFN class is the k-furthest-neighbors method\&. It returns L2 distances (Euclidean distances) for each of the k furthest neighbors\&. 
.PP
Definition at line 38 of file typedef\&.hpp\&.
.SS "typedef \fBNeighborSearch\fP<\fBNearestNeighborSort\fP, \fBmetric::EuclideanDistance\fP> \fBKNN\fP"

.PP
The KNN class is the k-nearest-neighbors method\&. It returns L2 distances (Euclidean distances) for each of the k nearest neighbors\&. 
.PP
Definition at line 32 of file typedef\&.hpp\&.
.SS "typedef \fBRASearch\fP<\fBFurthestNeighborSort\fP> \fBKRAFN\fP"

.PP
The KRAFN class is the k-rank-approximate-farthest-neighbors method\&. It returns L2 distances for each of the k rank-approximate farthest-neighbors\&.
.PP
The approximation is controlled with two parameters (see allkrann_main\&.cpp) which can be specified at search time\&. So the tree building is done only once while the search can be performed multiple times with different approximation levels\&. 
.PP
Definition at line 47 of file ra_typedef\&.hpp\&.
.SS "typedef \fBRASearch\fP \fBKRANN\fP"

.PP
The KRANN class is the k-rank-approximate-nearest-neighbors method\&. It returns L2 distances for each of the k rank-approximate nearest-neighbors\&.
.PP
The approximation is controlled with two parameters (see allkrann_main\&.cpp) which can be specified at search time\&. So the tree building is done only once while the search can be performed multiple times with different approximation levels\&. 
.PP
Definition at line 36 of file ra_typedef\&.hpp\&.
.SS "using \fBNearestNeighborSort\fP =  \fBNearestNS\fP"

.PP
Definition at line 200 of file nearest_neighbor_sort\&.hpp\&.
.SS "typedef \fBDefeatistKNN\fP<\fBtree::SPTree\fP> \fBSpillKNN\fP"

.PP
The SpillKNN class is the k-nearest-neighbors method considering defeatist search on SPTree\&. It returns L2 distances (Euclidean distances) for each of the k nearest neighbors found\&. 
.PP
Definition at line 67 of file typedef\&.hpp\&.
.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBNeighborSearchMode\fP"

.PP
NeighborSearchMode represents the different neighbor search modes available\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fINAIVE_MODE \fP\fP
.TP
\fB\fISINGLE_TREE_MODE \fP\fP
.TP
\fB\fIDUAL_TREE_MODE \fP\fP
.TP
\fB\fIGREEDY_SINGLE_TREE_MODE \fP\fP
.PP
Definition at line 43 of file neighbor_search\&.hpp\&.
.SH "Function Documentation"
.PP 
.SS "void mlpack::neighbor::Unmap (const arma::Mat< size_t > & neighbors, const arma::mat & distances, const std::vector< size_t > & referenceMap, const std::vector< size_t > & queryMap, arma::Mat< size_t > & neighborsOut, arma::mat & distancesOut, const bool squareRoot = \fCfalse\fP)"

.PP
Assuming that the datasets have been mapped using the referenceMap and the queryMap (such as during kd-tree construction), unmap the columns of the distances and neighbors matrices into neighborsOut and distancesOut, and also unmap the entries in each row of neighbors\&. This is useful for the dual-tree case\&.
.PP
\fBParameters:\fP
.RS 4
\fIneighbors\fP Matrix of neighbors resulting from neighbor search\&. 
.br
\fIdistances\fP Matrix of distances resulting from neighbor search\&. 
.br
\fIreferenceMap\fP Mapping of reference set to old points\&. 
.br
\fIqueryMap\fP Mapping of query set to old points\&. 
.br
\fIneighborsOut\fP Matrix to store unmapped neighbors into\&. 
.br
\fIdistancesOut\fP Matrix to store unmapped distances into\&. 
.br
\fIsquareRoot\fP If true, take the square root of the distances\&. 
.RE
.PP

.SS "void mlpack::neighbor::Unmap (const arma::Mat< size_t > & neighbors, const arma::mat & distances, const std::vector< size_t > & referenceMap, arma::Mat< size_t > & neighborsOut, arma::mat & distancesOut, const bool squareRoot = \fCfalse\fP)"

.PP
Assuming that the datasets have been mapped using referenceMap (such as during kd-tree construction), unmap the columns of the distances and neighbors matrices into neighborsOut and distancesOut, and also unmap the entries in each row of neighbors\&. This is useful for the single-tree case\&.
.PP
\fBParameters:\fP
.RS 4
\fIneighbors\fP Matrix of neighbors resulting from neighbor search\&. 
.br
\fIdistances\fP Matrix of distances resulting from neighbor search\&. 
.br
\fIreferenceMap\fP Mapping of reference set to old points\&. 
.br
\fIneighborsOut\fP Matrix to store unmapped neighbors into\&. 
.br
\fIdistancesOut\fP Matrix to store unmapped distances into\&. 
.br
\fIsquareRoot\fP If true, take the square root of the distances\&. 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for mlpack from the source code\&.
