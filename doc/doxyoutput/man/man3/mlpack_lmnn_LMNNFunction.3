.TH "LMNNFunction< MetricType >" 3 "Thu Jun 24 2021" "Version 3.4.2" "mlpack" \" -*- nroff -*-
.ad l
.nh
.SH NAME
LMNNFunction< MetricType > \- The Large Margin Nearest Neighbors function\&.  

.SH SYNOPSIS
.br
.PP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBLMNNFunction\fP (const arma::mat &dataset, const arma::Row< size_t > &labels, size_t k, double regularization, size_t range, MetricType metric=MetricType())"
.br
.RI "Constructor for \fBLMNNFunction\fP class\&. "
.ti -1c
.RI "const arma::mat & \fBDataset\fP () const"
.br
.RI "Return the dataset passed into the constructor\&. "
.ti -1c
.RI "double \fBEvaluate\fP (const arma::mat &transformation)"
.br
.RI "Evaluate the \fBLMNN\fP function for the given transformation matrix\&. "
.ti -1c
.RI "double \fBEvaluate\fP (const arma::mat &transformation, const size_t begin, const size_t batchSize=1)"
.br
.RI "Evaluate the \fBLMNN\fP objective function for the given transformation matrix on the given batch size from a given inital point of the dataset\&. "
.ti -1c
.RI "template<typename GradType > double \fBEvaluateWithGradient\fP (const arma::mat &transformation, GradType &gradient)"
.br
.RI "Evaluate the \fBLMNN\fP objective function together with gradient for the given transformation matrix\&. "
.ti -1c
.RI "template<typename GradType > double \fBEvaluateWithGradient\fP (const arma::mat &transformation, const size_t begin, GradType &gradient, const size_t batchSize=1)"
.br
.RI "Evaluate the \fBLMNN\fP objective function together with gradient for the given transformation matrix on the given batch size, from a given initial point of the dataset\&. "
.ti -1c
.RI "const arma::mat & \fBGetInitialPoint\fP () const"
.br
.RI "Return the initial point for the optimization\&. "
.ti -1c
.RI "template<typename GradType > void \fBGradient\fP (const arma::mat &transformation, GradType &gradient)"
.br
.RI "Evaluate the gradient of the \fBLMNN\fP function for the given transformation matrix\&. "
.ti -1c
.RI "template<typename GradType > void \fBGradient\fP (const arma::mat &transformation, const size_t begin, GradType &gradient, const size_t batchSize=1)"
.br
.RI "Evaluate the gradient of the \fBLMNN\fP function for the given transformation matrix on the given batch size, from a given initial point of the dataset\&. "
.ti -1c
.RI "const size_t & \fBK\fP () const"
.br
.RI "Access the value of k\&. "
.ti -1c
.RI "size_t & \fBK\fP ()"
.br
.RI "Modify the value of k\&. "
.ti -1c
.RI "size_t \fBNumFunctions\fP () const"
.br
.RI "Get the number of functions the objective function can be decomposed into\&. "
.ti -1c
.RI "const size_t & \fBRange\fP () const"
.br
.RI "Access the value of range\&. "
.ti -1c
.RI "size_t & \fBRange\fP ()"
.br
.RI "Modify the value of k\&. "
.ti -1c
.RI "const double & \fBRegularization\fP () const"
.br
.RI "Access the regularization value\&. "
.ti -1c
.RI "double & \fBRegularization\fP ()"
.br
.RI "Modify the regularization value\&. "
.ti -1c
.RI "void \fBShuffle\fP ()"
.br
.RI "Shuffle the points in the dataset\&. "
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename MetricType = metric::SquaredEuclideanDistance>
.br
class mlpack::lmnn::LMNNFunction< MetricType >"
The Large Margin Nearest Neighbors function\&. 

The actual function is
.PP
$ \epsilon(M) = \sum_{ij}\eta_{ij}|| L x_i - L x_j ||^2 + c\sum_{ijl}\eta_{ij}(1-y_{il})[1 + || L x_i - L x_j ||^2 - || L x_i - L x_l ||^2)]_{+} $.PP
where x_n represents a point and A is the current scaling matrix\&.
.PP
This class is more flexible than the original paper, allowing an arbitrary metric function to be used in place of || A x_i - A x_j ||^2, meaning that the squared Euclidean distance is not the only allowed metric for \fBLMNN\fP\&. However, that is probably the best way to use this class\&.
.PP
In addition to the standard \fBEvaluate()\fP and \fBGradient()\fP functions which mlpack optimizers use, overloads of \fBEvaluate()\fP and \fBGradient()\fP are given which only operate on one point in the dataset\&. This is useful for optimizers like stochastic gradient descent (see ens::SGD)\&. 
.PP
Definition at line 46 of file lmnn_function\&.hpp\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "\fBLMNNFunction\fP (const arma::mat & dataset, const arma::Row< size_t > & labels, size_t k, double regularization, size_t range, MetricType metric = \fCMetricType()\fP)"

.PP
Constructor for \fBLMNNFunction\fP class\&. 
.PP
\fBParameters:\fP
.RS 4
\fIdataset\fP Input dataset\&. 
.br
\fIlabels\fP Input dataset labels\&. 
.br
\fIk\fP Number of target neighbors to be used\&. 
.br
\fIregularization\fP Regularization value\&. 
.br
\fIrange\fP Range after which impostors need to be recalculated\&. 
.br
\fImetric\fP Type of metric used for computation\&. 
.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "const arma::mat& Dataset () const\fC [inline]\fP"

.PP
Return the dataset passed into the constructor\&. 
.PP
Definition at line 175 of file lmnn_function\&.hpp\&.
.SS "double Evaluate (const arma::mat & transformation)"

.PP
Evaluate the \fBLMNN\fP function for the given transformation matrix\&. This is the non-separable implementation, where the objective function is not decomposed into the sum of several objective functions\&.
.PP
\fBParameters:\fP
.RS 4
\fItransformation\fP Transformation matrix of Mahalanobis distance\&. 
.RE
.PP

.SS "double Evaluate (const arma::mat & transformation, const size_t begin, const size_t batchSize = \fC1\fP)"

.PP
Evaluate the \fBLMNN\fP objective function for the given transformation matrix on the given batch size from a given inital point of the dataset\&. This is the separable implementation, where the objective function is decomposed into the sum of many objective functions, and here, only one of those constituent objective functions is returned\&.
.PP
\fBParameters:\fP
.RS 4
\fItransformation\fP Transformation matrix of Mahalanobis distance\&. 
.br
\fIbegin\fP Index of the initial point to use for objective function\&. 
.br
\fIbatchSize\fP Number of points to use for objective function\&. 
.RE
.PP

.SS "double EvaluateWithGradient (const arma::mat & transformation, GradType & gradient)"

.PP
Evaluate the \fBLMNN\fP objective function together with gradient for the given transformation matrix\&. This is the non-separable implementation, where the objective function is not decomposed into the sum of several objective functions\&.
.PP
\fBTemplate Parameters:\fP
.RS 4
\fIGradType\fP The type of the gradient out-param\&. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fItransformation\fP Transformation matrix of Mahalanobis distance\&. 
.br
\fIgradient\fP Matrix to store the calculated gradient in\&. 
.RE
.PP

.SS "double EvaluateWithGradient (const arma::mat & transformation, const size_t begin, GradType & gradient, const size_t batchSize = \fC1\fP)"

.PP
Evaluate the \fBLMNN\fP objective function together with gradient for the given transformation matrix on the given batch size, from a given initial point of the dataset\&. This is the separable implementation, where the objective function is decomposed into the sum of many objective functions, and here, only one of those constituent objective functions is returned\&. The type of the gradient parameter is a template argument to allow the computation of a sparse gradient\&.
.PP
\fBTemplate Parameters:\fP
.RS 4
\fIGradType\fP The type of the gradient out-param\&. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fItransformation\fP Transformation matrix of Mahalanobis distance\&. 
.br
\fIbegin\fP Index of the initial point to use for objective function\&. 
.br
\fIgradient\fP Matrix to store the calculated gradient in\&. 
.br
\fIbatchSize\fP Number of points to use for objective function\&. 
.RE
.PP

.SS "const arma::mat& GetInitialPoint () const\fC [inline]\fP"

.PP
Return the initial point for the optimization\&. 
.PP
Definition at line 166 of file lmnn_function\&.hpp\&.
.SS "void Gradient (const arma::mat & transformation, GradType & gradient)"

.PP
Evaluate the gradient of the \fBLMNN\fP function for the given transformation matrix\&. This is the non-separable implementation, where the objective function is not decomposed into the sum of several objective functions\&.
.PP
\fBTemplate Parameters:\fP
.RS 4
\fIGradType\fP The type of the gradient out-param\&. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fItransformation\fP Transformation matrix of Mahalanobis distance\&. 
.br
\fIgradient\fP Matrix to store the calculated gradient in\&. 
.RE
.PP

.SS "void Gradient (const arma::mat & transformation, const size_t begin, GradType & gradient, const size_t batchSize = \fC1\fP)"

.PP
Evaluate the gradient of the \fBLMNN\fP function for the given transformation matrix on the given batch size, from a given initial point of the dataset\&. This is the separable implementation, where the objective function is decomposed into the sum of many objective functions, and here, only one of those constituent objective functions is returned\&. The type of the gradient parameter is a template argument to allow the computation of a sparse gradient\&.
.PP
\fBTemplate Parameters:\fP
.RS 4
\fIGradType\fP The type of the gradient out-param\&. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fItransformation\fP Transformation matrix of Mahalanobis distance\&. 
.br
\fIbegin\fP Index of the initial point to use for objective function\&. 
.br
\fIgradient\fP Matrix to store the calculated gradient in\&. 
.br
\fIbatchSize\fP Number of points to use for objective function\&. 
.RE
.PP

.SS "const size_t& K () const\fC [inline]\fP"

.PP
Access the value of k\&. 
.PP
Definition at line 183 of file lmnn_function\&.hpp\&.
.SS "size_t& K ()\fC [inline]\fP"

.PP
Modify the value of k\&. 
.PP
Definition at line 185 of file lmnn_function\&.hpp\&.
.SS "size_t NumFunctions () const\fC [inline]\fP"

.PP
Get the number of functions the objective function can be decomposed into\&. This is just the number of points in the dataset\&. 
.PP
Definition at line 172 of file lmnn_function\&.hpp\&.
.SS "const size_t& Range () const\fC [inline]\fP"

.PP
Access the value of range\&. 
.PP
Definition at line 188 of file lmnn_function\&.hpp\&.
.SS "size_t& Range ()\fC [inline]\fP"

.PP
Modify the value of k\&. 
.PP
Definition at line 190 of file lmnn_function\&.hpp\&.
.SS "const double& Regularization () const\fC [inline]\fP"

.PP
Access the regularization value\&. 
.PP
Definition at line 178 of file lmnn_function\&.hpp\&.
.SS "double& Regularization ()\fC [inline]\fP"

.PP
Modify the regularization value\&. 
.PP
Definition at line 180 of file lmnn_function\&.hpp\&.
.SS "void Shuffle ()"

.PP
Shuffle the points in the dataset\&. This may be used by optimizers\&. 

.SH "Author"
.PP 
Generated automatically by Doxygen for mlpack from the source code\&.
