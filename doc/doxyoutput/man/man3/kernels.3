.TH "kernels" 3 "Sun Aug 22 2021" "Version 3.4.2" "mlpack" \" -*- nroff -*-
.ad l
.nh
.SH NAME
kernelsThe KernelType policy in mlpack 
 \- 
.SH "Table of Contents"
.PP
.IP "\(bu" 2
\fBIntroduction to the KernelType policy\fP
.IP "\(bu" 2
\fBThe KernelTraits trait class\fP
.IP "\(bu" 2
\fBList of kernels and classes that use a \fCKernelType\fP \fP
.PP
.SH "Introduction to the KernelType policy"
.PP
`Kernel methods' make up a large class of machine learning techniques\&. Each of these methods is characterized by its dependence on a \fBkernel\fP \fBfunction\fP\&. In rough terms, a kernel function is a general notion of similarity between two points, with its value large when objects are similar and its value small when objects are dissimilar (note that this is not the only interpretation of what a kernel is)\&.
.PP
A kernel (or `Mercer kernel') $\mathcal{K}(\cdot, \cdot)$ takes two objects as input and returns some sort of similarity value\&. The specific details and properties of kernels are outside the scope of this documentation; for a better introduction to kernels and kernel methods, there are numerous better resources available, including \fCEric Kim's tutorial\fP
.PP
mlpack implements a number of kernel methods and, accordingly, each of these methods allows arbitrary kernels to be used via the \fCKernelType\fP template parameter\&. Like the \fBMetricType policy\fP, the requirements are quite simple: a class implementing the \fCKernelType\fP policy must have
.PP
.IP "\(bu" 2
an \fCEvaluate()\fP function
.IP "\(bu" 2
a default constructor
.PP
.PP
The signature of the \fCEvaluate()\fP function is straightforward:
.PP
.PP
.nf
template<typename VecTypeA, typename VecTypeB>
double Evaluate(const VecTypeA& a, const VecTypeB& b);
.fi
.PP
.PP
The function takes two vector arguments, \fCa\fP and \fCb\fP, and returns a \fCdouble\fP that is the evaluation of the kernel between the two arguments\&. So, for a particular kernel $\mathcal{K}(\cdot, \cdot)$, the \fCEvaluate()\fP function should return $\mathcal{K}(a, b)$\&.
.PP
The arguments \fCa\fP and \fCb\fP, of types \fCVecTypeA\fP and \fCVecTypeB\fP, respectively, will be an Armadillo-like vector type (usually \fCarma::vec\fP, \fCarma::sp_vec\fP, or similar)\&. In general it should be valid to assume that \fCVecTypeA\fP is a class with the same API as \fCarma::vec\fP\&.
.PP
Note that for kernels that do not hold any state, the \fCEvaluate()\fP method can be marked as \fCstatic\fP\&.
.PP
Overall, the \fCKernelType\fP template policy is quite simple (much like the \fBMetricType policy\fP)\&. Below is an example kernel class, which outputs \fC1\fP if the vectors are close and \fC0\fP otherwise\&.
.PP
.PP
.nf
class ExampleKernel
{
  // Default constructor is required\&.
  ExampleKernel() { }

  // The example kernel holds no state, so we can mark Evaluate() as static\&.
  template<typename VecTypeA, typename VecTypeB>
  static double Evaluate(const VecTypeA& a, const VecTypeB& b)
  {
    // Get how far apart the vectors are (using the Euclidean distance)\&.
    const double distance = arma::norm(a - b);

    if (distance < 0\&.05) // Less than 0\&.05 distance is "close"\&.
      return 1;
    else
      return 0;
  }
};
.fi
.PP
.PP
Then, this kernel may be easily used inside of mlpack algorithms\&. For instance, the code below runs kernel PCA (\fC\fBmlpack::kpca::KernelPCA\fP\fP) on a random dataset using the \fCExampleKernel\fP\&. The results are saved to a file called \fCresults\&.csv\fP\&. (Note that this is simply an example to demonstrate usage, and this example kernel isn't actually likely to be useful in practice\&.)
.PP
.PP
.nf
#include <mlpack/core\&.hpp>
#include <mlpack/methods/kernel_pca/kernel_pca\&.hpp>
#include "example_kernel\&.hpp" // Contains the ExampleKernel class\&.

using namespace mlpack;
using namespace mlpack::kpca;
using namespace arma;

int main()
{
  // Generate the random dataset; 10 dimensions, 5000 points\&.
  mat dataset = randu<mat>(10, 5000);

  // Instantiate the KernelPCA object with the ExampleKernel kernel type\&.
  KernelPCA<ExampleKernel> kpca;

  // The dataset will be transformed using kernel PCA with the example kernel to
  // contain only 2 dimensions\&.
  kpca\&.Apply(dataset, 2);

  // Save the results to 'results\&.csv'\&.
  data::Save(dataset, "results\&.csv");
}
.fi
.PP
.SH "The KernelTraits trait class"
.PP
Some algorithms that use kernels can specialize if the kernel fulfills some certain conditions\&. An example of a condition might be that the kernel is shift-invariant or that the kernel is normalized\&. In the case of fast max-kernel search (\fBmlpack::fastmks::FastMKS\fP), the computation can be accelerated if the kernel is normalized\&. For this reason, the \fCKernelTraits\fP trait class exists\&. This allows a kernel to specify via a \fCconst\fP \fCstatic\fP \fCbool\fP when these types of conditions are satisfied\&. \fBNote that a KernelTraits class is not required,\fP but may be helpful\&.
.PP
The \fCKernelTraits\fP trait class is a template class that takes a \fCKernelType\fP as a parameter, and exposes \fCconst\fP \fCstatic\fP \fCbool\fP values that depend on the kernel\&. Setting these values is achieved by specialization\&. The code below provides an example, specializing \fCKernelTraits\fP for the \fCExampleKernel\fP from earlier:
.PP
.PP
.nf
template<>
class KernelTraits<ExampleKernel>
{
 public:
  const static bool IsNormalized = true;
};
.fi
.PP
.PP
At this time, there is only one kernel trait that is used in mlpack code:
.PP
.IP "\(bu" 2
\fCIsNormalized\fP (defaults to \fCfalse\fP): if $ K(x, x) = 1 \; \forall x $, then the kernel is normalized and this should be set to true\&.
.PP
.SH "List of kernels and classes that use a \\c KernelType"
.PP
mlpack comes with a number of pre-written kernels that satisfy the \fCKernelType\fP policy:
.PP
.IP "\(bu" 2
\fBmlpack::kernel::LinearKernel\fP
.IP "\(bu" 2
\fBmlpack::kernel::ExampleKernel\fP -- an example kernel with more documentation
.IP "\(bu" 2
\fBmlpack::kernel::GaussianKernel\fP
.IP "\(bu" 2
\fBmlpack::kernel::HyperbolicTangentKernel\fP
.IP "\(bu" 2
\fBmlpack::kernel::EpanechnikovKernel\fP
.IP "\(bu" 2
\fBmlpack::kernel::CosineDistance\fP
.IP "\(bu" 2
\fBmlpack::kernel::LaplacianKernel\fP
.IP "\(bu" 2
\fBmlpack::kernel::PolynomialKernel\fP
.IP "\(bu" 2
\fBmlpack::kernel::TriangularKernel\fP
.IP "\(bu" 2
\fBmlpack::kernel::SphericalKernel\fP
.IP "\(bu" 2
\fBmlpack::kernel::PSpectrumStringKernel\fP -- operates on strings, not vectors
.PP
.PP
These kernels (or a custom kernel) may be used in a variety of mlpack methods:
.PP
.IP "\(bu" 2
\fBmlpack::kpca::KernelPCA\fP - kernel principal components analysis
.IP "\(bu" 2
\fBmlpack::fastmks::FastMKS\fP - fast max-kernel search
.IP "\(bu" 2
\fBmlpack::kernel::NystroemMethod\fP - the Nystroem method for sampling
.IP "\(bu" 2
\fBmlpack::metric::IPMetric\fP - a metric built on a kernel 
.PP

