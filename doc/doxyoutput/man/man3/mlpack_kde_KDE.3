.TH "KDE< KernelType, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType >" 3 "Sun Aug 22 2021" "Version 3.4.2" "mlpack" \" -*- nroff -*-
.ad l
.nh
.SH NAME
KDE< KernelType, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType > \- The \fBKDE\fP class is a template class for performing Kernel Density Estimations\&.  

.SH SYNOPSIS
.br
.PP
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef TreeType< MetricType, \fBkde::KDEStat\fP, MatType > \fBTree\fP"
.br
.RI "Convenience typedef\&. "
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBKDE\fP (const double relError=\fBKDEDefaultParams::relError\fP, const double absError=\fBKDEDefaultParams::absError\fP, KernelType kernel=KernelType(), const \fBKDEMode\fP mode=\fBKDEDefaultParams::mode\fP, MetricType metric=MetricType(), const bool monteCarlo=\fBKDEDefaultParams::monteCarlo\fP, const double mcProb=\fBKDEDefaultParams::mcProb\fP, const size_t initialSampleSize=\fBKDEDefaultParams::initialSampleSize\fP, const double mcEntryCoef=\fBKDEDefaultParams::mcEntryCoef\fP, const double mcBreakCoef=\fBKDEDefaultParams::mcBreakCoef\fP)"
.br
.RI "Initialize \fBKDE\fP object using custom instantiated Metric and Kernel objects\&. "
.ti -1c
.RI "\fBKDE\fP (const \fBKDE\fP &other)"
.br
.RI "Construct \fBKDE\fP object as a copy of the given model\&. "
.ti -1c
.RI "\fBKDE\fP (\fBKDE\fP &&other)"
.br
.RI "Construct \fBKDE\fP object taking ownership of the given model\&. "
.ti -1c
.RI "\fB~KDE\fP ()"
.br
.RI "Destroy the \fBKDE\fP object\&. "
.ti -1c
.RI "double \fBAbsoluteError\fP () const"
.br
.RI "Get absolute error tolerance\&. "
.ti -1c
.RI "void \fBAbsoluteError\fP (const double newError)"
.br
.RI "Modify absolute error tolerance (0 <= newError)\&. "
.ti -1c
.RI "void \fBEvaluate\fP (MatType querySet, arma::vec &estimations)"
.br
.RI "Estimate density of each point in the query set given the data of the reference set\&. "
.ti -1c
.RI "void \fBEvaluate\fP (\fBTree\fP *queryTree, const std::vector< size_t > &oldFromNewQueries, arma::vec &estimations)"
.br
.RI "Estimate density of each point in the query set given the data of an already created query tree\&. "
.ti -1c
.RI "void \fBEvaluate\fP (arma::vec &estimations)"
.br
.RI "Estimate density of each point in the reference set given the data of the reference set\&. "
.ti -1c
.RI "bool \fBIsTrained\fP () const"
.br
.RI "Check whether \fBKDE\fP model is trained or not\&. "
.ti -1c
.RI "const KernelType & \fBKernel\fP () const"
.br
.RI "Get the kernel\&. "
.ti -1c
.RI "KernelType & \fBKernel\fP ()"
.br
.RI "Modify the kernel\&. "
.ti -1c
.RI "double \fBMCBreakCoef\fP () const"
.br
.RI "Get Monte Carlo break coefficient\&. "
.ti -1c
.RI "void \fBMCBreakCoef\fP (const double newCoef)"
.br
.RI "Modify Monte Carlo break coefficient\&. (0 < newCoef <= 1)\&. "
.ti -1c
.RI "double \fBMCEntryCoef\fP () const"
.br
.RI "Get Monte Carlo entry coefficient\&. "
.ti -1c
.RI "void \fBMCEntryCoef\fP (const double newCoef)"
.br
.RI "Modify Monte Carlo entry coefficient\&. (newCoef >= 1)\&. "
.ti -1c
.RI "size_t \fBMCInitialSampleSize\fP () const"
.br
.RI "Get Monte Carlo initial sample size\&. "
.ti -1c
.RI "size_t & \fBMCInitialSampleSize\fP ()"
.br
.RI "Modify Monte Carlo initial sample size\&. "
.ti -1c
.RI "double \fBMCProb\fP () const"
.br
.RI "Get Monte Carlo probability of error being bounded by relative error\&. "
.ti -1c
.RI "void \fBMCProb\fP (const double newProb)"
.br
.RI "Modify Monte Carlo probability of error being bounded by relative error\&. "
.ti -1c
.RI "const MetricType & \fBMetric\fP () const"
.br
.RI "Get the metric\&. "
.ti -1c
.RI "MetricType & \fBMetric\fP ()"
.br
.RI "Modify the metric\&. "
.ti -1c
.RI "\fBKDEMode\fP \fBMode\fP () const"
.br
.RI "Get the mode of \fBKDE\fP\&. "
.ti -1c
.RI "\fBKDEMode\fP & \fBMode\fP ()"
.br
.RI "Modify the mode of \fBKDE\fP\&. "
.ti -1c
.RI "bool \fBMonteCarlo\fP () const"
.br
.RI "Get whether Monte Carlo estimations are being used or not\&. "
.ti -1c
.RI "bool & \fBMonteCarlo\fP ()"
.br
.RI "Modify whether Monte Carlo estimations are being used or not\&. "
.ti -1c
.RI "\fBKDE\fP & \fBoperator=\fP (const \fBKDE\fP &other)"
.br
.RI "Copy a \fBKDE\fP model\&. "
.ti -1c
.RI "\fBKDE\fP & \fBoperator=\fP (\fBKDE\fP &&other)"
.br
.RI "Move a \fBKDE\fP model\&. "
.ti -1c
.RI "bool \fBOwnsReferenceTree\fP () const"
.br
.RI "Check whether reference tree is owned by the \fBKDE\fP model\&. "
.ti -1c
.RI "\fBTree\fP * \fBReferenceTree\fP ()"
.br
.RI "Get the reference tree\&. "
.ti -1c
.RI "double \fBRelativeError\fP () const"
.br
.RI "Get relative error tolerance\&. "
.ti -1c
.RI "void \fBRelativeError\fP (const double newError)"
.br
.RI "Modify relative error tolerance (0 <= newError <= 1)\&. "
.ti -1c
.RI "template<typename Archive > void \fBserialize\fP (Archive &ar, const uint32_t version)"
.br
.RI "Serialize the model\&. "
.ti -1c
.RI "void \fBTrain\fP (MatType referenceSet)"
.br
.RI "Trains the \fBKDE\fP model\&. "
.ti -1c
.RI "void \fBTrain\fP (\fBTree\fP *referenceTree, std::vector< size_t > *oldFromNewReferences)"
.br
.RI "Trains the \fBKDE\fP model\&. "
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename KernelType = kernel::GaussianKernel, typename MetricType = mlpack::metric::EuclideanDistance, typename MatType = arma::mat, template< typename TreeMetricType, typename TreeStatType, typename TreeMatType > class TreeType = tree::KDTree, template< typename RuleType > class DualTreeTraversalType = TreeType<MetricType,                      kde::KDEStat,                      MatType>::template DualTreeTraverser, template< typename RuleType > class SingleTreeTraversalType = TreeType<MetricType,                      kde::KDEStat,                      MatType>::template SingleTreeTraverser>
.br
class mlpack::kde::KDE< KernelType, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType >"
The \fBKDE\fP class is a template class for performing Kernel Density Estimations\&. 

In statistics, kernel density estimation is a way to estimate the probability density function of a variable in a non parametric way\&. This implementation performs this estimation using a tree-independent dual-tree algorithm\&. Details about this algorithm are available in \fBKDERules\fP\&.
.PP
\fBTemplate Parameters:\fP
.RS 4
\fIKernelType\fP Kernel function to use for \fBKDE\fP calculations\&. 
.br
\fIMetricType\fP Metric to use for \fBKDE\fP calculations\&. 
.br
\fIMatType\fP Type of data to use\&. 
.br
\fITreeType\fP Type of tree to use; must satisfy the TreeType policy API\&. 
.br
\fIDualTreeTraversalType\fP Type of dual-tree traversal to use\&. 
.br
\fISingleTreeTraversalType\fP Type of single-tree traversal to use\&. 
.RE
.PP

.PP
Definition at line 88 of file kde\&.hpp\&.
.SH "Member Typedef Documentation"
.PP 
.SS "typedef TreeType<MetricType, \fBkde::KDEStat\fP, MatType> \fBTree\fP"

.PP
Convenience typedef\&. 
.PP
Definition at line 92 of file kde\&.hpp\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "\fBKDE\fP (const double relError = \fC\fBKDEDefaultParams::relError\fP\fP, const double absError = \fC\fBKDEDefaultParams::absError\fP\fP, KernelType kernel = \fCKernelType()\fP, const \fBKDEMode\fP mode = \fC\fBKDEDefaultParams::mode\fP\fP, MetricType metric = \fCMetricType()\fP, const bool monteCarlo = \fC\fBKDEDefaultParams::monteCarlo\fP\fP, const double mcProb = \fC\fBKDEDefaultParams::mcProb\fP\fP, const size_t initialSampleSize = \fC\fBKDEDefaultParams::initialSampleSize\fP\fP, const double mcEntryCoef = \fC\fBKDEDefaultParams::mcEntryCoef\fP\fP, const double mcBreakCoef = \fC\fBKDEDefaultParams::mcBreakCoef\fP\fP)"

.PP
Initialize \fBKDE\fP object using custom instantiated Metric and Kernel objects\&. 
.PP
\fBParameters:\fP
.RS 4
\fIrelError\fP Relative error tolerance of the model\&. 
.br
\fIabsError\fP Absolute error tolerance of the model\&. 
.br
\fIkernel\fP Instantiated kernel object\&. 
.br
\fImode\fP Mode for the algorithm\&. 
.br
\fImetric\fP Instantiated metric object\&. 
.br
\fImonteCarlo\fP Whether to use Monte Carlo estimations when possible\&. 
.br
\fImcProb\fP Probability of a Monte Carlo estimation to be bounded by relative error tolerance\&. 
.br
\fIinitialSampleSize\fP Initial sample size for Monte Carlo estimations\&. 
.br
\fImcEntryCoef\fP Coefficient to control how much larger does the amount of node descendants has to be compared to the initial sample size in order for it to be a candidate for Monte Carlo estimations\&. 
.br
\fImcBreakCoef\fP Coefficient to control what fraction of the node's descendants evaluated is the limit before Monte Carlo estimation recurses\&. 
.RE
.PP

.SS "\fBKDE\fP (const \fBKDE\fP< KernelType, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType > & other)"

.PP
Construct \fBKDE\fP object as a copy of the given model\&. This may be computationally intensive!
.PP
\fBParameters:\fP
.RS 4
\fIother\fP \fBKDE\fP object to copy\&. 
.RE
.PP

.SS "\fBKDE\fP (\fBKDE\fP< KernelType, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType > && other)"

.PP
Construct \fBKDE\fP object taking ownership of the given model\&. 
.PP
\fBParameters:\fP
.RS 4
\fIother\fP \fBKDE\fP object to take ownership of\&. 
.RE
.PP

.SS "~\fBKDE\fP ()"

.PP
Destroy the \fBKDE\fP object\&. If this object created any trees, they will be deleted\&. If you created the trees then you have to delete them yourself\&. 
.SH "Member Function Documentation"
.PP 
.SS "double AbsoluteError () const\fC [inline]\fP"

.PP
Get absolute error tolerance\&. 
.PP
Definition at line 250 of file kde\&.hpp\&.
.SS "void AbsoluteError (const double newError)"

.PP
Modify absolute error tolerance (0 <= newError)\&. 
.SS "void Evaluate (MatType querySet, arma::vec & estimations)"

.PP
Estimate density of each point in the query set given the data of the reference set\&. The result is stored in an estimations vector\&. Estimations might not be normalized\&.
.PP
.IP "\(bu" 2
Dimension of each point in the query set must match the dimension of each point in the reference set\&.
.IP "\(bu" 2
Use std::move if the query set is no longer needed\&.
.PP
.PP
\fBPrecondition:\fP
.RS 4
The model has to be previously trained\&. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIquerySet\fP Set of query points to get the density of\&. 
.br
\fIestimations\fP Object which will hold the density of each query point\&. 
.RE
.PP

.SS "void Evaluate (\fBTree\fP * queryTree, const std::vector< size_t > & oldFromNewQueries, arma::vec & estimations)"

.PP
Estimate density of each point in the query set given the data of an already created query tree\&. The result is stored in an estimations vector\&. Estimations might not be normalized\&.
.PP
.IP "\(bu" 2
Dimension of each point in the queryTree dataset must match the dimension of each point in the reference set\&.
.IP "\(bu" 2
Use std::move if the query tree is no longer needed\&.
.PP
.PP
\fBPrecondition:\fP
.RS 4
The model has to be previously trained and mode has to be dual-tree\&. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIqueryTree\fP Tree of query points to get the density of\&. 
.br
\fIoldFromNewQueries\fP Mappings of query points to the tree dataset\&. 
.br
\fIestimations\fP Object which will hold the density of each query point\&. 
.RE
.PP

.SS "void Evaluate (arma::vec & estimations)"

.PP
Estimate density of each point in the reference set given the data of the reference set\&. It does not compute the estimation of a point with itself\&. The result is stored in an estimations vector\&. Estimations might not be normalized\&.
.PP
\fBPrecondition:\fP
.RS 4
The model has to be previously trained\&. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIestimations\fP Object which will hold the density of each reference point\&. 
.RE
.PP

.SS "bool IsTrained () const\fC [inline]\fP"

.PP
Check whether \fBKDE\fP model is trained or not\&. 
.PP
Definition at line 259 of file kde\&.hpp\&.
.SS "const KernelType& Kernel () const\fC [inline]\fP"

.PP
Get the kernel\&. 
.PP
Definition at line 229 of file kde\&.hpp\&.
.SS "KernelType& Kernel ()\fC [inline]\fP"

.PP
Modify the kernel\&. 
.PP
Definition at line 232 of file kde\&.hpp\&.
.SS "double MCBreakCoef () const\fC [inline]\fP"

.PP
Get Monte Carlo break coefficient\&. 
.PP
Definition at line 293 of file kde\&.hpp\&.
.SS "void MCBreakCoef (const double newCoef)"

.PP
Modify Monte Carlo break coefficient\&. (0 < newCoef <= 1)\&. 
.SS "double MCEntryCoef () const\fC [inline]\fP"

.PP
Get Monte Carlo entry coefficient\&. 
.PP
Definition at line 287 of file kde\&.hpp\&.
.SS "void MCEntryCoef (const double newCoef)"

.PP
Modify Monte Carlo entry coefficient\&. (newCoef >= 1)\&. 
.SS "size_t MCInitialSampleSize () const\fC [inline]\fP"

.PP
Get Monte Carlo initial sample size\&. 
.PP
Definition at line 281 of file kde\&.hpp\&.
.SS "size_t& MCInitialSampleSize ()\fC [inline]\fP"

.PP
Modify Monte Carlo initial sample size\&. 
.PP
Definition at line 284 of file kde\&.hpp\&.
.SS "double MCProb () const\fC [inline]\fP"

.PP
Get Monte Carlo probability of error being bounded by relative error\&. 
.PP
Definition at line 274 of file kde\&.hpp\&.
.SS "void MCProb (const double newProb)"

.PP
Modify Monte Carlo probability of error being bounded by relative error\&. (0 <= newProb < 1)\&. 
.SS "const MetricType& Metric () const\fC [inline]\fP"

.PP
Get the metric\&. 
.PP
Definition at line 235 of file kde\&.hpp\&.
.SS "MetricType& Metric ()\fC [inline]\fP"

.PP
Modify the metric\&. 
.PP
Definition at line 238 of file kde\&.hpp\&.
.SS "\fBKDEMode\fP Mode () const\fC [inline]\fP"

.PP
Get the mode of \fBKDE\fP\&. 
.PP
Definition at line 262 of file kde\&.hpp\&.
.SS "\fBKDEMode\fP& Mode ()\fC [inline]\fP"

.PP
Modify the mode of \fBKDE\fP\&. 
.PP
Definition at line 265 of file kde\&.hpp\&.
.SS "bool MonteCarlo () const\fC [inline]\fP"

.PP
Get whether Monte Carlo estimations are being used or not\&. 
.PP
Definition at line 268 of file kde\&.hpp\&.
.SS "bool& MonteCarlo ()\fC [inline]\fP"

.PP
Modify whether Monte Carlo estimations are being used or not\&. 
.PP
Definition at line 271 of file kde\&.hpp\&.
.SS "\fBKDE\fP& operator= (const \fBKDE\fP< KernelType, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType > & other)"

.PP
Copy a \fBKDE\fP model\&. 
.PP
\fBParameters:\fP
.RS 4
\fIother\fP \fBKDE\fP model to copy\&. 
.RE
.PP

.SS "\fBKDE\fP& operator= (\fBKDE\fP< KernelType, MetricType, MatType, TreeType, DualTreeTraversalType, SingleTreeTraversalType > && other)"

.PP
Move a \fBKDE\fP model\&. 
.PP
\fBParameters:\fP
.RS 4
\fIother\fP \fBKDE\fP model to copy\&. 
.RE
.PP

.SS "bool OwnsReferenceTree () const\fC [inline]\fP"

.PP
Check whether reference tree is owned by the \fBKDE\fP model\&. 
.PP
Definition at line 256 of file kde\&.hpp\&.
.SS "\fBTree\fP* ReferenceTree ()\fC [inline]\fP"

.PP
Get the reference tree\&. 
.PP
Definition at line 241 of file kde\&.hpp\&.
.SS "double RelativeError () const\fC [inline]\fP"

.PP
Get relative error tolerance\&. 
.PP
Definition at line 244 of file kde\&.hpp\&.
.SS "void RelativeError (const double newError)"

.PP
Modify relative error tolerance (0 <= newError <= 1)\&. 
.SS "void serialize (Archive & ar, const uint32_t version)"

.PP
Serialize the model\&. 
.SS "void Train (MatType referenceSet)"

.PP
Trains the \fBKDE\fP model\&. It builds a tree using a reference set\&.
.PP
Use std::move if the reference set is no longer needed\&.
.PP
\fBParameters:\fP
.RS 4
\fIreferenceSet\fP Set of reference data\&. 
.RE
.PP

.SS "void Train (\fBTree\fP * referenceTree, std::vector< size_t > * oldFromNewReferences)"

.PP
Trains the \fBKDE\fP model\&. Sets the reference tree to an already created tree\&.
.PP
.IP "\(bu" 2
If TreeTraits<TreeType>::RearrangesDataset is false then it is possible to use an empty oldFromNewReferences vector\&.
.PP
.PP
\fBParameters:\fP
.RS 4
\fIreferenceTree\fP Built reference tree\&. 
.br
\fIoldFromNewReferences\fP Permutations of reference points obtained during tree generation\&. 
.RE
.PP


.SH "Author"
.PP 
Generated automatically by Doxygen for mlpack from the source code\&.
