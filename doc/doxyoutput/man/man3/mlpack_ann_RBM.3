.TH "RBM< InitializationRuleType, DataType, PolicyType >" 3 "Sun Aug 22 2021" "Version 3.4.2" "mlpack" \" -*- nroff -*-
.ad l
.nh
.SH NAME
RBM< InitializationRuleType, DataType, PolicyType > \- The implementation of the \fBRBM\fP module\&.  

.SH SYNOPSIS
.br
.PP
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef DataType::elem_type \fBElemType\fP"
.br
.ti -1c
.RI "using \fBNetworkType\fP = \fBRBM\fP< InitializationRuleType, DataType, PolicyType >"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBRBM\fP (arma::Mat< \fBElemType\fP > predictors, InitializationRuleType initializeRule, const size_t visibleSize, const size_t hiddenSize, const size_t batchSize=1, const size_t numSteps=1, const size_t negSteps=1, const size_t poolSize=2, const \fBElemType\fP slabPenalty=8, const \fBElemType\fP radius=1, const bool persistence=false)"
.br
.RI "Initialize all the parameters of the network using initializeRule\&. "
.ti -1c
.RI "double \fBEvaluate\fP (const arma::Mat< \fBElemType\fP > &parameters, const size_t i, const size_t batchSize)"
.br
.RI "Evaluate the \fBRBM\fP network with the given parameters\&. "
.ti -1c
.RI "template<typename Policy  = PolicyType, typename InputType  = DataType> std::enable_if< std::is_same< Policy, \fBBinaryRBM\fP >::value, double >::type \fBFreeEnergy\fP (const arma::Mat< \fBElemType\fP > &input)"
.br
.RI "This function calculates the free energy of the \fBBinaryRBM\fP\&. "
.ti -1c
.RI "template<typename Policy  = PolicyType, typename InputType  = DataType> std::enable_if< std::is_same< Policy, \fBSpikeSlabRBM\fP >::value, double >::type \fBFreeEnergy\fP (const arma::Mat< \fBElemType\fP > &input)"
.br
.RI "This function calculates the free energy of the \fBSpikeSlabRBM\fP\&. "
.ti -1c
.RI "void \fBGibbs\fP (const arma::Mat< \fBElemType\fP > &input, arma::Mat< \fBElemType\fP > &output, const size_t steps=SIZE_MAX)"
.br
.RI "This function does the k-step Gibbs Sampling\&. "
.ti -1c
.RI "void \fBGradient\fP (const arma::Mat< \fBElemType\fP > &parameters, const size_t i, arma::Mat< \fBElemType\fP > &gradient, const size_t batchSize)"
.br
.RI "Calculates the gradients for the \fBRBM\fP network\&. "
.ti -1c
.RI "DataType const  & \fBHiddenBias\fP () const"
.br
.RI "Return the hidden bias of the network\&. "
.ti -1c
.RI "DataType & \fBHiddenBias\fP ()"
.br
.RI "Modify the hidden bias of the network\&. "
.ti -1c
.RI "template<typename Policy  = PolicyType, typename InputType  = DataType> std::enable_if< std::is_same< Policy, \fBBinaryRBM\fP >::value, void >::type \fBHiddenMean\fP (const InputType &input, DataType &output)"
.br
.RI "The function calculates the mean for the hidden layer\&. "
.ti -1c
.RI "template<typename Policy  = PolicyType, typename InputType  = DataType> std::enable_if< std::is_same< Policy, \fBSpikeSlabRBM\fP >::value, void >::type \fBHiddenMean\fP (const InputType &input, DataType &output)"
.br
.RI "The function calculates the mean of the Normal distribution of P(s|v, h)\&. "
.ti -1c
.RI "size_t const  & \fBHiddenSize\fP () const"
.br
.RI "Get the hidden size\&. "
.ti -1c
.RI "size_t \fBNumFunctions\fP () const"
.br
.RI "Return the number of separable functions (the number of predictor points)\&. "
.ti -1c
.RI "size_t \fBNumSteps\fP () const"
.br
.RI "Return the number of steps of Gibbs Sampling\&. "
.ti -1c
.RI "const arma::Mat< \fBElemType\fP > & \fBParameters\fP () const"
.br
.RI "Return the parameters of the network\&. "
.ti -1c
.RI "arma::Mat< \fBElemType\fP > & \fBParameters\fP ()"
.br
.RI "Modify the parameters of the network\&. "
.ti -1c
.RI "template<typename Policy  = PolicyType, typename InputType  = DataType> std::enable_if< std::is_same< Policy, \fBBinaryRBM\fP >::value, void >::type \fBPhase\fP (const InputType &input, DataType &gradient)"
.br
.RI "Calculates the gradient of the \fBRBM\fP network on the provided input\&. "
.ti -1c
.RI "template<typename Policy  = PolicyType, typename InputType  = DataType> std::enable_if< std::is_same< Policy, \fBSpikeSlabRBM\fP >::value, void >::type \fBPhase\fP (const InputType &input, DataType &gradient)"
.br
.RI "Calculates the gradient of the \fBRBM\fP network on the provided input\&. "
.ti -1c
.RI "size_t const  & \fBPoolSize\fP () const"
.br
.RI "Get the pool size\&. "
.ti -1c
.RI "template<typename Policy  = PolicyType, typename InputType  = DataType> std::enable_if< std::is_same< Policy, \fBBinaryRBM\fP >::value, void >::type \fBReset\fP ()"
.br
.ti -1c
.RI "template<typename Policy  = PolicyType, typename InputType  = DataType> std::enable_if< std::is_same< Policy, \fBSpikeSlabRBM\fP >::value, void >::type \fBReset\fP ()"
.br
.ti -1c
.RI "template<typename Policy  = PolicyType, typename InputType  = DataType> std::enable_if< std::is_same< Policy, \fBBinaryRBM\fP >::value, void >::type \fBSampleHidden\fP (const arma::Mat< \fBElemType\fP > &input, arma::Mat< \fBElemType\fP > &output)"
.br
.RI "This function samples the hidden layer given the visible layer using Bernoulli function\&. "
.ti -1c
.RI "template<typename Policy  = PolicyType, typename InputType  = DataType> std::enable_if< std::is_same< Policy, \fBSpikeSlabRBM\fP >::value, void >::type \fBSampleHidden\fP (const arma::Mat< \fBElemType\fP > &input, arma::Mat< \fBElemType\fP > &output)"
.br
.RI "This function samples the slab outputs from the Normal distribution with mean given by: $ h_i*\alpha^{-1}*W_i^T*v $ and variance: $ \alpha^{-1} $\&. "
.ti -1c
.RI "template<typename Policy  = PolicyType, typename InputType  = DataType> std::enable_if< std::is_same< Policy, \fBSpikeSlabRBM\fP >::value, void >::type \fBSampleSlab\fP (InputType &slabMean, DataType &slab)"
.br
.RI "The function samples from the Normal distribution of P(s|v, h), where the mean is given by: $ h_i*\alpha^{-1}*W_i^T*v $ and variance is given by: $ \alpha^{-1} $\&. "
.ti -1c
.RI "template<typename Policy  = PolicyType, typename InputType  = DataType> std::enable_if< std::is_same< Policy, \fBSpikeSlabRBM\fP >::value, void >::type \fBSampleSpike\fP (InputType &spikeMean, DataType &spike)"
.br
.RI "The function samples the spike function using Bernoulli distribution\&. "
.ti -1c
.RI "template<typename Policy  = PolicyType, typename InputType  = DataType> std::enable_if< std::is_same< Policy, \fBBinaryRBM\fP >::value, void >::type \fBSampleVisible\fP (arma::Mat< \fBElemType\fP > &input, arma::Mat< \fBElemType\fP > &output)"
.br
.RI "This function samples the visible layer given the hidden layer using Bernoulli function\&. "
.ti -1c
.RI "template<typename Policy  = PolicyType, typename InputType  = DataType> std::enable_if< std::is_same< Policy, \fBSpikeSlabRBM\fP >::value, void >::type \fBSampleVisible\fP (arma::Mat< \fBElemType\fP > &input, arma::Mat< \fBElemType\fP > &output)"
.br
.RI "Sample Hidden function samples the slab outputs from the Normal distribution with mean given by: $ h_i*\alpha^{-1}*W_i^T*v $ and variance: $ \alpha^{-1} $\&. "
.ti -1c
.RI "template<typename Archive > void \fBserialize\fP (Archive &ar, const uint32_t version)"
.br
.RI "Serialize the model\&. "
.ti -1c
.RI "void \fBShuffle\fP ()"
.br
.RI "Shuffle the order of function visitation\&. "
.ti -1c
.RI "template<typename Policy  = PolicyType, typename InputType  = DataType> std::enable_if< std::is_same< Policy, \fBSpikeSlabRBM\fP >::value, void >::type \fBSlabMean\fP (const DataType &visible, DataType &spike, DataType &slabMean)"
.br
.RI "The function calculates the mean of Normal distribution of P(s|v, h), where the mean is given by: $ h_i*\alpha^{-1}*W_i^T*v $\&. "
.ti -1c
.RI "\fBElemType\fP const  & \fBSlabPenalty\fP () const"
.br
.RI "Get the regularizer associated with slab variables\&. "
.ti -1c
.RI "DataType const  & \fBSpikeBias\fP () const"
.br
.RI "Get the regularizer associated with spike variables\&. "
.ti -1c
.RI "DataType & \fBSpikeBias\fP ()"
.br
.RI "Modify the regularizer associated with spike variables\&. "
.ti -1c
.RI "template<typename Policy  = PolicyType, typename InputType  = DataType> std::enable_if< std::is_same< Policy, \fBSpikeSlabRBM\fP >::value, void >::type \fBSpikeMean\fP (const InputType &visible, DataType &spikeMean)"
.br
.RI "The function calculates the mean of the distribution P(h|v), where mean is given by: $ sigm(v^T*W_i*\alpha_i^{-1}*W_i^T*v + b_i) $\&. "
.ti -1c
.RI "template<typename OptimizerType , typename\&.\&.\&. CallbackType> double \fBTrain\fP (OptimizerType &optimizer, CallbackType &&\&.\&.\&. callbacks)"
.br
.RI "Train the \fBRBM\fP on the given input data\&. "
.ti -1c
.RI "DataType const  & \fBVisibleBias\fP () const"
.br
.RI "Return the visible bias of the network\&. "
.ti -1c
.RI "DataType & \fBVisibleBias\fP ()"
.br
.RI "Modify the visible bias of the network\&. "
.ti -1c
.RI "template<typename Policy  = PolicyType, typename InputType  = DataType> std::enable_if< std::is_same< Policy, \fBBinaryRBM\fP >::value, void >::type \fBVisibleMean\fP (InputType &input, DataType &output)"
.br
.RI "The function calculates the mean for the visible layer\&. "
.ti -1c
.RI "template<typename Policy  = PolicyType, typename InputType  = DataType> std::enable_if< std::is_same< Policy, \fBSpikeSlabRBM\fP >::value, void >::type \fBVisibleMean\fP (InputType &input, DataType &output)"
.br
.RI "The function calculates the mean of the Normal distribution of P(v|s, h)\&. "
.ti -1c
.RI "DataType const  & \fBVisiblePenalty\fP () const"
.br
.RI "Get the regularizer associated with visible variables\&. "
.ti -1c
.RI "DataType & \fBVisiblePenalty\fP ()"
.br
.RI "Modify the regularizer associated with visible variables\&. "
.ti -1c
.RI "size_t const  & \fBVisibleSize\fP () const"
.br
.RI "Get the visible size\&. "
.ti -1c
.RI "arma::Cube< \fBElemType\fP > const  & \fBWeight\fP () const"
.br
.RI "Get the weights of the network\&. "
.ti -1c
.RI "arma::Cube< \fBElemType\fP > & \fBWeight\fP ()"
.br
.RI "Modify the weights of the network\&. "
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename InitializationRuleType, typename DataType = arma::mat, typename PolicyType = BinaryRBM>
.br
class mlpack::ann::RBM< InitializationRuleType, DataType, PolicyType >"
The implementation of the \fBRBM\fP module\&. 

A Restricted Boltzmann Machines (\fBRBM\fP) is a generative stochastic artificial neural network that can learn a probability distribution over its set of inputs\&. RBMs have found applications in dimensionality reduction, classification, collaborative filtering, feature learning and topic modelling\&. They can be trained in either supervised or unsupervised ways, depending on the task\&. They are a variant of Boltzmann machines, with the restriction that the neurons must form a bipartite graph\&.
.PP
\fBTemplate Parameters:\fP
.RS 4
\fIInitializationRuleType\fP Rule used to initialize the network\&. 
.br
\fIDataType\fP The type of matrix to be used\&. 
.br
\fIPolicyType\fP The \fBRBM\fP variant to be used (\fBBinaryRBM\fP or \fBSpikeSlabRBM\fP)\&. 
.RE
.PP

.PP
Definition at line 38 of file rbm\&.hpp\&.
.SH "Member Typedef Documentation"
.PP 
.SS "typedef DataType::elem_type \fBElemType\fP"

.PP
Definition at line 42 of file rbm\&.hpp\&.
.SS "using \fBNetworkType\fP =  \fBRBM\fP<InitializationRuleType, DataType, PolicyType>"

.PP
Definition at line 41 of file rbm\&.hpp\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "\fBRBM\fP (arma::Mat< \fBElemType\fP > predictors, InitializationRuleType initializeRule, const size_t visibleSize, const size_t hiddenSize, const size_t batchSize = \fC1\fP, const size_t numSteps = \fC1\fP, const size_t negSteps = \fC1\fP, const size_t poolSize = \fC2\fP, const \fBElemType\fP slabPenalty = \fC8\fP, const \fBElemType\fP radius = \fC1\fP, const bool persistence = \fCfalse\fP)"

.PP
Initialize all the parameters of the network using initializeRule\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpredictors\fP Training data to be used\&. 
.br
\fIinitializeRule\fP InitializationRule object for initializing the network parameter\&. 
.br
\fIvisibleSize\fP Number of visible neurons\&. 
.br
\fIhiddenSize\fP Number of hidden neurons\&. 
.br
\fIbatchSize\fP Batch size to be used for training\&. 
.br
\fInumSteps\fP Number of Gibbs Sampling steps\&. 
.br
\fInegSteps\fP Number of negative samples to average negative gradient\&. 
.br
\fIpoolSize\fP Number of hidden neurons to pool together\&. 
.br
\fIslabPenalty\fP Regulariser of slab variables\&. 
.br
\fIradius\fP Feasible regions for visible layer samples\&. 
.br
\fIpersistence\fP Indicates whether to use Persistent CD or not\&. 
.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "double Evaluate (const arma::Mat< \fBElemType\fP > & parameters, const size_t i, const size_t batchSize)"

.PP
Evaluate the \fBRBM\fP network with the given parameters\&. The function is needed for monitoring the progress of the network\&.
.PP
\fBParameters:\fP
.RS 4
\fIparameters\fP Matrix model parameters\&. 
.br
\fIi\fP Index of the data point\&. 
.br
\fIbatchSize\fP Variable to store the present number of inputs\&. 
.RE
.PP

.SS "std::enable_if<std::is_same<Policy, \fBBinaryRBM\fP>::value, double>::type FreeEnergy (const arma::Mat< \fBElemType\fP > & input)"

.PP
This function calculates the free energy of the \fBBinaryRBM\fP\&. The free energy is given by: $ -b^Tv - \sum_{i=1}^M log(1 + e^{c_j+v^TW_j}) $\&.
.PP
\fBParameters:\fP
.RS 4
\fIinput\fP The visible neurons\&. 
.RE
.PP

.SS "std::enable_if<std::is_same<Policy, \fBSpikeSlabRBM\fP>::value, double>::type FreeEnergy (const arma::Mat< \fBElemType\fP > & input)"

.PP
This function calculates the free energy of the \fBSpikeSlabRBM\fP\&. The free energy is given by: $ v^t$$\Delta$v - $\sum_{i=1}^N $ $ \log{ \sqrt{\frac{(-2\pi)^K}{\prod_{m=1}^{K}(\alpha_i)_m}}} $ - $ \sum_{i=1}^N \log(1+\exp( b_i + \sum_{m=1}^k \frac{(v(w_i)_m^t)^2}{2(\alpha_i)_m}) $
.PP
\fBParameters:\fP
.RS 4
\fIinput\fP The visible layer neurons\&. 
.RE
.PP

.SS "void Gibbs (const arma::Mat< \fBElemType\fP > & input, arma::Mat< \fBElemType\fP > & output, const size_t steps = \fCSIZE_MAX\fP)"

.PP
This function does the k-step Gibbs Sampling\&. 
.PP
\fBParameters:\fP
.RS 4
\fIinput\fP Input to the Gibbs function\&. 
.br
\fIoutput\fP Used for storing the negative sample\&. 
.br
\fIsteps\fP Number of Gibbs Sampling steps taken\&. 
.RE
.PP

.SS "void Gradient (const arma::Mat< \fBElemType\fP > & parameters, const size_t i, arma::Mat< \fBElemType\fP > & gradient, const size_t batchSize)"

.PP
Calculates the gradients for the \fBRBM\fP network\&. 
.PP
\fBParameters:\fP
.RS 4
\fIparameters\fP The current parameters of the network\&. 
.br
\fIi\fP Index of the data point\&. 
.br
\fIgradient\fP Variable to store the present gradient\&. 
.br
\fIbatchSize\fP Variable to store the present number of inputs\&. 
.RE
.PP

.SS "DataType const& HiddenBias () const\fC [inline]\fP"

.PP
Return the hidden bias of the network\&. 
.PP
Definition at line 354 of file rbm\&.hpp\&.
.SS "DataType& HiddenBias ()\fC [inline]\fP"

.PP
Modify the hidden bias of the network\&. 
.PP
Definition at line 356 of file rbm\&.hpp\&.
.SS "std::enable_if<std::is_same<Policy, \fBBinaryRBM\fP>::value, void>::type HiddenMean (const InputType & input, DataType & output)"

.PP
The function calculates the mean for the hidden layer\&. 
.PP
\fBParameters:\fP
.RS 4
\fIinput\fP Visible neurons\&. 
.br
\fIoutput\fP Hidden neuron activations\&. 
.RE
.PP

.SS "std::enable_if<std::is_same<Policy, \fBSpikeSlabRBM\fP>::value, void>::type HiddenMean (const InputType & input, DataType & output)"

.PP
The function calculates the mean of the Normal distribution of P(s|v, h)\&. The mean is given by: $ h_i*\alpha^{-1}*W_i^T*v $ The variance is given by: $ \alpha^{-1} $
.PP
\fBParameters:\fP
.RS 4
\fIinput\fP Visible layer neurons\&. 
.br
\fIoutput\fP Consists of both the spike samples and slab samples\&. 
.RE
.PP

.SS "size_t const& HiddenSize () const\fC [inline]\fP"

.PP
Get the hidden size\&. 
.PP
Definition at line 374 of file rbm\&.hpp\&.
.SS "size_t NumFunctions () const\fC [inline]\fP"

.PP
Return the number of separable functions (the number of predictor points)\&. 
.PP
Definition at line 333 of file rbm\&.hpp\&.
.SS "size_t NumSteps () const\fC [inline]\fP"

.PP
Return the number of steps of Gibbs Sampling\&. 
.PP
Definition at line 336 of file rbm\&.hpp\&.
.SS "const arma::Mat<\fBElemType\fP>& Parameters () const\fC [inline]\fP"

.PP
Return the parameters of the network\&. 
.PP
Definition at line 339 of file rbm\&.hpp\&.
.SS "arma::Mat<\fBElemType\fP>& Parameters ()\fC [inline]\fP"

.PP
Modify the parameters of the network\&. 
.PP
Definition at line 341 of file rbm\&.hpp\&.
.SS "std::enable_if<std::is_same<Policy, \fBBinaryRBM\fP>::value, void>::type Phase (const InputType & input, DataType & gradient)"

.PP
Calculates the gradient of the \fBRBM\fP network on the provided input\&. 
.PP
\fBParameters:\fP
.RS 4
\fIinput\fP The provided input data\&. 
.br
\fIgradient\fP Stores the gradient of the \fBRBM\fP network\&. 
.RE
.PP

.SS "std::enable_if<std::is_same<Policy, \fBSpikeSlabRBM\fP>::value, void>::type Phase (const InputType & input, DataType & gradient)"

.PP
Calculates the gradient of the \fBRBM\fP network on the provided input\&. 
.PP
\fBParameters:\fP
.RS 4
\fIinput\fP The provided input data\&. 
.br
\fIgradient\fP Stores the gradient of the \fBRBM\fP network\&. 
.RE
.PP

.SS "size_t const& PoolSize () const\fC [inline]\fP"

.PP
Get the pool size\&. 
.PP
Definition at line 376 of file rbm\&.hpp\&.
.PP
References RBM< InitializationRuleType, DataType, PolicyType >::serialize()\&.
.SS "std::enable_if<std::is_same<Policy, \fBBinaryRBM\fP>::value, void>::type Reset ()"

.SS "std::enable_if<std::is_same<Policy, \fBSpikeSlabRBM\fP>::value, void>::type Reset ()"

.SS "std::enable_if<std::is_same<Policy, \fBBinaryRBM\fP>::value, void>::type SampleHidden (const arma::Mat< \fBElemType\fP > & input, arma::Mat< \fBElemType\fP > & output)"

.PP
This function samples the hidden layer given the visible layer using Bernoulli function\&. 
.PP
\fBParameters:\fP
.RS 4
\fIinput\fP Visible layer input\&. 
.br
\fIoutput\fP The sampled hidden layer\&. 
.RE
.PP

.SS "std::enable_if<std::is_same<Policy, \fBSpikeSlabRBM\fP>::value, void>::type SampleHidden (const arma::Mat< \fBElemType\fP > & input, arma::Mat< \fBElemType\fP > & output)"

.PP
This function samples the slab outputs from the Normal distribution with mean given by: $ h_i*\alpha^{-1}*W_i^T*v $ and variance: $ \alpha^{-1} $\&. 
.PP
\fBParameters:\fP
.RS 4
\fIinput\fP Consists of both visible and spike variables\&. 
.br
\fIoutput\fP Sampled slab neurons\&. 
.RE
.PP

.SS "std::enable_if<std::is_same<Policy, \fBSpikeSlabRBM\fP>::value, void>::type SampleSlab (InputType & slabMean, DataType & slab)"

.PP
The function samples from the Normal distribution of P(s|v, h), where the mean is given by: $ h_i*\alpha^{-1}*W_i^T*v $ and variance is given by: $ \alpha^{-1} $\&. 
.PP
\fBParameters:\fP
.RS 4
\fIslabMean\fP Mean of the Normal distribution of the slab neurons\&. 
.br
\fIslab\fP Sampled slab variable from the Normal distribution\&. 
.RE
.PP

.SS "std::enable_if<std::is_same<Policy, \fBSpikeSlabRBM\fP>::value, void>::type SampleSpike (InputType & spikeMean, DataType & spike)"

.PP
The function samples the spike function using Bernoulli distribution\&. 
.PP
\fBParameters:\fP
.RS 4
\fIspikeMean\fP Indicates P(h|v)\&. 
.br
\fIspike\fP Sampled binary spike variables\&. 
.RE
.PP

.SS "std::enable_if<std::is_same<Policy, \fBBinaryRBM\fP>::value, void>::type SampleVisible (arma::Mat< \fBElemType\fP > & input, arma::Mat< \fBElemType\fP > & output)"

.PP
This function samples the visible layer given the hidden layer using Bernoulli function\&. 
.PP
\fBParameters:\fP
.RS 4
\fIinput\fP Hidden layer of the network\&. 
.br
\fIoutput\fP The sampled visible layer\&. 
.RE
.PP

.SS "std::enable_if<std::is_same<Policy, \fBSpikeSlabRBM\fP>::value, void>::type SampleVisible (arma::Mat< \fBElemType\fP > & input, arma::Mat< \fBElemType\fP > & output)"

.PP
Sample Hidden function samples the slab outputs from the Normal distribution with mean given by: $ h_i*\alpha^{-1}*W_i^T*v $ and variance: $ \alpha^{-1} $\&. 
.PP
\fBParameters:\fP
.RS 4
\fIinput\fP Hidden layer of the network\&. 
.br
\fIoutput\fP The sampled visible layer\&. 
.RE
.PP

.SS "void serialize (Archive & ar, const uint32_t version)"

.PP
Serialize the model\&. 
.PP
Referenced by RBM< InitializationRuleType, DataType, PolicyType >::PoolSize()\&.
.SS "void Shuffle ()"

.PP
Shuffle the order of function visitation\&. This may be called by the optimizer\&. 
.SS "std::enable_if<std::is_same<Policy, \fBSpikeSlabRBM\fP>::value, void>::type SlabMean (const DataType & visible, DataType & spike, DataType & slabMean)"

.PP
The function calculates the mean of Normal distribution of P(s|v, h), where the mean is given by: $ h_i*\alpha^{-1}*W_i^T*v $\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvisible\fP The visible layer neurons\&. 
.br
\fIspike\fP The spike variables from hidden layer\&. 
.br
\fIslabMean\fP The mean of the Normal distribution of slab neurons\&. 
.RE
.PP

.SS "\fBElemType\fP const& SlabPenalty () const\fC [inline]\fP"

.PP
Get the regularizer associated with slab variables\&. 
.PP
Definition at line 364 of file rbm\&.hpp\&.
.SS "DataType const& SpikeBias () const\fC [inline]\fP"

.PP
Get the regularizer associated with spike variables\&. 
.PP
Definition at line 359 of file rbm\&.hpp\&.
.SS "DataType& SpikeBias ()\fC [inline]\fP"

.PP
Modify the regularizer associated with spike variables\&. 
.PP
Definition at line 361 of file rbm\&.hpp\&.
.SS "std::enable_if<std::is_same<Policy, \fBSpikeSlabRBM\fP>::value, void>::type SpikeMean (const InputType & visible, DataType & spikeMean)"

.PP
The function calculates the mean of the distribution P(h|v), where mean is given by: $ sigm(v^T*W_i*\alpha_i^{-1}*W_i^T*v + b_i) $\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvisible\fP The visible layer neurons\&. 
.br
\fIspikeMean\fP Indicates P(h|v)\&. 
.RE
.PP

.SS "double Train (OptimizerType & optimizer, CallbackType &&\&.\&.\&. callbacks)"

.PP
Train the \fBRBM\fP on the given input data\&. This will use the existing model parameters as a starting point for the optimization\&. If this is not what you want, then you should access the parameters vector directly with \fBParameters()\fP and modify it as desired\&.
.PP
\fBTemplate Parameters:\fP
.RS 4
\fIOptimizerType\fP Type of optimizer to use to train the model\&. 
.br
\fICallbackTypes\fP Types of Callback functions\&. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIoptimizer\fP Optimizer type\&. 
.br
\fIcallbacks\fP Callback Functions for ensmallen optimizer \fCOptimizerType\fP\&. See https://www.ensmallen.org/docs.html#callback-documentation\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
The final objective of the trained model (NaN or Inf on error)\&. 
.RE
.PP

.SS "DataType const& VisibleBias () const\fC [inline]\fP"

.PP
Return the visible bias of the network\&. 
.PP
Definition at line 349 of file rbm\&.hpp\&.
.SS "DataType& VisibleBias ()\fC [inline]\fP"

.PP
Modify the visible bias of the network\&. 
.PP
Definition at line 351 of file rbm\&.hpp\&.
.SS "std::enable_if<std::is_same<Policy, \fBBinaryRBM\fP>::value, void>::type VisibleMean (InputType & input, DataType & output)"

.PP
The function calculates the mean for the visible layer\&. 
.PP
\fBParameters:\fP
.RS 4
\fIinput\fP Hidden neurons from the hidden layer of the network\&. 
.br
\fIoutput\fP Visible neuron activations\&. 
.RE
.PP

.SS "std::enable_if<std::is_same<Policy, \fBSpikeSlabRBM\fP>::value, void>::type VisibleMean (InputType & input, DataType & output)"

.PP
The function calculates the mean of the Normal distribution of P(v|s, h)\&. The mean is given by: $ \Lambda^{-1} \sum_{i=1}^N W_i * s_i * h_i $
.PP
\fBParameters:\fP
.RS 4
\fIinput\fP Consists of both the spike and slab variables\&. 
.br
\fIoutput\fP Mean of the of the Normal distribution\&. 
.RE
.PP

.SS "DataType const& VisiblePenalty () const\fC [inline]\fP"

.PP
Get the regularizer associated with visible variables\&. 
.PP
Definition at line 367 of file rbm\&.hpp\&.
.SS "DataType& VisiblePenalty ()\fC [inline]\fP"

.PP
Modify the regularizer associated with visible variables\&. 
.PP
Definition at line 369 of file rbm\&.hpp\&.
.SS "size_t const& VisibleSize () const\fC [inline]\fP"

.PP
Get the visible size\&. 
.PP
Definition at line 372 of file rbm\&.hpp\&.
.SS "arma::Cube<\fBElemType\fP> const& Weight () const\fC [inline]\fP"

.PP
Get the weights of the network\&. 
.PP
Definition at line 344 of file rbm\&.hpp\&.
.SS "arma::Cube<\fBElemType\fP>& Weight ()\fC [inline]\fP"

.PP
Modify the weights of the network\&. 
.PP
Definition at line 346 of file rbm\&.hpp\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for mlpack from the source code\&.
