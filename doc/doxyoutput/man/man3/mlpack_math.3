.TH "mlpack::math" 3 "Thu Jun 24 2021" "Version 3.4.2" "mlpack" \" -*- nroff -*-
.ad l
.nh
.SH NAME
mlpack::math \- Miscellaneous math routines\&.  

.SH SYNOPSIS
.br
.PP
.SS "Classes"

.in +1c
.ti -1c
.RI "class \fBColumnsToBlocks\fP"
.br
.RI "Transform the columns of the given matrix into a block format\&. "
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "template<typename T > T::elem_type \fBAccuLog\fP (const T &x)"
.br
.RI "Log-sum a vector of log values\&. "
.ti -1c
.RI "void \fBCenter\fP (const arma::mat &x, arma::mat &xCentered)"
.br
.RI "Creates a centered matrix, where centering is done by subtracting the sum over the columns (a column vector) from each column of the matrix\&. "
.ti -1c
.RI "double \fBClampNonNegative\fP (const double d)"
.br
.RI "Forces a number to be non-negative, turning negative numbers into zero\&. "
.ti -1c
.RI "double \fBClampNonPositive\fP (const double d)"
.br
.RI "Forces a number to be non-positive, turning positive numbers into zero\&. "
.ti -1c
.RI "double \fBClampRange\fP (double value, const double rangeMin, const double rangeMax)"
.br
.RI "Clamp a number between a particular range\&. "
.ti -1c
.RI "template<typename ElemType > void \fBClearAlias\fP (arma::Mat< ElemType > &mat)"
.br
.RI "Clear an alias so that no data is overwritten\&. "
.ti -1c
.RI "template<typename ElemType > void \fBClearAlias\fP (arma::SpMat< ElemType > &)"
.br
.RI "Clear an alias for a sparse matrix\&. "
.ti -1c
.RI "template<typename eT > arma::Mat< eT > \fBColumnCovariance\fP (const arma::Mat< eT > &A, const size_t norm_type=0)"
.br
.ti -1c
.RI "template<typename T > arma::Mat< std::complex< T > > \fBColumnCovariance\fP (const arma::Mat< std::complex< T > > &A, const size_t norm_type=0)"
.br
.ti -1c
.RI "void \fBCustomRandomSeed\fP (const size_t seed)"
.br
.ti -1c
.RI "void \fBFixedRandomSeed\fP ()"
.br
.RI "Set the random seed to a fixed number\&. "
.ti -1c
.RI "template<typename T > T \fBLogAdd\fP (T x, T y)"
.br
.RI "Internal log-addition\&. "
.ti -1c
.RI "template<typename T , bool InPlace = false> void \fBLogSumExp\fP (const T &x, arma::Col< typename T::elem_type > &y)"
.br
.RI "Compute the sum of exponentials of each element in each column, then compute the log of that\&. "
.ti -1c
.RI "template<typename T , bool InPlace = false> void \fBLogSumExpT\fP (const T &x, arma::Col< typename T::elem_type > &y)"
.br
.RI "Compute the sum of exponentials of each element in each row, then compute the log of that\&. "
.ti -1c
.RI "template<typename ElemType > arma::Cube< ElemType > \fBMakeAlias\fP (arma::Cube< ElemType > &input, const bool strict=true)"
.br
.RI "Make an alias of a dense cube\&. "
.ti -1c
.RI "template<typename ElemType > arma::Mat< ElemType > \fBMakeAlias\fP (arma::Mat< ElemType > &input, const bool strict=true)"
.br
.RI "Make an alias of a dense matrix\&. "
.ti -1c
.RI "template<typename ElemType > arma::Row< ElemType > \fBMakeAlias\fP (arma::Row< ElemType > &input, const bool strict=true)"
.br
.RI "Make an alias of a dense row\&. "
.ti -1c
.RI "template<typename ElemType > arma::Col< ElemType > \fBMakeAlias\fP (arma::Col< ElemType > &input, const bool strict=true)"
.br
.RI "Make an alias of a dense column\&. "
.ti -1c
.RI "template<typename ElemType > arma::SpMat< ElemType > \fBMakeAlias\fP (const arma::SpMat< ElemType > &input, const bool=true)"
.br
.RI "Make a copy of a sparse matrix (an alias is not possible)\&. "
.ti -1c
.RI "template<typename ElemType > arma::SpRow< ElemType > \fBMakeAlias\fP (const arma::SpRow< ElemType > &input, const bool=true)"
.br
.RI "Make a copy of a sparse row (an alias is not possible)\&. "
.ti -1c
.RI "template<typename ElemType > arma::SpCol< ElemType > \fBMakeAlias\fP (const arma::SpCol< ElemType > &input, const bool=true)"
.br
.RI "Make a copy of a sparse column (an alias is not possible)\&. "
.ti -1c
.RI "template<typename CubeType > CubeType \fBMultiplyCube2Cube\fP (const CubeType &cubeA, const CubeType &cubeB, const bool aTranspose=false, const bool bTranspose=false)"
.br
.RI "Matrix multiplication of slices of two cubes\&. "
.ti -1c
.RI "template<typename CubeType , typename MatType > CubeType \fBMultiplyCube2Mat\fP (const CubeType &cubeA, const MatType &matB, const bool aTranspose=false, const bool bTranspose=false)"
.br
.RI "Matrix multiplication of all slices of a cube with a matrix\&. "
.ti -1c
.RI "template<typename MatType , typename CubeType > CubeType \fBMultiplyMat2Cube\fP (const MatType &matA, const CubeType &cubeB, const bool aTranspose=false, const bool bTranspose=false)"
.br
.RI "Matrix multiplication of a matrix and all the slices of a cube\&. "
.ti -1c
.RI "void \fBObtainDistinctSamples\fP (const size_t loInclusive, const size_t hiExclusive, const size_t maxNumSamples, arma::uvec &distinctSamples)"
.br
.RI "Obtains no more than maxNumSamples distinct samples\&. "
.ti -1c
.RI "void \fBOrthogonalize\fP (const arma::mat &x, arma::mat &W)"
.br
.RI "Orthogonalize x and return the result in W, using eigendecomposition\&. "
.ti -1c
.RI "void \fBOrthogonalize\fP (arma::mat &x)"
.br
.RI "Orthogonalize x in-place\&. "
.ti -1c
.RI "double \fBRandBernoulli\fP (const double input)"
.br
.RI "Generates a 0/1 specified by the input\&. "
.ti -1c
.RI "int \fBRandInt\fP (const int hiExclusive)"
.br
.RI "Generates a uniform random integer\&. "
.ti -1c
.RI "int \fBRandInt\fP (const int lo, const int hiExclusive)"
.br
.RI "Generates a uniform random integer\&. "
.ti -1c
.RI "double \fBRandNormal\fP ()"
.br
.RI "Generates a normally distributed random number with mean 0 and variance 1\&. "
.ti -1c
.RI "double \fBRandNormal\fP (const double mean, const double variance)"
.br
.RI "Generates a normally distributed random number with specified mean and variance\&. "
.ti -1c
.RI "double \fBRandom\fP ()"
.br
.RI "Generates a uniform random number between 0 and 1\&. "
.ti -1c
.RI "double \fBRandom\fP (const double lo, const double hi)"
.br
.RI "Generates a uniform random number in the specified range\&. "
.ti -1c
.RI "void \fBRandomBasis\fP (arma::mat &basis, const size_t d)"
.br
.RI "Create a random d-dimensional orthogonal basis, storing it in the given matrix\&. "
.ti -1c
.RI "void \fBRandomSeed\fP (const size_t seed)"
.br
.RI "Set the random seed used by the random functions (\fBRandom()\fP and \fBRandInt()\fP)\&. "
.ti -1c
.RI "void \fBRandVector\fP (arma::vec &v)"
.br
.RI "Overwrites a dimension-N vector to a random vector on the unit sphere in R^N\&. "
.ti -1c
.RI "void \fBRemoveRows\fP (const arma::mat &input, const std::vector< size_t > &rowsToRemove, arma::mat &output)"
.br
.RI "Remove a certain set of rows in a matrix while copying to a second matrix\&. "
.ti -1c
.RI "template<typename MatType , typename LabelsType > void \fBShuffleData\fP (const MatType &inputPoints, const LabelsType &inputLabels, MatType &outputPoints, LabelsType &outputLabels, const \fBstd::enable_if_t\fP<!arma::is_SpMat< MatType >::value > *=0, const \fBstd::enable_if_t\fP<!arma::is_Cube< MatType >::value > *=0)"
.br
.RI "Shuffle a dataset and associated labels (or responses)\&. "
.ti -1c
.RI "template<typename MatType , typename LabelsType > void \fBShuffleData\fP (const MatType &inputPoints, const LabelsType &inputLabels, MatType &outputPoints, LabelsType &outputLabels, const \fBstd::enable_if_t\fP< arma::is_SpMat< MatType >::value > *=0, const \fBstd::enable_if_t\fP<!arma::is_Cube< MatType >::value > *=0)"
.br
.RI "Shuffle a sparse dataset and associated labels (or responses)\&. "
.ti -1c
.RI "template<typename MatType , typename LabelsType > void \fBShuffleData\fP (const MatType &inputPoints, const LabelsType &inputLabels, MatType &outputPoints, LabelsType &outputLabels, const \fBstd::enable_if_t\fP<!arma::is_SpMat< MatType >::value > *=0, const \fBstd::enable_if_t\fP< arma::is_Cube< MatType >::value > *=0, const \fBstd::enable_if_t\fP< arma::is_Cube< LabelsType >::value > *=0)"
.br
.RI "Shuffle a cube-shaped dataset and associated labels (or responses) which are also cube-shaped\&. "
.ti -1c
.RI "template<typename MatType , typename LabelsType , typename WeightsType > void \fBShuffleData\fP (const MatType &inputPoints, const LabelsType &inputLabels, const WeightsType &inputWeights, MatType &outputPoints, LabelsType &outputLabels, WeightsType &outputWeights, const \fBstd::enable_if_t\fP<!arma::is_SpMat< MatType >::value > *=0, const \fBstd::enable_if_t\fP<!arma::is_Cube< MatType >::value > *=0)"
.br
.RI "Shuffle a dataset and associated labels (or responses) and weights\&. "
.ti -1c
.RI "template<typename MatType , typename LabelsType , typename WeightsType > void \fBShuffleData\fP (const MatType &inputPoints, const LabelsType &inputLabels, const WeightsType &inputWeights, MatType &outputPoints, LabelsType &outputLabels, WeightsType &outputWeights, const \fBstd::enable_if_t\fP< arma::is_SpMat< MatType >::value > *=0, const \fBstd::enable_if_t\fP<!arma::is_Cube< MatType >::value > *=0)"
.br
.RI "Shuffle a sparse dataset and associated labels (or responses) and weights\&. "
.ti -1c
.RI "template<typename T > T \fBSign\fP (const T x)"
.br
.RI "Signum function\&. "
.ti -1c
.RI "void \fBSmat\fP (const arma::vec &input, arma::mat &output)"
.br
.RI "The inverse of Svec\&. "
.ti -1c
.RI "void \fBSvec\fP (const arma::mat &input, arma::vec &output)"
.br
.RI "Upper triangular representation of a symmetric matrix, scaled such that, dot(Svec(A), Svec(B)) == dot(A, B) for symmetric A, B\&. "
.ti -1c
.RI "void \fBSvec\fP (const arma::sp_mat &input, arma::sp_vec &output)"
.br
.ti -1c
.RI "size_t \fBSvecIndex\fP (size_t i, size_t j, size_t n)"
.br
.RI "Return the index such that A[i,j] == factr(i, j) * svec(A)[pos(i, j)], where factr(i, j) = sqrt(2) if i != j and 1 otherwise\&. "
.ti -1c
.RI "void \fBSymKronId\fP (const arma::mat &A, arma::mat &op)"
.br
.RI "If A is a symmetric matrix, then SymKronId returns an operator Op such that\&. "
.ti -1c
.RI "void \fBVectorPower\fP (arma::vec &vec, const double power)"
.br
.RI "Auxiliary function to raise vector elements to a specific power\&. "
.ti -1c
.RI "void \fBWhitenUsingSVD\fP (const arma::mat &x, arma::mat &xWhitened, arma::mat &whiteningMatrix)"
.br
.RI "Whitens a matrix using the singular value decomposition of the covariance matrix\&. "
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "MLPACK_EXPORT std::mt19937 \fBrandGen\fP"
.br
.RI "MLPACK_EXPORT is required for global variables; it exports the symbols correctly on Windows\&. "
.ti -1c
.RI "MLPACK_EXPORT std::normal_distribution \fBrandNormalDist\fP"
.br
.ti -1c
.RI "MLPACK_EXPORT std::uniform_real_distribution \fBrandUniformDist\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Miscellaneous math routines\&. 


.SH "Function Documentation"
.PP 
.SS "T::elem_type mlpack::math::AccuLog (const T & x)"

.PP
Log-sum a vector of log values\&. (T should be an Armadillo type\&.)
.PP
\fBParameters:\fP
.RS 4
\fIx\fP vector of log values 
.RE
.PP
\fBReturns:\fP
.RS 4
log(e^x0 + e^x1 + \&.\&.\&.) 
.RE
.PP

.SS "void mlpack::math::Center (const arma::mat & x, arma::mat & xCentered)"

.PP
Creates a centered matrix, where centering is done by subtracting the sum over the columns (a column vector) from each column of the matrix\&. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP Input matrix 
.br
\fIxCentered\fP Matrix to write centered output into 
.RE
.PP

.PP
Referenced by NystroemKernelRule< KernelType, PointSelectionPolicy >::ApplyKernelMatrix(), and HRectBound< MetricType >::Metric()\&.
.SS "double mlpack::math::ClampNonNegative (const double d)\fC [inline]\fP"

.PP
Forces a number to be non-negative, turning negative numbers into zero\&. Avoids branching costs (this is a measurable improvement)\&.
.PP
\fBParameters:\fP
.RS 4
\fId\fP Double to clamp\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
0 if d < 0, d otherwise\&. 
.RE
.PP

.PP
Definition at line 28 of file clamp\&.hpp\&.
.PP
Referenced by ClampRange()\&.
.SS "double mlpack::math::ClampNonPositive (const double d)\fC [inline]\fP"

.PP
Forces a number to be non-positive, turning positive numbers into zero\&. Avoids branching costs (this is a measurable improvement)\&.
.PP
\fBParameters:\fP
.RS 4
\fId\fP Double to clamp\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
0 if d > 0, d otherwise\&. 
.RE
.PP

.PP
Definition at line 40 of file clamp\&.hpp\&.
.PP
Referenced by ClampRange()\&.
.SS "double mlpack::math::ClampRange (double value, const double rangeMin, const double rangeMax)\fC [inline]\fP"

.PP
Clamp a number between a particular range\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvalue\fP The number to clamp\&. 
.br
\fIrangeMin\fP The first of the range\&. 
.br
\fIrangeMax\fP The last of the range\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
max(rangeMin, min(rangeMax, d))\&. 
.RE
.PP

.PP
Definition at line 53 of file clamp\&.hpp\&.
.PP
References ClampNonNegative(), and ClampNonPositive()\&.
.PP
Referenced by RewardClipping< EnvironmentType >::Sample(), ContinuousMountainCar::Sample(), MountainCar::Sample(), Pendulum::Sample(), and Acrobot::Sample()\&.
.SS "void mlpack::math::ClearAlias (arma::Mat< ElemType > & mat)"

.PP
Clear an alias so that no data is overwritten\&. This resets the matrix if it is an alias (and does nothing otherwise)\&. 
.PP
Definition at line 110 of file make_alias\&.hpp\&.
.SS "void mlpack::math::ClearAlias (arma::SpMat< ElemType > &)"

.PP
Clear an alias for a sparse matrix\&. This does nothing because no sparse matrices can have aliases\&. 
.PP
Definition at line 121 of file make_alias\&.hpp\&.
.SS "arma::Mat<eT> mlpack::math::ColumnCovariance (const arma::Mat< eT > & A, const size_t norm_type = \fC0\fP)\fC [inline]\fP"

.PP
Referenced by PCAWhitening::Fit()\&.
.SS "arma::Mat< std::complex<T> > mlpack::math::ColumnCovariance (const arma::Mat< std::complex< T > > & A, const size_t norm_type = \fC0\fP)\fC [inline]\fP"

.SS "void mlpack::math::CustomRandomSeed (const size_t seed)\fC [inline]\fP"

.PP
Definition at line 72 of file random\&.hpp\&.
.SS "void mlpack::math::FixedRandomSeed ()\fC [inline]\fP"

.PP
Set the random seed to a fixed number\&. This function is used in binding tests to set a fixed random seed before calling mlpack()\&. In this way we can test whether a certain parameter makes a difference to execution of CLI binding\&. Refer to pull request #1306 for discussion on this function\&. 
.PP
Definition at line 64 of file random\&.hpp\&.
.SS "T mlpack::math::LogAdd (T x, T y)"

.PP
Internal log-addition\&. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP log value 
.br
\fIy\fP log value 
.RE
.PP
\fBReturns:\fP
.RS 4
log(e^x + e^y) 
.RE
.PP

.SS "void mlpack::math::LogSumExp (const T & x, arma::Col< typename T::elem_type > & y)"

.PP
Compute the sum of exponentials of each element in each column, then compute the log of that\&. If InPlace is true, then the values of \fCy\fP will also be added to the sum\&.
.PP
That is, if InPlace is false, then this method will set \fCy\fP such that: 
.PP
.nf
`y_i = log(sum(exp(x.col(i))))`

.fi
.PP
.PP
and if InPlace is true, then \fCy\fP will be set such that: 
.PP
.nf
`y_i = log(sum(exp(x.col(i))) + exp(y_i))`.
.fi
.PP
 
.SS "void mlpack::math::LogSumExpT (const T & x, arma::Col< typename T::elem_type > & y)"

.PP
Compute the sum of exponentials of each element in each row, then compute the log of that\&. If InPlace is true, then the values of \fCy\fP will also be added to the sum\&.
.PP
That is, if InPlace is false, then this method will set \fCy\fP such that: 
.PP
.nf
`y_i = log(sum(exp(x.row(i))))`

.fi
.PP
.PP
and if InPlace is true, then \fCy\fP will be set such that: 
.PP
.nf
`y_i = log(sum(exp(x.row(i))) + exp(y_i))`.
.fi
.PP
 
.SS "arma::Cube<ElemType> mlpack::math::MakeAlias (arma::Cube< ElemType > & input, const bool strict = \fCtrue\fP)"

.PP
Make an alias of a dense cube\&. If strict is true, then the alias cannot be resized or pointed at new memory\&. 
.PP
Definition at line 24 of file make_alias\&.hpp\&.
.SS "arma::Mat<ElemType> mlpack::math::MakeAlias (arma::Mat< ElemType > & input, const bool strict = \fCtrue\fP)"

.PP
Make an alias of a dense matrix\&. If strict is true, then the alias cannot be resized or pointed at new memory\&. 
.PP
Definition at line 37 of file make_alias\&.hpp\&.
.SS "arma::Row<ElemType> mlpack::math::MakeAlias (arma::Row< ElemType > & input, const bool strict = \fCtrue\fP)"

.PP
Make an alias of a dense row\&. If strict is true, then the alias cannot be resized or pointed at new memory\&. 
.PP
Definition at line 50 of file make_alias\&.hpp\&.
.SS "arma::Col<ElemType> mlpack::math::MakeAlias (arma::Col< ElemType > & input, const bool strict = \fCtrue\fP)"

.PP
Make an alias of a dense column\&. If strict is true, then the alias cannot be resized or pointed at new memory\&. 
.PP
Definition at line 62 of file make_alias\&.hpp\&.
.SS "arma::SpMat<ElemType> mlpack::math::MakeAlias (const arma::SpMat< ElemType > & input, const bool = \fCtrue\fP)"

.PP
Make a copy of a sparse matrix (an alias is not possible)\&. The strict parameter is ignored\&. 
.PP
Definition at line 74 of file make_alias\&.hpp\&.
.SS "arma::SpRow<ElemType> mlpack::math::MakeAlias (const arma::SpRow< ElemType > & input, const bool = \fCtrue\fP)"

.PP
Make a copy of a sparse row (an alias is not possible)\&. The strict parameter is ignored\&. 
.PP
Definition at line 86 of file make_alias\&.hpp\&.
.SS "arma::SpCol<ElemType> mlpack::math::MakeAlias (const arma::SpCol< ElemType > & input, const bool = \fCtrue\fP)"

.PP
Make a copy of a sparse column (an alias is not possible)\&. The strict parameter is ignored\&. 
.PP
Definition at line 98 of file make_alias\&.hpp\&.
.SS "CubeType mlpack::math::MultiplyCube2Cube (const CubeType & cubeA, const CubeType & cubeB, const bool aTranspose = \fCfalse\fP, const bool bTranspose = \fCfalse\fP)"

.PP
Matrix multiplication of slices of two cubes\&. This function expects both cubes to have the same number of slices\&. For example, a valid operation would be: cube A of shape (m, p, s) multiplied by cube B of shape (p, n, s) resulting in a cube of shape (m, n, s)\&.
.PP
\fBParameters:\fP
.RS 4
\fIcubeA\fP First cube\&. 
.br
\fIcubeB\fP Second cube\&. 
.br
\fIaTranspose\fP Whether slices of first cube have to be transposed\&. 
.br
\fIbTranspose\fP Whether slices of second cube have to be transposed\&. 
.RE
.PP

.SS "CubeType mlpack::math::MultiplyCube2Mat (const CubeType & cubeA, const MatType & matB, const bool aTranspose = \fCfalse\fP, const bool bTranspose = \fCfalse\fP)"

.PP
Matrix multiplication of all slices of a cube with a matrix\&. This function is used when the first object is a cube and the second object is a matrix\&. For example, a valid operation would be: cube A of shape (m, p, s) multiplied by a matrix of shape (p, n) resulting in a cube of shape (m, n, s)\&.
.PP
\fBParameters:\fP
.RS 4
\fIcubeA\fP The cube as the first operand\&. 
.br
\fImatB\fP The matrix as the second operand\&. 
.br
\fIaTranspose\fP Whether slices of cube have to be transposed\&. 
.br
\fIbTranspose\fP Whether matrix has to be transposed\&. 
.RE
.PP

.SS "CubeType mlpack::math::MultiplyMat2Cube (const MatType & matA, const CubeType & cubeB, const bool aTranspose = \fCfalse\fP, const bool bTranspose = \fCfalse\fP)"

.PP
Matrix multiplication of a matrix and all the slices of a cube\&. This function is used when the first object is a matrix and the second object is a cube\&. For example, a valid operation would be: matrix A of shape (m, p) multiplied by cube B of shape (p, n, s) resulting in a cube of shape (m, n, s)\&.
.PP
\fBParameters:\fP
.RS 4
\fImatA\fP The matrix as the first operand\&. 
.br
\fIcubeB\fP The cube as the second operand\&. 
.br
\fIaTranspose\fP Whether matrix has to be transposed\&. 
.br
\fIbTranspose\fP Whether slices of cube have to be transposed\&. 
.RE
.PP

.SS "void mlpack::math::ObtainDistinctSamples (const size_t loInclusive, const size_t hiExclusive, const size_t maxNumSamples, arma::uvec & distinctSamples)\fC [inline]\fP"

.PP
Obtains no more than maxNumSamples distinct samples\&. Each sample belongs to [loInclusive, hiExclusive)\&.
.PP
\fBParameters:\fP
.RS 4
\fIloInclusive\fP The lower bound (inclusive)\&. 
.br
\fIhiExclusive\fP The high bound (exclusive)\&. 
.br
\fImaxNumSamples\fP The maximum number of samples to obtain\&. 
.br
\fIdistinctSamples\fP The samples that will be obtained\&. 
.RE
.PP

.PP
Definition at line 153 of file random\&.hpp\&.
.PP
References RandInt()\&.
.SS "void mlpack::math::Orthogonalize (const arma::mat & x, arma::mat & W)"

.PP
Orthogonalize x and return the result in W, using eigendecomposition\&. We will be using the formula $ W = x (x^T x)^{-0.5} $\&. 
.SS "void mlpack::math::Orthogonalize (arma::mat & x)"

.PP
Orthogonalize x in-place\&. This could be sped up by a custom implementation\&. 
.SS "double mlpack::math::RandBernoulli (const double input)\fC [inline]\fP"

.PP
Generates a 0/1 specified by the input\&. 
.PP
Definition at line 99 of file random\&.hpp\&.
.PP
References Random()\&.
.SS "int mlpack::math::RandInt (const int hiExclusive)\fC [inline]\fP"

.PP
Generates a uniform random integer\&. 
.PP
Definition at line 110 of file random\&.hpp\&.
.PP
References randUniformDist\&.
.PP
Referenced by RandomDimensionSelect::Begin(), MultipleRandomDimensionSelect::Begin(), SampleInitialization::Cluster(), KMeansPlusPlusInitialization::Cluster(), DataDependentRandomInitializer::Initialize(), RandomAcolInitialization< columnsToAverage >::Initialize(), ObtainDistinctSamples(), GreedyPolicy< EnvironmentType >::Sample(), RandomSelection::Select(), and RandomPointSelection::Select()\&.
.SS "int mlpack::math::RandInt (const int lo, const int hiExclusive)\fC [inline]\fP"

.PP
Generates a uniform random integer\&. 
.PP
Definition at line 118 of file random\&.hpp\&.
.PP
References randUniformDist\&.
.SS "double mlpack::math::RandNormal ()\fC [inline]\fP"

.PP
Generates a normally distributed random number with mean 0 and variance 1\&. 
.PP
Definition at line 127 of file random\&.hpp\&.
.PP
References randNormalDist\&.
.PP
Referenced by GaussianInitialization::Initialize()\&.
.SS "double mlpack::math::RandNormal (const double mean, const double variance)\fC [inline]\fP"

.PP
Generates a normally distributed random number with specified mean and variance\&. 
.PP
\fBParameters:\fP
.RS 4
\fImean\fP Mean of distribution\&. 
.br
\fIvariance\fP Variance of distribution\&. 
.RE
.PP

.PP
Definition at line 139 of file random\&.hpp\&.
.PP
References randNormalDist\&.
.SS "double mlpack::math::Random ()\fC [inline]\fP"

.PP
Generates a uniform random number between 0 and 1\&. 
.PP
Definition at line 83 of file random\&.hpp\&.
.PP
References randUniformDist\&.
.PP
Referenced by KMeansPlusPlusInitialization::Cluster(), ContinuousMountainCar::InitialSample(), Pendulum::InitialSample(), MockCategoricalData(), RandBernoulli(), GreedyPolicy< EnvironmentType >::Sample(), and Acrobot::Torque()\&.
.SS "double mlpack::math::Random (const double lo, const double hi)\fC [inline]\fP"

.PP
Generates a uniform random number in the specified range\&. 
.PP
Definition at line 91 of file random\&.hpp\&.
.PP
References randUniformDist\&.
.SS "void mlpack::math::RandomBasis (arma::mat & basis, const size_t d)"

.PP
Create a random d-dimensional orthogonal basis, storing it in the given matrix\&. 
.PP
\fBParameters:\fP
.RS 4
\fIbasis\fP Matrix to store basis in\&. 
.br
\fId\fP Desired number of dimensions in the basis\&. 
.RE
.PP

.SS "void mlpack::math::RandomSeed (const size_t seed)\fC [inline]\fP"

.PP
Set the random seed used by the random functions (\fBRandom()\fP and \fBRandInt()\fP)\&. The seed is casted to a 32-bit integer before being given to the random number generator, but a size_t is taken as a parameter for API consistency\&.
.PP
\fBParameters:\fP
.RS 4
\fIseed\fP Seed for the random number generator\&. 
.RE
.PP

.PP
Definition at line 40 of file random\&.hpp\&.
.SS "void mlpack::math::RandVector (arma::vec & v)"

.PP
Overwrites a dimension-N vector to a random vector on the unit sphere in R^N\&. 
.SS "void mlpack::math::RemoveRows (const arma::mat & input, const std::vector< size_t > & rowsToRemove, arma::mat & output)"

.PP
Remove a certain set of rows in a matrix while copying to a second matrix\&. 
.PP
\fBParameters:\fP
.RS 4
\fIinput\fP Input matrix to copy\&. 
.br
\fIrowsToRemove\fP Vector containing indices of rows to be removed\&. 
.br
\fIoutput\fP Matrix to copy non-removed rows into\&. 
.RE
.PP

.SS "void mlpack::math::ShuffleData (const MatType & inputPoints, const LabelsType & inputLabels, MatType & outputPoints, LabelsType & outputLabels, const \fBstd::enable_if_t\fP<!arma::is_SpMat< MatType >::value > * = \fC0\fP, const \fBstd::enable_if_t\fP<!arma::is_Cube< MatType >::value > * = \fC0\fP)"

.PP
Shuffle a dataset and associated labels (or responses)\&. It is expected that inputPoints and inputLabels have the same number of columns (so, be sure that inputLabels, if it is a vector, is a row vector)\&.
.PP
Shuffled data will be output into outputPoints and outputLabels\&. 
.PP
Definition at line 28 of file shuffle_data\&.hpp\&.
.SS "void mlpack::math::ShuffleData (const MatType & inputPoints, const LabelsType & inputLabels, MatType & outputPoints, LabelsType & outputLabels, const \fBstd::enable_if_t\fP< arma::is_SpMat< MatType >::value > * = \fC0\fP, const \fBstd::enable_if_t\fP<!arma::is_Cube< MatType >::value > * = \fC0\fP)"

.PP
Shuffle a sparse dataset and associated labels (or responses)\&. It is expected that inputPoints and inputLabels have the same number of columns (so, be sure that inputLabels, if it is a vector, is a row vector)\&.
.PP
Shuffled data will be output into outputPoints and outputLabels\&. 
.PP
Definition at line 51 of file shuffle_data\&.hpp\&.
.SS "void mlpack::math::ShuffleData (const MatType & inputPoints, const LabelsType & inputLabels, MatType & outputPoints, LabelsType & outputLabels, const \fBstd::enable_if_t\fP<!arma::is_SpMat< MatType >::value > * = \fC0\fP, const \fBstd::enable_if_t\fP< arma::is_Cube< MatType >::value > * = \fC0\fP, const \fBstd::enable_if_t\fP< arma::is_Cube< LabelsType >::value > * = \fC0\fP)"

.PP
Shuffle a cube-shaped dataset and associated labels (or responses) which are also cube-shaped\&. It is expected that inputPoints and inputLabels have the same number of columns\&.
.PP
Shuffled data will be output into outputPoints and outputLabels\&. 
.PP
Definition at line 103 of file shuffle_data\&.hpp\&.
.SS "void mlpack::math::ShuffleData (const MatType & inputPoints, const LabelsType & inputLabels, const WeightsType & inputWeights, MatType & outputPoints, LabelsType & outputLabels, WeightsType & outputWeights, const \fBstd::enable_if_t\fP<!arma::is_SpMat< MatType >::value > * = \fC0\fP, const \fBstd::enable_if_t\fP<!arma::is_Cube< MatType >::value > * = \fC0\fP)"

.PP
Shuffle a dataset and associated labels (or responses) and weights\&. It is expected that inputPoints and inputLabels and inputWeights have the same number of columns (so, be sure that inputLabels, if it is a vector, is a row vector)\&.
.PP
Shuffled data will be output into outputPoints and outputLabels and outputWeights\&. 
.PP
Definition at line 160 of file shuffle_data\&.hpp\&.
.SS "void mlpack::math::ShuffleData (const MatType & inputPoints, const LabelsType & inputLabels, const WeightsType & inputWeights, MatType & outputPoints, LabelsType & outputLabels, WeightsType & outputWeights, const \fBstd::enable_if_t\fP< arma::is_SpMat< MatType >::value > * = \fC0\fP, const \fBstd::enable_if_t\fP<!arma::is_Cube< MatType >::value > * = \fC0\fP)"

.PP
Shuffle a sparse dataset and associated labels (or responses) and weights\&. It is expected that inputPoints and inputLabels and inputWeights have the same number of columns (so, be sure that inputLabels, if it is a vector, is a row vector)\&.
.PP
Shuffled data will be output into outputPoints and outputLabels and outputWeights\&. 
.PP
Definition at line 188 of file shuffle_data\&.hpp\&.
.SS "T mlpack::math::Sign (const T x)"

.PP
Signum function\&. Return 1 if x>0; return 0 if x=0; return -1 if x<0\&. Return type are the same as input type\&.
.PP
\fBParameters:\fP
.RS 4
\fIx\fP Number of any type\&. 
.RE
.PP

.PP
Definition at line 128 of file lin_alg\&.hpp\&.
.SS "void mlpack::math::Smat (const arma::vec & input, arma::mat & output)"

.PP
The inverse of Svec\&. That is, Smat(Svec(A)) == A\&.
.PP
\fBParameters:\fP
.RS 4
\fIinput\fP 
.br
\fIoutput\fP A symmetric matrix 
.RE
.PP

.SS "void mlpack::math::Svec (const arma::mat & input, arma::vec & output)"

.PP
Upper triangular representation of a symmetric matrix, scaled such that, dot(Svec(A), Svec(B)) == dot(A, B) for symmetric A, B\&. Specifically,
.PP
Svec(K) = [ K_11, sqrt(2) K_12, \&.\&.\&., sqrt(2) K_1n, K_22, \&.\&.\&., sqrt(2) K_2n, \&.\&.\&., K_nn ]^T
.PP
\fBParameters:\fP
.RS 4
\fIinput\fP A symmetric matrix 
.br
\fIoutput\fP 
.RE
.PP

.SS "void mlpack::math::Svec (const arma::sp_mat & input, arma::sp_vec & output)"

.SS "size_t mlpack::math::SvecIndex (size_t i, size_t j, size_t n)\fC [inline]\fP"

.PP
Return the index such that A[i,j] == factr(i, j) * svec(A)[pos(i, j)], where factr(i, j) = sqrt(2) if i != j and 1 otherwise\&. 
.PP
\fBParameters:\fP
.RS 4
\fIi\fP 
.br
\fIj\fP 
.br
\fIn\fP 
.RE
.PP

.SS "void mlpack::math::SymKronId (const arma::mat & A, arma::mat & op)"

.PP
If A is a symmetric matrix, then SymKronId returns an operator Op such that\&. Op * svec(X) == svec(0\&.5 * (AX + XA))
.PP
for every symmetric matrix X
.PP
\fBParameters:\fP
.RS 4
\fIA\fP 
.br
\fIop\fP 
.RE
.PP

.SS "void mlpack::math::VectorPower (arma::vec & vec, const double power)"

.PP
Auxiliary function to raise vector elements to a specific power\&. The sign is ignored in the power operation and then re-added\&. Useful for eigenvalues\&. 
.SS "void mlpack::math::WhitenUsingSVD (const arma::mat & x, arma::mat & xWhitened, arma::mat & whiteningMatrix)"

.PP
Whitens a matrix using the singular value decomposition of the covariance matrix\&. Whitening means the covariance matrix of the result is the identity matrix\&. 
.SH "Variable Documentation"
.PP 
.SS "MLPACK_EXPORT std::mt19937 randGen"

.PP
MLPACK_EXPORT is required for global variables; it exports the symbols correctly on Windows\&. 
.SS "MLPACK_EXPORT std::normal_distribution randNormalDist"

.PP
Referenced by RandNormal()\&.
.SS "MLPACK_EXPORT std::uniform_real_distribution randUniformDist"

.PP
Referenced by RandInt(), and Random()\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for mlpack from the source code\&.
