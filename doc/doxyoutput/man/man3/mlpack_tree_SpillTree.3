.TH "SpillTree< MetricType, StatisticType, MatType, HyperplaneType, SplitType >" 3 "Sun Aug 22 2021" "Version 3.4.2" "mlpack" \" -*- nroff -*-
.ad l
.nh
.SH NAME
SpillTree< MetricType, StatisticType, MatType, HyperplaneType, SplitType > \- A hybrid spill tree is a variant of binary space trees in which the children of a node can 'spill over' each other, and contain shared datapoints\&.  

.SH SYNOPSIS
.br
.PP
.SS "Classes"

.in +1c
.ti -1c
.RI "class \fBSpillDualTreeTraverser\fP"
.br
.RI "A generic dual-tree traverser for hybrid spill trees; see \fBspill_dual_tree_traverser\&.hpp\fP for implementation\&. "
.ti -1c
.RI "class \fBSpillSingleTreeTraverser\fP"
.br
.RI "A generic single-tree traverser for hybrid spill trees; see \fBspill_single_tree_traverser\&.hpp\fP for implementation\&. "
.in -1c
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef HyperplaneType< MetricType >::\fBBoundType\fP \fBBoundType\fP"
.br
.RI "The bound type\&. "
.ti -1c
.RI "template<typename RuleType > using \fBDefeatistDualTreeTraverser\fP = \fBSpillDualTreeTraverser\fP< RuleType, true >"
.br
.RI "A defeatist dual-tree traverser for hybrid spill trees\&. "
.ti -1c
.RI "template<typename RuleType > using \fBDefeatistSingleTreeTraverser\fP = \fBSpillSingleTreeTraverser\fP< RuleType, true >"
.br
.RI "A defeatist single-tree traverser for hybrid spill trees\&. "
.ti -1c
.RI "template<typename RuleType > using \fBDualTreeTraverser\fP = \fBSpillDualTreeTraverser\fP< RuleType, false >"
.br
.RI "A dual-tree traverser for hybrid spill trees\&. "
.ti -1c
.RI "typedef MatType::elem_type \fBElemType\fP"
.br
.RI "The type of element held in MatType\&. "
.ti -1c
.RI "typedef MatType \fBMat\fP"
.br
.RI "So other classes can use TreeType::Mat\&. "
.ti -1c
.RI "template<typename RuleType > using \fBSingleTreeTraverser\fP = \fBSpillSingleTreeTraverser\fP< RuleType, false >"
.br
.RI "A single-tree traverser for hybrid spill trees\&. "
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBSpillTree\fP (const MatType &data, const double tau=0, const size_t maxLeafSize=20, const double rho=0\&.7)"
.br
.RI "Construct this as the root node of a hybrid spill tree using the given dataset\&. "
.ti -1c
.RI "\fBSpillTree\fP (MatType &&data, const double tau=0, const size_t maxLeafSize=20, const double rho=0\&.7)"
.br
.RI "Construct this as the root node of a hybrid spill tree using the given dataset\&. "
.ti -1c
.RI "\fBSpillTree\fP (\fBSpillTree\fP *parent, arma::Col< size_t > &points, const double tau=0, const size_t maxLeafSize=20, const double rho=0\&.7)"
.br
.RI "Construct this node as a child of the given parent, including the given list of points\&. "
.ti -1c
.RI "\fBSpillTree\fP (const \fBSpillTree\fP &other)"
.br
.RI "Create a hybrid spill tree by copying the other tree\&. "
.ti -1c
.RI "\fBSpillTree\fP (\fBSpillTree\fP &&other)"
.br
.RI "Move constructor for a \fBSpillTree\fP; possess all the members of the given tree\&. "
.ti -1c
.RI "template<typename Archive > \fBSpillTree\fP (Archive &ar, const typename \fBstd::enable_if_t\fP< \fBcereal::is_loading\fP< Archive >()> *=0)"
.br
.RI "Initialize the tree from a cereal archive\&. "
.ti -1c
.RI "\fB~SpillTree\fP ()"
.br
.RI "Deletes this node, deallocating the memory for the children and calling their destructors in turn\&. "
.ti -1c
.RI "const \fBBoundType\fP & \fBBound\fP () const"
.br
.RI "Return the bound object for this node\&. "
.ti -1c
.RI "\fBBoundType\fP & \fBBound\fP ()"
.br
.RI "Return the bound object for this node\&. "
.ti -1c
.RI "void \fBCenter\fP (arma::vec &center)"
.br
.RI "Store the center of the bounding region in the given vector\&. "
.ti -1c
.RI "\fBSpillTree\fP & \fBChild\fP (const size_t child) const"
.br
.RI "Return the specified child (0 will be left, 1 will be right)\&. "
.ti -1c
.RI "\fBSpillTree\fP *& \fBChildPtr\fP (const size_t child)"
.br
.ti -1c
.RI "const MatType & \fBDataset\fP () const"
.br
.RI "Get the dataset which the tree is built on\&. "
.ti -1c
.RI "size_t \fBDescendant\fP (const size_t index) const"
.br
.RI "Return the index (with reference to the dataset) of a particular descendant of this node\&. "
.ti -1c
.RI "\fBElemType\fP \fBFurthestDescendantDistance\fP () const"
.br
.RI "Return the furthest possible descendant distance\&. "
.ti -1c
.RI "\fBElemType\fP \fBFurthestPointDistance\fP () const"
.br
.RI "Return the furthest distance to a point held in this node\&. "
.ti -1c
.RI "template<typename VecType > size_t \fBGetFurthestChild\fP (const VecType &point, typename \fBstd::enable_if_t\fP< \fBIsVector\fP< VecType >::value > *=0)"
.br
.RI "Return the index of the furthest child node to the given query point (this is an efficient estimation based on the splitting hyperplane, the node returned is not necessarily the furthest)\&. "
.ti -1c
.RI "size_t \fBGetFurthestChild\fP (const \fBSpillTree\fP &queryNode)"
.br
.RI "Return the index of the furthest child node to the given query node (this is an efficient estimation based on the splitting hyperplane, the node returned is not necessarily the furthest)\&. "
.ti -1c
.RI "template<typename VecType > size_t \fBGetNearestChild\fP (const VecType &point, typename \fBstd::enable_if_t\fP< \fBIsVector\fP< VecType >::value > *=0)"
.br
.RI "Return the index of the nearest child node to the given query point (this is an efficient estimation based on the splitting hyperplane, the node returned is not necessarily the nearest)\&. "
.ti -1c
.RI "size_t \fBGetNearestChild\fP (const \fBSpillTree\fP &queryNode)"
.br
.RI "Return the index of the nearest child node to the given query node (this is an efficient estimation based on the splitting hyperplane, the node returned is not necessarily the nearest)\&. "
.ti -1c
.RI "const HyperplaneType< MetricType > & \fBHyperplane\fP () const"
.br
.RI "Get the Hyperplane instance\&. "
.ti -1c
.RI "bool \fBIsLeaf\fP () const"
.br
.RI "Return whether or not this node is a leaf (true if it has no children)\&. "
.ti -1c
.RI "\fBSpillTree\fP * \fBLeft\fP () const"
.br
.RI "Gets the left child of this node\&. "
.ti -1c
.RI "\fBSpillTree\fP *& \fBLeft\fP ()"
.br
.RI "Modify the left child of this node\&. "
.ti -1c
.RI "\fBElemType\fP \fBMaxDistance\fP (const \fBSpillTree\fP &other) const"
.br
.RI "Return the maximum distance to another node\&. "
.ti -1c
.RI "template<typename VecType > \fBElemType\fP \fBMaxDistance\fP (const VecType &point, typename \fBstd::enable_if_t\fP< \fBIsVector\fP< VecType >::value > *=0) const"
.br
.RI "Return the maximum distance to another point\&. "
.ti -1c
.RI "MetricType \fBMetric\fP () const"
.br
.RI "Get the metric that the tree uses\&. "
.ti -1c
.RI "\fBElemType\fP \fBMinDistance\fP (const \fBSpillTree\fP &other) const"
.br
.RI "Return the minimum distance to another node\&. "
.ti -1c
.RI "template<typename VecType > \fBElemType\fP \fBMinDistance\fP (const VecType &point, typename \fBstd::enable_if_t\fP< \fBIsVector\fP< VecType >::value > *=0) const"
.br
.RI "Return the minimum distance to another point\&. "
.ti -1c
.RI "\fBElemType\fP \fBMinimumBoundDistance\fP () const"
.br
.RI "Return the minimum distance from the center of the node to any bound edge\&. "
.ti -1c
.RI "size_t \fBNumChildren\fP () const"
.br
.RI "Return the number of children in this node\&. "
.ti -1c
.RI "size_t \fBNumDescendants\fP () const"
.br
.RI "Return the number of descendants of this node\&. "
.ti -1c
.RI "size_t \fBNumPoints\fP () const"
.br
.RI "Return the number of points in this node (0 if not a leaf)\&. "
.ti -1c
.RI "\fBSpillTree\fP & \fBoperator=\fP (const \fBSpillTree\fP &other)"
.br
.RI "Copy the given Spill Tree\&. "
.ti -1c
.RI "\fBSpillTree\fP & \fBoperator=\fP (\fBSpillTree\fP &&other)"
.br
.RI "Take ownership of the given Spill Tree\&. "
.ti -1c
.RI "bool \fBOverlap\fP () const"
.br
.RI "Distinguish overlapping nodes from non-overlapping nodes\&. "
.ti -1c
.RI "\fBSpillTree\fP * \fBParent\fP () const"
.br
.RI "Gets the parent of this node\&. "
.ti -1c
.RI "\fBSpillTree\fP *& \fBParent\fP ()"
.br
.RI "Modify the parent of this node\&. "
.ti -1c
.RI "\fBElemType\fP \fBParentDistance\fP () const"
.br
.RI "Return the distance from the center of this node to the center of the parent node\&. "
.ti -1c
.RI "\fBElemType\fP & \fBParentDistance\fP ()"
.br
.RI "Modify the distance from the center of this node to the center of the parent node\&. "
.ti -1c
.RI "size_t \fBPoint\fP (const size_t index) const"
.br
.RI "Return the index (with reference to the dataset) of a particular point in this node\&. "
.ti -1c
.RI "math::RangeType< \fBElemType\fP > \fBRangeDistance\fP (const \fBSpillTree\fP &other) const"
.br
.RI "Return the minimum and maximum distance to another node\&. "
.ti -1c
.RI "template<typename VecType > math::RangeType< \fBElemType\fP > \fBRangeDistance\fP (const VecType &point, typename \fBstd::enable_if_t\fP< \fBIsVector\fP< VecType >::value > *=0) const"
.br
.RI "Return the minimum and maximum distance to another point\&. "
.ti -1c
.RI "\fBSpillTree\fP * \fBRight\fP () const"
.br
.RI "Gets the right child of this node\&. "
.ti -1c
.RI "\fBSpillTree\fP *& \fBRight\fP ()"
.br
.RI "Modify the right child of this node\&. "
.ti -1c
.RI "template<typename Archive > void \fBserialize\fP (Archive &ar, const uint32_t version)"
.br
.RI "Serialize the tree\&. "
.ti -1c
.RI "const StatisticType & \fBStat\fP () const"
.br
.RI "Return the statistic object for this node\&. "
.ti -1c
.RI "StatisticType & \fBStat\fP ()"
.br
.RI "Return the statistic object for this node\&. "
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static bool \fBHasSelfChildren\fP ()"
.br
.RI "Returns false: this tree type does not have self children\&. "
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "\fBSpillTree\fP ()"
.br
.RI "A default constructor\&. "
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename MetricType, typename StatisticType = EmptyStatistic, typename MatType = arma::mat, template< typename HyperplaneMetricType > class HyperplaneType = AxisOrthogonalHyperplane, template< typename SplitMetricType, typename SplitMatType > class SplitType = MidpointSpaceSplit>
.br
class mlpack::tree::SpillTree< MetricType, StatisticType, MatType, HyperplaneType, SplitType >"
A hybrid spill tree is a variant of binary space trees in which the children of a node can 'spill over' each other, and contain shared datapoints\&. 

Two new separating planes lplane and rplane are defined, both of which are parallel to the original decision boundary and at a distance tau from it\&. The region between lplane and rplane is called 'overlapping buffer'\&.
.PP
For each node, we first split the points considering the overlapping buffer\&. If either of its children contains more than rho fraction of the total points we undo the overlapping splitting\&. Instead a conventional partition is used\&. In this way, we can ensure that each split reduces the number of points of a node by at least a constant factor\&.
.PP
This particular tree does not allow growth, so you cannot add or delete nodes from it\&. If you need to add or delete a node, the better procedure is to rebuild the tree entirely\&.
.PP
Three runtime parameters are required in the constructor:
.IP "\(bu" 2
maxLeafSize: Max leaf size to be used\&.
.IP "\(bu" 2
tau: Overlapping size\&.
.IP "\(bu" 2
rho: Balance threshold\&.
.PP
.PP
For more information on spill trees, see
.PP
.PP
.nf
@inproceedings{
  author = {Ting Liu, Andrew W\&. Moore, Alexander Gray and Ke Yang},
  title = {An Investigation of Practical Approximate Nearest Neighbor
    Algorithms},
  booktitle = {Advances in Neural Information Processing Systems 17},
  year = {2005},
  pages = {825--832}
}
.fi
.PP
.PP
\fBTemplate Parameters:\fP
.RS 4
\fIMetricType\fP The metric used for tree-building\&. 
.br
\fIStatisticType\fP Extra data contained in the node\&. See \fBstatistic\&.hpp\fP for the necessary skeleton interface\&. 
.br
\fIMatType\fP The dataset class\&. 
.br
\fIHyperplaneType\fP The splitting hyperplane class\&. 
.br
\fISplitType\fP The class that partitions the dataset/points at a particular node into two parts\&. Its definition decides the way this split is done\&. 
.RE
.PP

.PP
Definition at line 73 of file spill_tree\&.hpp\&.
.SH "Member Typedef Documentation"
.PP 
.SS "typedef HyperplaneType<MetricType>::\fBBoundType\fP \fBBoundType\fP"

.PP
The bound type\&. 
.PP
Definition at line 81 of file spill_tree\&.hpp\&.
.SS "using \fBDefeatistDualTreeTraverser\fP =  \fBSpillDualTreeTraverser\fP<RuleType, true>"

.PP
A defeatist dual-tree traverser for hybrid spill trees\&. 
.PP
Definition at line 146 of file spill_tree\&.hpp\&.
.SS "using \fBDefeatistSingleTreeTraverser\fP =  \fBSpillSingleTreeTraverser\fP<RuleType, true>"

.PP
A defeatist single-tree traverser for hybrid spill trees\&. 
.PP
Definition at line 138 of file spill_tree\&.hpp\&.
.SS "using \fBDualTreeTraverser\fP =  \fBSpillDualTreeTraverser\fP<RuleType, false>"

.PP
A dual-tree traverser for hybrid spill trees\&. 
.PP
Definition at line 142 of file spill_tree\&.hpp\&.
.SS "typedef MatType::elem_type \fBElemType\fP"

.PP
The type of element held in MatType\&. 
.PP
Definition at line 79 of file spill_tree\&.hpp\&.
.SS "typedef MatType \fBMat\fP"

.PP
So other classes can use TreeType::Mat\&. 
.PP
Definition at line 77 of file spill_tree\&.hpp\&.
.SS "using \fBSingleTreeTraverser\fP =  \fBSpillSingleTreeTraverser\fP<RuleType, false>"

.PP
A single-tree traverser for hybrid spill trees\&. 
.PP
Definition at line 134 of file spill_tree\&.hpp\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "\fBSpillTree\fP (const MatType & data, const double tau = \fC0\fP, const size_t maxLeafSize = \fC20\fP, const double rho = \fC0\&.7\fP)"

.PP
Construct this as the root node of a hybrid spill tree using the given dataset\&. The dataset will not be modified during the building procedure (unlike \fBBinarySpaceTree\fP)\&.
.PP
\fBParameters:\fP
.RS 4
\fIdata\fP Dataset to create tree from\&. 
.br
\fItau\fP Overlapping size\&. 
.br
\fImaxLeafSize\fP Size of each leaf in the tree\&. 
.br
\fIrho\fP Balance threshold\&. 
.RE
.PP

.SS "\fBSpillTree\fP (MatType && data, const double tau = \fC0\fP, const size_t maxLeafSize = \fC20\fP, const double rho = \fC0\&.7\fP)"

.PP
Construct this as the root node of a hybrid spill tree using the given dataset\&. This will take ownership of the data matrix; if you don't want this, consider using the constructor that takes a const reference to a dataset\&.
.PP
\fBParameters:\fP
.RS 4
\fIdata\fP Dataset to create tree from\&. 
.br
\fItau\fP Overlapping size\&. 
.br
\fImaxLeafSize\fP Size of each leaf in the tree\&. 
.br
\fIrho\fP Balance threshold\&. 
.RE
.PP

.SS "\fBSpillTree\fP (\fBSpillTree\fP< MetricType, StatisticType, MatType, HyperplaneType, SplitType > * parent, arma::Col< size_t > & points, const double tau = \fC0\fP, const size_t maxLeafSize = \fC20\fP, const double rho = \fC0\&.7\fP)"

.PP
Construct this node as a child of the given parent, including the given list of points\&. This is used for recursive tree-building by the other constructors which don't specify point indices\&.
.PP
\fBParameters:\fP
.RS 4
\fIparent\fP Parent of this node\&. 
.br
\fIpoints\fP Vector of indexes of points to be included in this node\&. 
.br
\fItau\fP Overlapping size\&. 
.br
\fImaxLeafSize\fP Size of each leaf in the tree\&. 
.br
\fIrho\fP Balance threshold\&. 
.RE
.PP

.SS "\fBSpillTree\fP (const \fBSpillTree\fP< MetricType, StatisticType, MatType, HyperplaneType, SplitType > & other)"

.PP
Create a hybrid spill tree by copying the other tree\&. Be careful! This can take a long time and use a lot of memory\&.
.PP
\fBParameters:\fP
.RS 4
\fIother\fP tree to be replicated\&. 
.RE
.PP

.SS "\fBSpillTree\fP (\fBSpillTree\fP< MetricType, StatisticType, MatType, HyperplaneType, SplitType > && other)"

.PP
Move constructor for a \fBSpillTree\fP; possess all the members of the given tree\&. 
.PP
\fBParameters:\fP
.RS 4
\fIother\fP tree to be moved\&. 
.RE
.PP

.SS "\fBSpillTree\fP (Archive & ar, const typename \fBstd::enable_if_t\fP< \fBcereal::is_loading\fP< Archive >()> * = \fC0\fP)"

.PP
Initialize the tree from a cereal archive\&. 
.PP
\fBParameters:\fP
.RS 4
\fIar\fP Archive to load tree from\&. Must be an iarchive, not an oarchive\&. 
.RE
.PP

.SS "~\fBSpillTree\fP ()"

.PP
Deletes this node, deallocating the memory for the children and calling their destructors in turn\&. This will invalidate any pointers or references to any nodes which are children of this one\&. 
.SS "\fBSpillTree\fP ()\fC [protected]\fP"

.PP
A default constructor\&. This is meant to only be used with cereal, which is allowed with the friend declaration below\&. This does not return a valid tree! The method must be protected, so that the serialization shim can work with the default constructor\&. 
.PP
Referenced by SpillTree< MetricType, StatisticType, MatType, HyperplaneType, SplitType >::Center()\&.
.SH "Member Function Documentation"
.PP 
.SS "const \fBBoundType\fP& Bound () const\fC [inline]\fP"

.PP
Return the bound object for this node\&. 
.PP
Definition at line 244 of file spill_tree\&.hpp\&.
.PP
Referenced by SpillTree< MetricType, StatisticType, MatType, HyperplaneType, SplitType >::MaxDistance(), SpillTree< MetricType, StatisticType, MatType, HyperplaneType, SplitType >::MinDistance(), and SpillTree< MetricType, StatisticType, MatType, HyperplaneType, SplitType >::RangeDistance()\&.
.SS "\fBBoundType\fP& Bound ()\fC [inline]\fP"

.PP
Return the bound object for this node\&. 
.PP
Definition at line 246 of file spill_tree\&.hpp\&.
.SS "void Center (arma::vec & center)\fC [inline]\fP"

.PP
Store the center of the bounding region in the given vector\&. 
.PP
Definition at line 438 of file spill_tree\&.hpp\&.
.PP
References SpillTree< MetricType, StatisticType, MatType, HyperplaneType, SplitType >::SpillTree()\&.
.SS "\fBSpillTree\fP& Child (const size_t child) const"

.PP
Return the specified child (0 will be left, 1 will be right)\&. If the index is greater than 1, this will return the right child\&.
.PP
\fBParameters:\fP
.RS 4
\fIchild\fP Index of child to return\&. 
.RE
.PP

.PP
Referenced by SpillTree< MetricType, StatisticType, MatType, HyperplaneType, SplitType >::ParentDistance()\&.
.SS "\fBSpillTree\fP*& ChildPtr (const size_t child)\fC [inline]\fP"

.PP
Definition at line 357 of file spill_tree\&.hpp\&.
.PP
References SpillTree< MetricType, StatisticType, MatType, HyperplaneType, SplitType >::Descendant(), SpillTree< MetricType, StatisticType, MatType, HyperplaneType, SplitType >::NumDescendants(), SpillTree< MetricType, StatisticType, MatType, HyperplaneType, SplitType >::NumPoints(), and SpillTree< MetricType, StatisticType, MatType, HyperplaneType, SplitType >::Point()\&.
.SS "const MatType& Dataset () const\fC [inline]\fP"

.PP
Get the dataset which the tree is built on\&. 
.PP
Definition at line 272 of file spill_tree\&.hpp\&.
.SS "size_t Descendant (const size_t index) const"

.PP
Return the index (with reference to the dataset) of a particular descendant of this node\&. The index should be greater than zero but less than the number of descendants\&.
.PP
\fBParameters:\fP
.RS 4
\fIindex\fP Index of the descendant\&. 
.RE
.PP

.PP
Referenced by SpillTree< MetricType, StatisticType, MatType, HyperplaneType, SplitType >::ChildPtr()\&.
.SS "\fBElemType\fP FurthestDescendantDistance () const"

.PP
Return the furthest possible descendant distance\&. This returns the maximum distance from the centroid to the edge of the bound and not the empirical quantity which is the actual furthest descendant distance\&. So the actual furthest descendant distance may be less than what this method returns (but it will never be greater than this)\&. 
.PP
Referenced by SpillTree< MetricType, StatisticType, MatType, HyperplaneType, SplitType >::Metric()\&.
.SS "\fBElemType\fP FurthestPointDistance () const"

.PP
Return the furthest distance to a point held in this node\&. If this is not a leaf node, then the distance is 0 because the node holds no points\&. 
.PP
Referenced by SpillTree< MetricType, StatisticType, MatType, HyperplaneType, SplitType >::Metric()\&.
.SS "size_t GetFurthestChild (const VecType & point, typename \fBstd::enable_if_t\fP< \fBIsVector\fP< VecType >::value > * = \fC0\fP)"

.PP
Return the index of the furthest child node to the given query point (this is an efficient estimation based on the splitting hyperplane, the node returned is not necessarily the furthest)\&. If this is a leaf node, it will return \fBNumChildren()\fP (invalid index)\&. 
.PP
Referenced by SpillTree< MetricType, StatisticType, MatType, HyperplaneType, SplitType >::Metric()\&.
.SS "size_t GetFurthestChild (const \fBSpillTree\fP< MetricType, StatisticType, MatType, HyperplaneType, SplitType > & queryNode)"

.PP
Return the index of the furthest child node to the given query node (this is an efficient estimation based on the splitting hyperplane, the node returned is not necessarily the furthest)\&. If it can't decide it will return \fBNumChildren()\fP (invalid index)\&. 
.SS "size_t GetNearestChild (const VecType & point, typename \fBstd::enable_if_t\fP< \fBIsVector\fP< VecType >::value > * = \fC0\fP)"

.PP
Return the index of the nearest child node to the given query point (this is an efficient estimation based on the splitting hyperplane, the node returned is not necessarily the nearest)\&. If this is a leaf node, it will return \fBNumChildren()\fP (invalid index)\&. 
.PP
Referenced by SpillTree< MetricType, StatisticType, MatType, HyperplaneType, SplitType >::Metric()\&.
.SS "size_t GetNearestChild (const \fBSpillTree\fP< MetricType, StatisticType, MatType, HyperplaneType, SplitType > & queryNode)"

.PP
Return the index of the nearest child node to the given query node (this is an efficient estimation based on the splitting hyperplane, the node returned is not necessarily the nearest)\&. If it can't decide it will return \fBNumChildren()\fP (invalid index)\&. 
.SS "static bool HasSelfChildren ()\fC [inline]\fP, \fC [static]\fP"

.PP
Returns false: this tree type does not have self children\&. 
.PP
Definition at line 435 of file spill_tree\&.hpp\&.
.SS "const HyperplaneType<MetricType>& \fBHyperplane\fP () const\fC [inline]\fP"

.PP
Get the Hyperplane instance\&. 
.PP
Definition at line 278 of file spill_tree\&.hpp\&.
.SS "bool IsLeaf () const"

.PP
Return whether or not this node is a leaf (true if it has no children)\&. 
.PP
Referenced by SpillTree< MetricType, StatisticType, MatType, HyperplaneType, SplitType >::Stat()\&.
.SS "\fBSpillTree\fP* Left () const\fC [inline]\fP"

.PP
Gets the left child of this node\&. 
.PP
Definition at line 257 of file spill_tree\&.hpp\&.
.SS "\fBSpillTree\fP*& Left ()\fC [inline]\fP"

.PP
Modify the left child of this node\&. 
.PP
Definition at line 259 of file spill_tree\&.hpp\&.
.SS "\fBElemType\fP MaxDistance (const \fBSpillTree\fP< MetricType, StatisticType, MatType, HyperplaneType, SplitType > & other) const\fC [inline]\fP"

.PP
Return the maximum distance to another node\&. 
.PP
Definition at line 396 of file spill_tree\&.hpp\&.
.PP
References SpillTree< MetricType, StatisticType, MatType, HyperplaneType, SplitType >::Bound()\&.
.SS "\fBElemType\fP MaxDistance (const VecType & point, typename \fBstd::enable_if_t\fP< \fBIsVector\fP< VecType >::value > * = \fC0\fP) const\fC [inline]\fP"

.PP
Return the maximum distance to another point\&. 
.PP
Definition at line 418 of file spill_tree\&.hpp\&.
.SS "MetricType Metric () const\fC [inline]\fP"

.PP
Get the metric that the tree uses\&. 
.PP
Definition at line 281 of file spill_tree\&.hpp\&.
.PP
References SpillTree< MetricType, StatisticType, MatType, HyperplaneType, SplitType >::FurthestDescendantDistance(), SpillTree< MetricType, StatisticType, MatType, HyperplaneType, SplitType >::FurthestPointDistance(), SpillTree< MetricType, StatisticType, MatType, HyperplaneType, SplitType >::GetFurthestChild(), SpillTree< MetricType, StatisticType, MatType, HyperplaneType, SplitType >::GetNearestChild(), SpillTree< MetricType, StatisticType, MatType, HyperplaneType, SplitType >::MinimumBoundDistance(), and SpillTree< MetricType, StatisticType, MatType, HyperplaneType, SplitType >::NumChildren()\&.
.SS "\fBElemType\fP MinDistance (const \fBSpillTree\fP< MetricType, StatisticType, MatType, HyperplaneType, SplitType > & other) const\fC [inline]\fP"

.PP
Return the minimum distance to another node\&. 
.PP
Definition at line 390 of file spill_tree\&.hpp\&.
.PP
References SpillTree< MetricType, StatisticType, MatType, HyperplaneType, SplitType >::Bound()\&.
.SS "\fBElemType\fP MinDistance (const VecType & point, typename \fBstd::enable_if_t\fP< \fBIsVector\fP< VecType >::value > * = \fC0\fP) const\fC [inline]\fP"

.PP
Return the minimum distance to another point\&. 
.PP
Definition at line 409 of file spill_tree\&.hpp\&.
.SS "\fBElemType\fP MinimumBoundDistance () const"

.PP
Return the minimum distance from the center of the node to any bound edge\&. 
.PP
Referenced by SpillTree< MetricType, StatisticType, MatType, HyperplaneType, SplitType >::Metric()\&.
.SS "size_t NumChildren () const"

.PP
Return the number of children in this node\&. 
.PP
Referenced by SpillTree< MetricType, StatisticType, MatType, HyperplaneType, SplitType >::Metric()\&.
.SS "size_t NumDescendants () const"

.PP
Return the number of descendants of this node\&. For a non-leaf spill tree, this is the number of points at the descendant leaves\&. For a leaf, this is the number of points in the leaf\&. 
.PP
Referenced by SpillTree< MetricType, StatisticType, MatType, HyperplaneType, SplitType >::ChildPtr()\&.
.SS "size_t NumPoints () const"

.PP
Return the number of points in this node (0 if not a leaf)\&. 
.PP
Referenced by SpillTree< MetricType, StatisticType, MatType, HyperplaneType, SplitType >::ChildPtr()\&.
.SS "\fBSpillTree\fP& operator= (const \fBSpillTree\fP< MetricType, StatisticType, MatType, HyperplaneType, SplitType > & other)"

.PP
Copy the given Spill Tree\&. 
.PP
\fBParameters:\fP
.RS 4
\fIother\fP The tree to be copied\&. 
.RE
.PP

.SS "\fBSpillTree\fP& operator= (\fBSpillTree\fP< MetricType, StatisticType, MatType, HyperplaneType, SplitType > && other)"

.PP
Take ownership of the given Spill Tree\&. 
.PP
\fBParameters:\fP
.RS 4
\fIother\fP The tree to take ownership of\&. 
.RE
.PP

.SS "bool Overlap () const\fC [inline]\fP"

.PP
Distinguish overlapping nodes from non-overlapping nodes\&. 
.PP
Definition at line 275 of file spill_tree\&.hpp\&.
.SS "\fBSpillTree\fP* Parent () const\fC [inline]\fP"

.PP
Gets the parent of this node\&. 
.PP
Definition at line 267 of file spill_tree\&.hpp\&.
.SS "\fBSpillTree\fP*& Parent ()\fC [inline]\fP"

.PP
Modify the parent of this node\&. 
.PP
Definition at line 269 of file spill_tree\&.hpp\&.
.SS "\fBElemType\fP ParentDistance () const\fC [inline]\fP"

.PP
Return the distance from the center of this node to the center of the parent node\&. 
.PP
Definition at line 344 of file spill_tree\&.hpp\&.
.SS "\fBElemType\fP& ParentDistance ()\fC [inline]\fP"

.PP
Modify the distance from the center of this node to the center of the parent node\&. 
.PP
Definition at line 347 of file spill_tree\&.hpp\&.
.PP
References SpillTree< MetricType, StatisticType, MatType, HyperplaneType, SplitType >::Child()\&.
.SS "size_t Point (const size_t index) const"

.PP
Return the index (with reference to the dataset) of a particular point in this node\&. This will happily return invalid indices if the given index is greater than the number of points in this node (obtained with \fBNumPoints()\fP) -- be careful\&.
.PP
\fBParameters:\fP
.RS 4
\fIindex\fP Index of point for which a dataset index is wanted\&. 
.RE
.PP

.PP
Referenced by SpillTree< MetricType, StatisticType, MatType, HyperplaneType, SplitType >::ChildPtr()\&.
.SS "math::RangeType<\fBElemType\fP> RangeDistance (const \fBSpillTree\fP< MetricType, StatisticType, MatType, HyperplaneType, SplitType > & other) const\fC [inline]\fP"

.PP
Return the minimum and maximum distance to another node\&. 
.PP
Definition at line 402 of file spill_tree\&.hpp\&.
.PP
References SpillTree< MetricType, StatisticType, MatType, HyperplaneType, SplitType >::Bound()\&.
.SS "math::RangeType<\fBElemType\fP> RangeDistance (const VecType & point, typename \fBstd::enable_if_t\fP< \fBIsVector\fP< VecType >::value > * = \fC0\fP) const\fC [inline]\fP"

.PP
Return the minimum and maximum distance to another point\&. 
.PP
Definition at line 428 of file spill_tree\&.hpp\&.
.SS "\fBSpillTree\fP* Right () const\fC [inline]\fP"

.PP
Gets the right child of this node\&. 
.PP
Definition at line 262 of file spill_tree\&.hpp\&.
.SS "\fBSpillTree\fP*& Right ()\fC [inline]\fP"

.PP
Modify the right child of this node\&. 
.PP
Definition at line 264 of file spill_tree\&.hpp\&.
.SS "void serialize (Archive & ar, const uint32_t version)"

.PP
Serialize the tree\&. 
.SS "const StatisticType& Stat () const\fC [inline]\fP"

.PP
Return the statistic object for this node\&. 
.PP
Definition at line 249 of file spill_tree\&.hpp\&.
.SS "StatisticType& Stat ()\fC [inline]\fP"

.PP
Return the statistic object for this node\&. 
.PP
Definition at line 251 of file spill_tree\&.hpp\&.
.PP
References SpillTree< MetricType, StatisticType, MatType, HyperplaneType, SplitType >::IsLeaf()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for mlpack from the source code\&.
