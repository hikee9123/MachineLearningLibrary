.TH "LocalCoordinateCoding" 3 "Thu Jun 24 2021" "Version 3.4.2" "mlpack" \" -*- nroff -*-
.ad l
.nh
.SH NAME
LocalCoordinateCoding \- An implementation of Local Coordinate Coding (LCC) that codes data which approximately lives on a manifold using a variation of l1-norm regularized sparse coding; in LCC, the penalty on the absolute value of each point's coefficient for each atom is weighted by the squared distance of that point to that atom\&.  

.SH SYNOPSIS
.br
.PP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "template<typename DictionaryInitializer  = sparse_coding::DataDependentRandomInitializer> \fBLocalCoordinateCoding\fP (const arma::mat &data, const size_t atoms, const double lambda, const size_t maxIterations=0, const double tolerance=0\&.01, const DictionaryInitializer &initializer=DictionaryInitializer())"
.br
.RI "Set the parameters to \fBLocalCoordinateCoding\fP, and train the dictionary\&. "
.ti -1c
.RI "\fBLocalCoordinateCoding\fP (const size_t atoms=0, const double lambda=0\&.0, const size_t maxIterations=0, const double tolerance=0\&.01)"
.br
.RI "Set the parameters to \fBLocalCoordinateCoding\fP\&. "
.ti -1c
.RI "size_t \fBAtoms\fP () const"
.br
.RI "Get the number of atoms\&. "
.ti -1c
.RI "size_t & \fBAtoms\fP ()"
.br
.RI "Modify the number of atoms\&. "
.ti -1c
.RI "const arma::mat & \fBDictionary\fP () const"
.br
.RI "Accessor for dictionary\&. "
.ti -1c
.RI "arma::mat & \fBDictionary\fP ()"
.br
.RI "Mutator for dictionary\&. "
.ti -1c
.RI "void \fBEncode\fP (const arma::mat &data, arma::mat &codes)"
.br
.RI "Code each point via distance-weighted LARS\&. "
.ti -1c
.RI "double \fBLambda\fP () const"
.br
.RI "Get the L1 regularization parameter\&. "
.ti -1c
.RI "double & \fBLambda\fP ()"
.br
.RI "Modify the L1 regularization parameter\&. "
.ti -1c
.RI "size_t \fBMaxIterations\fP () const"
.br
.RI "Get the maximum number of iterations\&. "
.ti -1c
.RI "size_t & \fBMaxIterations\fP ()"
.br
.RI "Modify the maximum number of iterations\&. "
.ti -1c
.RI "double \fBObjective\fP (const arma::mat &data, const arma::mat &codes, const arma::uvec &adjacencies) const"
.br
.RI "Compute objective function given the list of adjacencies\&. "
.ti -1c
.RI "void \fBOptimizeDictionary\fP (const arma::mat &data, const arma::mat &codes, const arma::uvec &adjacencies)"
.br
.RI "Learn dictionary by solving linear system\&. "
.ti -1c
.RI "template<typename Archive > void \fBserialize\fP (Archive &ar, const uint32_t)"
.br
.RI "Serialize the model\&. "
.ti -1c
.RI "double \fBTolerance\fP () const"
.br
.RI "Get the objective tolerance\&. "
.ti -1c
.RI "double & \fBTolerance\fP ()"
.br
.RI "Modify the objective tolerance\&. "
.ti -1c
.RI "template<typename DictionaryInitializer  = sparse_coding::DataDependentRandomInitializer> double \fBTrain\fP (const arma::mat &data, const DictionaryInitializer &initializer=DictionaryInitializer())"
.br
.RI "Run local coordinate coding\&. "
.in -1c
.SH "Detailed Description"
.PP 
An implementation of Local Coordinate Coding (LCC) that codes data which approximately lives on a manifold using a variation of l1-norm regularized sparse coding; in LCC, the penalty on the absolute value of each point's coefficient for each atom is weighted by the squared distance of that point to that atom\&. 

Let d be the number of dimensions in the original space, m the number of training points, and k the number of atoms in the dictionary (the dimension of the learned feature space)\&. The training data X is a d-by-m matrix where each column is a point and each row is a dimension\&. The dictionary D is a d-by-k matrix, and the sparse codes matrix Z is a k-by-m matrix\&. This program seeks to minimize the objective: min_{D,Z} ||X - D Z||_{Fro}^2
.IP "\(bu" 2
lambda sum_{i=1}^m sum_{j=1}^k dist(X_i,D_j)^2 Z_i^j where lambda > 0\&.
.PP
.PP
This problem is solved by an algorithm that alternates between a dictionary learning step and a sparse coding step\&. The dictionary learning step updates the dictionary D by solving a linear system (note that the objective is a positive definite quadratic program)\&. The sparse coding step involves solving a large number of weighted l1-norm regularized linear regression problems problems; this can be done efficiently using LARS, an algorithm that can solve the LASSO (paper below)\&.
.PP
The papers are listed below\&.
.PP
.PP
.nf
@incollection{NIPS2009_0719,
  title = {Nonlinear Learning using Local Coordinate Coding},
  author = {Kai Yu and Tong Zhang and Yihong Gong},
  booktitle = {Advances in Neural Information Processing Systems 22},
  editor = {Y\&. Bengio and D\&. Schuurmans and J\&. Lafferty and C\&. K\&. I\&. Williams
      and A\&. Culotta},
  pages = {2223--2231},
  year = {2009}
}
.fi
.PP
.PP
.PP
.nf
@article{efron2004least,
  title={Least angle regression},
  author={Efron, B\&. and Hastie, T\&. and Johnstone, I\&. and Tibshirani, R\&.},
  journal={The Annals of statistics},
  volume={32},
  number={2},
  pages={407--499},
  year={2004},
  publisher={Institute of Mathematical Statistics}
}
.fi
.PP
 
.PP
Definition at line 79 of file lcc\&.hpp\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "\fBLocalCoordinateCoding\fP (const arma::mat & data, const size_t atoms, const double lambda, const size_t maxIterations = \fC0\fP, const double tolerance = \fC0\&.01\fP, const DictionaryInitializer & initializer = \fCDictionaryInitializer()\fP)"

.PP
Set the parameters to \fBLocalCoordinateCoding\fP, and train the dictionary\&. This constructor will also initialize the dictionary using the given DictionaryInitializer before training\&.
.PP
If you want to initialize the dictionary to a custom matrix, consider either writing your own DictionaryInitializer class (with void Initialize(const arma::mat& data, arma::mat& dictionary) function), or call the constructor that does not take a data matrix, then call \fBDictionary()\fP to set the dictionary matrix to a matrix of your choosing, and then call \fBTrain()\fP with \fBsparse_coding::NothingInitializer\fP (i\&.e\&. Train<sparse_coding::NothingInitializer>(data))\&.
.PP
\fBParameters:\fP
.RS 4
\fIdata\fP Data matrix\&. 
.br
\fIatoms\fP Number of atoms in dictionary\&. 
.br
\fIlambda\fP Regularization parameter for weighted l1-norm penalty\&. 
.br
\fImaxIterations\fP Maximum number of iterations for training (0 runs until convergence)\&. 
.br
\fItolerance\fP Tolerance for the objective function\&. 
.br
\fIinitializer\fP Intializer to use\&. 
.RE
.PP

.SS "\fBLocalCoordinateCoding\fP (const size_t atoms = \fC0\fP, const double lambda = \fC0\&.0\fP, const size_t maxIterations = \fC0\fP, const double tolerance = \fC0\&.01\fP)"

.PP
Set the parameters to \fBLocalCoordinateCoding\fP\&. This constructor will not train the model, and a subsequent call to \fBTrain()\fP will be required before the model can encode points with \fBEncode()\fP\&. The default values for atoms and lambda should be changed if you intend to train the model!
.PP
\fBParameters:\fP
.RS 4
\fIatoms\fP Number of atoms in dictionary\&. 
.br
\fIlambda\fP Regularization parameter for weighted l1-norm penalty\&. 
.br
\fImaxIterations\fP Maximum number of iterations for training (0 runs until convergence)\&. 
.br
\fItolerance\fP Tolerance for the objective function\&. 
.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "size_t Atoms () const\fC [inline]\fP"

.PP
Get the number of atoms\&. 
.PP
Definition at line 182 of file lcc\&.hpp\&.
.SS "size_t& Atoms ()\fC [inline]\fP"

.PP
Modify the number of atoms\&. 
.PP
Definition at line 184 of file lcc\&.hpp\&.
.SS "const arma::mat& Dictionary () const\fC [inline]\fP"

.PP
Accessor for dictionary\&. 
.PP
Definition at line 187 of file lcc\&.hpp\&.
.SS "arma::mat& Dictionary ()\fC [inline]\fP"

.PP
Mutator for dictionary\&. 
.PP
Definition at line 189 of file lcc\&.hpp\&.
.SS "void Encode (const arma::mat & data, arma::mat & codes)"

.PP
Code each point via distance-weighted LARS\&. 
.PP
\fBParameters:\fP
.RS 4
\fIdata\fP Matrix containing points to encode\&. 
.br
\fIcodes\fP Output matrix to store codes in\&. 
.RE
.PP

.SS "double Lambda () const\fC [inline]\fP"

.PP
Get the L1 regularization parameter\&. 
.PP
Definition at line 192 of file lcc\&.hpp\&.
.SS "double& Lambda ()\fC [inline]\fP"

.PP
Modify the L1 regularization parameter\&. 
.PP
Definition at line 194 of file lcc\&.hpp\&.
.SS "size_t MaxIterations () const\fC [inline]\fP"

.PP
Get the maximum number of iterations\&. 
.PP
Definition at line 197 of file lcc\&.hpp\&.
.SS "size_t& MaxIterations ()\fC [inline]\fP"

.PP
Modify the maximum number of iterations\&. 
.PP
Definition at line 199 of file lcc\&.hpp\&.
.SS "double Objective (const arma::mat & data, const arma::mat & codes, const arma::uvec & adjacencies) const"

.PP
Compute objective function given the list of adjacencies\&. 
.PP
\fBParameters:\fP
.RS 4
\fIdata\fP Matrix containing points to encode\&. 
.br
\fIcodes\fP Output matrix to store codes in\&. 
.br
\fIadjacencies\fP Indices of entries (unrolled column by column) of the coding matrix Z that are non-zero (the adjacency matrix for the bipartite graph of points and atoms) 
.RE
.PP

.SS "void OptimizeDictionary (const arma::mat & data, const arma::mat & codes, const arma::uvec & adjacencies)"

.PP
Learn dictionary by solving linear system\&. 
.PP
\fBParameters:\fP
.RS 4
\fIdata\fP Matrix containing points to encode\&. 
.br
\fIcodes\fP Output matrix to store codes in\&. 
.br
\fIadjacencies\fP Indices of entries (unrolled column by column) of the coding matrix Z that are non-zero (the adjacency matrix for the bipartite graph of points and atoms) 
.RE
.PP

.SS "void serialize (Archive & ar, const uint32_t)"

.PP
Serialize the model\&. 
.PP
Referenced by LocalCoordinateCoding::Tolerance()\&.
.SS "double Tolerance () const\fC [inline]\fP"

.PP
Get the objective tolerance\&. 
.PP
Definition at line 202 of file lcc\&.hpp\&.
.SS "double& Tolerance ()\fC [inline]\fP"

.PP
Modify the objective tolerance\&. 
.PP
Definition at line 204 of file lcc\&.hpp\&.
.PP
References LocalCoordinateCoding::serialize()\&.
.SS "double Train (const arma::mat & data, const DictionaryInitializer & initializer = \fCDictionaryInitializer()\fP)"

.PP
Run local coordinate coding\&. 
.PP
\fBParameters:\fP
.RS 4
\fIdata\fP Data matrix\&. 
.br
\fIinitializer\fP Intializer to use\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
The final objective value\&. 
.RE
.PP


.SH "Author"
.PP 
Generated automatically by Doxygen for mlpack from the source code\&.
