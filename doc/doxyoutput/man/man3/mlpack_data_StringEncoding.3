.TH "StringEncoding< EncodingPolicyType, DictionaryType >" 3 "Sun Aug 22 2021" "Version 3.4.2" "mlpack" \" -*- nroff -*-
.ad l
.nh
.SH NAME
StringEncoding< EncodingPolicyType, DictionaryType > \- The class translates a set of strings into numbers using various encoding algorithms\&.  

.SH SYNOPSIS
.br
.PP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "template<typename \&.\&.\&. ArgTypes> \fBStringEncoding\fP (ArgTypes &&\&.\&.\&. args)"
.br
.RI "Pass the given arguments to the policy constructor and create the \fBStringEncoding\fP object using the policy\&. "
.ti -1c
.RI "\fBStringEncoding\fP (EncodingPolicyType encodingPolicy)"
.br
.RI "Construct the class from the given encoding policy\&. "
.ti -1c
.RI "\fBStringEncoding\fP (\fBStringEncoding\fP &)"
.br
.RI "A variant of the copy constructor for non-constant objects\&. "
.ti -1c
.RI "\fBStringEncoding\fP (const \fBStringEncoding\fP &)"
.br
.RI "Default copy-constructor\&. "
.ti -1c
.RI "\fBStringEncoding\fP (\fBStringEncoding\fP &&)"
.br
.RI "Default move-constructor\&. "
.ti -1c
.RI "void \fBClear\fP ()"
.br
.RI "Clear the dictionary\&. "
.ti -1c
.RI "template<typename TokenizerType > void \fBCreateMap\fP (const std::string &input, const TokenizerType &tokenizer)"
.br
.RI "Initialize the dictionary using the given corpus\&. "
.ti -1c
.RI "const DictionaryType & \fBDictionary\fP () const"
.br
.RI "Return the dictionary\&. "
.ti -1c
.RI "DictionaryType & \fBDictionary\fP ()"
.br
.RI "Modify the dictionary\&. "
.ti -1c
.RI "template<typename OutputType , typename TokenizerType > void \fBEncode\fP (const std::vector< std::string > &input, OutputType &output, const TokenizerType &tokenizer)"
.br
.RI "Encode the given text and write the result to the given output\&. "
.ti -1c
.RI "const EncodingPolicyType & \fBEncodingPolicy\fP () const"
.br
.RI "Return the encoding policy object\&. "
.ti -1c
.RI "EncodingPolicyType & \fBEncodingPolicy\fP ()"
.br
.RI "Modify the encoding policy object\&. "
.ti -1c
.RI "\fBStringEncoding\fP & \fBoperator=\fP (const \fBStringEncoding\fP &)=default"
.br
.RI "Default copy assignment operator\&. "
.ti -1c
.RI "\fBStringEncoding\fP & \fBoperator=\fP (\fBStringEncoding\fP &&)=default"
.br
.RI "Default move assignment operator\&. "
.ti -1c
.RI "template<typename Archive > void \fBserialize\fP (Archive &ar, const uint32_t)"
.br
.RI "Serialize the class to the given archive\&. "
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename EncodingPolicyType, typename DictionaryType>
.br
class mlpack::data::StringEncoding< EncodingPolicyType, DictionaryType >"
The class translates a set of strings into numbers using various encoding algorithms\&. 

The encoder writes data either in the column-major order or in the row-major order depending on the output data type\&.
.PP
\fBTemplate Parameters:\fP
.RS 4
\fIEncodingPolicyType\fP Type of the encoding algorithm itself\&. 
.br
\fIDictionaryType\fP Type of the dictionary\&. 
.RE
.PP

.PP
Definition at line 35 of file string_encoding\&.hpp\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "\fBStringEncoding\fP (ArgTypes &&\&.\&.\&. args)"

.PP
Pass the given arguments to the policy constructor and create the \fBStringEncoding\fP object using the policy\&. 
.SS "\fBStringEncoding\fP (EncodingPolicyType encodingPolicy)"

.PP
Construct the class from the given encoding policy\&. 
.PP
\fBParameters:\fP
.RS 4
\fIencodingPolicy\fP The given encoding policy\&. 
.RE
.PP

.SS "\fBStringEncoding\fP (\fBStringEncoding\fP< EncodingPolicyType, DictionaryType > &)"

.PP
A variant of the copy constructor for non-constant objects\&. 
.SS "\fBStringEncoding\fP (const \fBStringEncoding\fP< EncodingPolicyType, DictionaryType > &)"

.PP
Default copy-constructor\&. 
.SS "\fBStringEncoding\fP (\fBStringEncoding\fP< EncodingPolicyType, DictionaryType > &&)"

.PP
Default move-constructor\&. 
.SH "Member Function Documentation"
.PP 
.SS "void Clear ()"

.PP
Clear the dictionary\&. 
.SS "void CreateMap (const std::string & input, const TokenizerType & tokenizer)"

.PP
Initialize the dictionary using the given corpus\&. 
.PP
\fBTemplate Parameters:\fP
.RS 4
\fITokenizerType\fP Type of the tokenizer\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIinput\fP Corpus of text to encode\&. 
.br
\fItokenizer\fP The tokenizer object\&.
.RE
.PP
The tokenization algorithm has to be an object with two public methods:
.IP "1." 4
operator() which accepts a reference to boost::string_view, extracts the next token from the given view, removes the prefix containing the extracted token and returns the token;
.IP "2." 4
IsTokenEmpty() that accepts a token and returns true if the given token is empty\&. 
.PP

.SS "const DictionaryType& Dictionary () const\fC [inline]\fP"

.PP
Return the dictionary\&. 
.PP
Definition at line 124 of file string_encoding\&.hpp\&.
.SS "DictionaryType& Dictionary ()\fC [inline]\fP"

.PP
Modify the dictionary\&. 
.PP
Definition at line 126 of file string_encoding\&.hpp\&.
.SS "void Encode (const std::vector< std::string > & input, OutputType & output, const TokenizerType & tokenizer)"

.PP
Encode the given text and write the result to the given output\&. The encoder writes data in the column-major order or in the row-major order depending on the output data type\&.
.PP
If the output type is either arma::mat or arma::sp_mat then the function writes it in the column-major order\&. If the output type is 2D std::vector then the function writes it in the row major order\&.
.PP
\fBTemplate Parameters:\fP
.RS 4
\fIOutputType\fP Type of the output container\&. The function supports the following types: arma::mat, arma::sp_mat, std::vector<std::vector<>>\&. 
.br
\fITokenizerType\fP Type of the tokenizer\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIinput\fP Corpus of text to encode\&. 
.br
\fIoutput\fP Output container to store the result\&. 
.br
\fItokenizer\fP The tokenizer object\&.
.RE
.PP
The tokenization algorithm has to be an object with two public methods:
.IP "1." 4
operator() which accepts a reference to boost::string_view, extracts the next token from the given view, removes the prefix containing the extracted token and returns the token;
.IP "2." 4
IsTokenEmpty() that accepts a token and returns true if the given token is empty\&. 
.PP

.SS "const EncodingPolicyType& EncodingPolicy () const\fC [inline]\fP"

.PP
Return the encoding policy object\&. 
.PP
Definition at line 129 of file string_encoding\&.hpp\&.
.SS "EncodingPolicyType& EncodingPolicy ()\fC [inline]\fP"

.PP
Modify the encoding policy object\&. 
.PP
Definition at line 131 of file string_encoding\&.hpp\&.
.PP
References StringEncoding< EncodingPolicyType, DictionaryType >::serialize()\&.
.SS "\fBStringEncoding\fP& operator= (const \fBStringEncoding\fP< EncodingPolicyType, DictionaryType > &)\fC [default]\fP"

.PP
Default copy assignment operator\&. 
.SS "\fBStringEncoding\fP& operator= (\fBStringEncoding\fP< EncodingPolicyType, DictionaryType > &&)\fC [default]\fP"

.PP
Default move assignment operator\&. 
.SS "void serialize (Archive & ar, const uint32_t)"

.PP
Serialize the class to the given archive\&. 
.PP
Referenced by StringEncoding< EncodingPolicyType, DictionaryType >::EncodingPolicy()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for mlpack from the source code\&.
