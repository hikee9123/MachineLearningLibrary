.TH "timer" 3 "Sun Aug 22 2021" "Version 3.4.2" "mlpack" \" -*- nroff -*-
.ad l
.nh
.SH NAME
timermlpack Timers 
 \- 
.SH "Introduction"
.PP
mlpack provides a simple timer interface for the timing of machine learning methods\&. The results of any timers used during the program are displayed at output by any command-line binding, when --verbose is given:
.PP
.PP
.nf
$ mlpack_knn -r dataset\&.csv -n neighbors_out\&.csv -d distances_out\&.csv -k 5 -v
<\&.\&.\&.>
[INFO ] Program timers:
[INFO ]   computing_neighbors: 0\&.010650s
[INFO ]   loading_data: 0\&.002567s
[INFO ]   saving_data: 0\&.001115s
[INFO ]   total_time: 0\&.149816s
[INFO ]   tree_building: 0\&.000534s
.fi
.PP
.SH "Timer API"
.PP
The \fBmlpack::Timer\fP class provides three simple methods:
.PP
.PP
.nf
void Timer::Start(const char* name);
void Timer::Stop(const char* name);
timeval Timer::Get(const char* name);
.fi
.PP
.PP
Each timer is given a name, and is referenced by that name\&. You can call \fCTimer::Start()\fP and \fCTimer::Stop()\fP multiple times for a particular timer name, and the result will be the sum of the runs of the timer\&. Note that \fCTimer::Stop()\fP must be called before \fCTimer::Start()\fP is called again, otherwise a std::runtime_error exception will be thrown\&.
.PP
A \fC'total_time'\fP timer is run by default for each mlpack program\&.
.SH "Timer Example"
.PP
Below is a very simple example of timer usage in code\&.
.PP
.PP
.nf
#include <mlpack/core\&.hpp>
#include <mlpack/core/util/io\&.hpp>
#define BINDING_TYPE BINDING_TYPE_CLI
#include <mlpack/core/util/mlpack_main\&.hpp>

using namespace mlpack;

void mlpackMain()
{
  // Start a timer\&.
  Timer::Start("some_timer");

  // Do some things\&.
  DoSomeStuff();

  // Stop the timer\&.
  Timer::Stop("some_timer");
}
.fi
.PP
.PP
If the --verbose flag was given to this executable, the time that \fC'some_timer'\fP ran for would be printed at the end of the program's output\&. 
