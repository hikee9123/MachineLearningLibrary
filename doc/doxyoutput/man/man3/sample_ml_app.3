.TH "sample_ml_app" 3 "Sun Aug 22 2021" "Version 3.4.2" "mlpack" \" -*- nroff -*-
.ad l
.nh
.SH NAME
sample_ml_appSample C++ ML App for Windows 
 \- 
.SH "Introduction"
.PP
This tutorial will help you create a sample machine learning app using mlpack/C++\&. Although this app does not cover all the mlpack capabilities, it will walkthrough several APIs to understand how everything connects\&. This Windows sample app is created using Visual Studio, but you can easily adapt it to a different platform by following the provided source code\&.
.PP
\fBNote:\fP
.RS 4
Before starting, make sure you have built mlpack for Windows following this \fBWindows guide\fP
.RE
.PP
.SH "Creating the VS project"
.PP
.IP "\(bu" 2
Open Visual Studio and create a new project (Windows Console Application)
.IP "\(bu" 2
For this sample, the project is named “sample-ml-app”
.PP
.SH "Project Configuration"
.PP
There are different ways in which you can configure your project to link with dependencies\&. This configuration is for x64 Debug Mode\&. If you need Release Mode, please change the paths accordingly (assuming you have built mlpack and dependencies in Release Mode)\&.
.PP
.IP "\(bu" 2
Right click on the project and select Properties, select the x64 Debug profile
.IP "\(bu" 2
Under C/C++ > General > Additional Include Directories add: 
.PP
.nf
- C:\boost\boost_1_71_0\lib\native\include
- C:\mlpack\armadillo-9\&.800\&.3\include
- C:\mlpack\mlpack-3\&.4\&.2\build\include

.fi
.PP

.IP "\(bu" 2
Under Linker > Input > Additional Dependencies add: 
.PP
.nf
- C:\mlpack\mlpack-3\&.4\&.2\build\Debug\mlpack\&.lib

.fi
.PP

.IP "\(bu" 2
Under Build Events > Post-Build Event > Command Line add: 
.PP
.nf
- xcopy /y "C:\mlpack\mlpack-3\&.4\&.2\build\Debug\mlpack\&.dll" $(OutDir)
- xcopy /y "C:\mlpack\mlpack-3\&.4\&.2\packages\OpenBLAS\&.0\&.2\&.14\&.1\lib\native\bin\x64\*\&.dll" $(OutDir)

.fi
.PP

.PP
.PP
\fBNote:\fP
.RS 4
Recent versions of Visual Studio set 'Conformance Mode' enabled by default\&. This causes some issues with the armadillo library\&. If you encounter this issue, disable 'Conformance Mode' under C/C++ > Language\&.
.RE
.PP
.SH "The app goal"
.PP
This app aims to exercise an end-to-end machine learning workflow\&. We will cover:
.PP
.IP "\(bu" 2
Loading and preparing a dataset
.IP "\(bu" 2
Training (using Random Forest as example)
.IP "\(bu" 2
Computing the training accuracy
.IP "\(bu" 2
Cross-Validation using K-Fold
.IP "\(bu" 2
Metrics gathering (accuracy, precision, recall, F1)
.IP "\(bu" 2
Saving the trained model to disk
.IP "\(bu" 2
Loading the model
.IP "\(bu" 2
Classifying a new sample
.PP
.SH "Headers and namespaces"
.PP
For this app, we will need to include the following headers (i\&.e\&. add into stdafx\&.h):
.PP
.PP
.nf
#include "mlpack/core\&.hpp"
#include "mlpack/methods/random_forest/random_forest\&.hpp"
#include "mlpack/methods/decision_tree/random_dimension_select\&.hpp"
#include "mlpack/core/cv/k_fold_cv\&.hpp"
#include "mlpack/core/cv/metrics/accuracy\&.hpp"
#include "mlpack/core/cv/metrics/precision\&.hpp"
#include "mlpack/core/cv/metrics/recall\&.hpp"
#include "mlpack/core/cv/metrics/F1\&.hpp"
.fi
.PP
.PP
Also, we will use the following namespaces:
.PP
.PP
.nf
using namespace arma;
using namespace mlpack;
using namespace mlpack::tree;
using namespace mlpack::cv;
.fi
.PP
.SH "Loading the dataset"
.PP
First step is about loading the dataset\&. Different dataset file formats are supported, but here we load a CSV dataset, and we assume the labels don't require normalization\&.
.PP
\fBNote:\fP
.RS 4
Make sure you update the path to your dataset file\&. For this sample, you can simply copy 'mlpack/tests/data/german\&.csv' and paste into a new 'data' folder in your project directory\&.
.RE
.PP
.PP
.nf
mat dataset;
bool loaded = mlpack::data::Load("data/german\&.csv", dataset);
if (!loaded)
  return -1;
.fi
.PP
.PP
Then we need to extract the labels from the last dimension of the dataset and remove the labels from the training set:
.PP
.PP
.nf
Row<size_t> labels;
labels = conv_to<Row<size_t>>::from(dataset\&.row(dataset\&.n_rows - 1));
dataset\&.shed_row(dataset\&.n_rows - 1);
.fi
.PP
.PP
We now have our dataset ready for training\&.
.SH "Training"
.PP
This app will use a Random Forest classifier\&. At first we define the classifier parameters and then we create the classifier to train it\&.
.PP
.PP
.nf
const size_t numClasses = 2;
const size_t minimumLeafSize = 5;
const size_t numTrees = 10;

RandomForest<GiniGain, RandomDimensionSelect> rf;

rf = RandomForest<GiniGain, RandomDimensionSelect>(dataset, labels,
    numClasses, numTrees, minimumLeafSize);
.fi
.PP
.PP
Now that the training is completed, we quickly compute the training accuracy:
.PP
.PP
.nf
Row<size_t> predictions;
rf\&.Classify(dataset, predictions);
const size_t correct = arma::accu(predictions == labels);
cout << "\nTraining Accuracy: " << (double(correct) / double(labels\&.n_elem));
.fi
.PP
.SH "Cross-Validating"
.PP
Instead of training the Random Forest directly, we could also use K-fold cross-validation for training, which will give us a measure of performance on a held-out test set\&. This can give us a better estimate of how the model will perform when given new data\&. We also define which metric to use in order to assess the quality of the trained model\&.
.PP
.PP
.nf
const size_t k = 10;
KFoldCV<RandomForest<GiniGain, RandomDimensionSelect>, Accuracy> cv(k, 
    dataset, labels, numClasses);
double cvAcc = cv\&.Evaluate(numTrees, minimumLeafSize);
cout << "\nKFoldCV Accuracy: " << cvAcc;
.fi
.PP
.PP
To compute other relevant metrics, such as Precision, Recall and F1:
.PP
.PP
.nf
double cvPrecision = Precision<Binary>::Evaluate(rf, dataset, labels);
cout << "\nPrecision: " << cvPrecision;

double cvRecall = Recall<Binary>::Evaluate(rf, dataset, labels);
cout << "\nRecall: " << cvRecall;

double cvF1 = F1<Binary>::Evaluate(rf, dataset, labels);
cout << "\nF1: " << cvF1;
.fi
.PP
.SH "Saving the model"
.PP
Now that our model is trained and validated, we save it to a file so we can use it later\&. Here we save the model that was trained using the entire dataset\&. Alternatively, we could extract the model from the cross-validation stage by using \fCcv\&.Model()\fP 
.PP
.PP
.nf
mlpack::data::Save("mymodel\&.xml", "model", rf, false);
.fi
.PP
.PP
We can also save the model in \fCbin\fP format ('mymodel\&.bin') which would result in a smaller file\&.
.SH "Loading the model"
.PP
In a real-life application, you may want to load a previously trained model to classify new samples\&. We load the model from a file using:
.PP
.PP
.nf
mlpack::data::Load("mymodel\&.xml", "model", rf);
.fi
.PP
.SH "Classifying a new sample"
.PP
Finally, the ultimate goal is to classify a new sample using the previously trained model\&. Since the Random Forest classifier provides both predictions and probabilities, we obtain both\&.
.PP
.PP
.nf
// Create a test sample containing only one point\&.  Because Armadillo is
// column-major, this matrix has one column (one point) and the number of rows
// is equal to the dimensionality of the point (23)\&.
mat sample("2; 12; 2; 13; 1; 2; 2; 1; 3; 24; 3; 1; 1; 1; 1; 1; 0; 1; 0; 1;"
    " 0; 0; 0");
mat probabilities;
rf\&.Classify(sample, predictions, probabilities);
u64 result = predictions\&.at(0);
cout << "\nClassification result: " << result << " , Probabilities: " <<
    probabilities\&.at(0) << "/" << probabilities\&.at(1);
.fi
.PP
.SH "Final thoughts"
.PP
Building real-life applications and services using machine learning can be challenging\&. Hopefully, this tutorial provides a good starting point that covers the basic workflow you may need to follow while developing it\&. You can take a look at the entire source code in the provided sample project located here: 'doc/examples/sample-ml-app'\&. 
