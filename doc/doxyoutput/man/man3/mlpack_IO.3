.TH "IO" 3 "Thu Jun 24 2021" "Version 3.4.2" "mlpack" \" -*- nroff -*-
.ad l
.nh
.SH NAME
IO \- Parses the command line for parameters and holds user-specified parameters\&.  

.SH SYNOPSIS
.br
.PP
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef std::map< std::string, std::map< std::string, void(*)(\fButil::ParamData\fP &, const void *, void *)> > \fBFunctionMapType\fP"
.br
.RI "Map for functions and types\&. "
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static void \fBAdd\fP (\fButil::ParamData\fP &&d)"
.br
.RI "Adds a parameter to the hierarchy; use the PARAM_*() macros instead of this (i\&.e\&. "
.ti -1c
.RI "static std::map< char, std::string > & \fBAliases\fP ()"
.br
.RI "Return a modifiable list of aliases that \fBIO\fP knows about\&. "
.ti -1c
.RI "static void \fBCheckInputMatrices\fP ()"
.br
.RI "Checks all input matrices for NaN and inf values, exits if found any\&. "
.ti -1c
.RI "template<typename T > static void \fBCheckInputMatrix\fP (const T &matrix, const std::string &identifier)"
.br
.RI "Utility function for \fBCheckInputMatrices()\fP\&. "
.ti -1c
.RI "static void \fBClearSettings\fP ()"
.br
.RI "Clear all of the settings, removing all parameters and function mappings\&. "
.ti -1c
.RI "template<typename T > static T & \fBGetParam\fP (const std::string &identifier)"
.br
.RI "Get the value of type T found while parsing\&. "
.ti -1c
.RI "template<typename T > static std::string \fBGetPrintableParam\fP (const std::string &identifier)"
.br
.RI "Cast the given parameter of the given type to a short, printable std::string, for use in status messages\&. "
.ti -1c
.RI "template<typename T > static T & \fBGetRawParam\fP (const std::string &identifier)"
.br
.RI "Get the raw value of the parameter before any processing that \fBGetParam()\fP might normally do\&. "
.ti -1c
.RI "static \fBIO\fP & \fBGetSingleton\fP ()"
.br
.RI "Retrieve the singleton\&. "
.ti -1c
.RI "static bool \fBHasParam\fP (const std::string &identifier)"
.br
.RI "See if the specified flag was found while parsing\&. "
.ti -1c
.RI "static void \fBMakeInPlaceCopy\fP (const std::string &outputParamName, const std::string &inputParamName)"
.br
.RI "Given two (matrix) parameters, ensure that the first is an in-place copy of the second\&. "
.ti -1c
.RI "static std::map< std::string, \fButil::ParamData\fP > & \fBParameters\fP ()"
.br
.RI "Return a modifiable list of parameters that \fBIO\fP knows about\&. "
.ti -1c
.RI "static std::string \fBProgramName\fP ()"
.br
.RI "Get the program name as set by the BINDING_NAME() macro\&. "
.ti -1c
.RI "static void \fBRestoreSettings\fP (const std::string &name, const bool fatal=true)"
.br
.RI "Restore all of the parameters and function mappings of the given name, if they exist\&. "
.ti -1c
.RI "static void \fBSetPassed\fP (const std::string &name)"
.br
.RI "Mark a particular parameter as passed\&. "
.ti -1c
.RI "static void \fBStoreSettings\fP (const std::string &name)"
.br
.RI "Take all parameters and function mappings and store them, under the given name\&. "
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "bool \fBdidParse\fP"
.br
.RI "True, if \fBIO\fP was used to parse command line options\&. "
.ti -1c
.RI "\fButil::BindingDetails\fP \fBdoc\fP"
.br
.RI "Holds the bindingDetails objects\&. "
.ti -1c
.RI "\fBFunctionMapType\fP \fBfunctionMap\fP"
.br
.ti -1c
.RI "std::string \fBprogramName\fP"
.br
.RI "Holds the name of the program for --version\&. "
.ti -1c
.RI "\fBTimers\fP \fBtimer\fP"
.br
.RI "Holds the timer objects\&. "
.in -1c
.SH "Detailed Description"
.PP 
Parses the command line for parameters and holds user-specified parameters\&. 

The \fBIO\fP class is a subsystem by which parameters for machine learning methods can be specified and accessed\&. In conjunction with the macros PARAM_DOUBLE, PARAM_INT, PARAM_STRING, PARAM_FLAG, and others, this class aims to make user configurability of mlpack methods very easy\&. There are only three methods in \fBIO\fP that a user should need: IO::ParseCommandLine(), \fBIO::GetParam()\fP, and \fBIO::HasParam()\fP (in addition to the PARAM_*() macros)\&.
.SH "Adding parameters to a program"
.PP
.PP
.nf
$ \&./executable --bar=5
.fi
.PP
.PP
\fBNote:\fP
.RS 4
The = is optional; a space can also be used\&.
.RE
.PP
A parameter is specified by using one of the following macros (this is not a complete list; see core/io/io\&.hpp):
.PP
.IP "\(bu" 2
PARAM_FLAG(ID, DESC, ALIAS)
.IP "\(bu" 2
PARAM_DOUBLE(ID, DESC, ALIAS, DEF)
.IP "\(bu" 2
PARAM_INT(ID, DESC, ALIAS, DEF)
.IP "\(bu" 2
PARAM_STRING(ID, DESC, ALIAS, DEF)
.PP
.PP
\fBParameters:\fP
.RS 4
\fIID\fP Name of the parameter\&. 
.br
\fIDESC\fP Short description of the parameter (one/two sentences)\&. 
.br
\fIALIAS\fP An alias for the parameter\&. 
.br
\fIDEF\fP Default value of the parameter\&.
.RE
.PP
The flag (boolean) type automatically defaults to false; it is specified merely as a flag on the command line (no '=true' is required)\&.
.PP
Here is an example of a few parameters being defined; this is for the KNN binding (methods/neighbor_search/knn_main\&.cpp):
.PP
.PP
.nf
PARAM_STRING_REQ("reference_file", "File containing the reference dataset\&.",
    "r");
PARAM_STRING_REQ("distances_file", "File to output distances into\&.", "d");
PARAM_STRING_REQ("neighbors_file", "File to output neighbors into\&.", "n");
PARAM_INT_REQ("k", "Number of furthest neighbors to find\&.", "k");
PARAM_STRING("query_file", "File containing query points (optional)\&.", "q",
    "");
PARAM_INT("leaf_size", "Leaf size for tree building\&.", "l", 20);
PARAM_FLAG("naive", "If true, O(n^2) naive mode is used for computation\&.",
    "N");
PARAM_FLAG("single_mode", "If true, single-tree search is used (as opposed "
    "to dual-tree search\&.", "s");
.fi
.PP
.PP
More documentation is available on the PARAM_*() macros in the documentation for core/io/io\&.hpp\&.
.SH "Documenting the program itself"
.PP
In addition to allowing documentation for each individual parameter and module, the BINDING_NAME() macro provides support for documenting the programName, BINDING_SHORT_DESC() macro provides support for documenting the shortDescription, BINDING_LONG_DESC() macro provides support for documenting the longDescription, the BINDING_EXAMPLE() macro provides support for documenting the example and the BINDING_SEE_ALSO() macro provides support for documenting the seeAlso\&. There should only be one instance of the BINDING_NAME(), BINDING_SHORT_DESC() and BINDING_LONG_DESC() macros and there can be multiple instance of BINDING_EXAMPLE() and BINDING_SEE_ALSO() macro\&. Below is an example:
.PP
.PP
.nf
BINDING_NAME("Maximum Variance Unfolding");
BINDING_SHORT_DESC("An implementation of Maximum Variance Unfolding");
BINDING_LONG_DESC( "This program performs maximum "
   "variance unfolding on the given dataset, writing a lower-dimensional "
   "unfolded dataset to the given output file\&.");
BINDING_EXAMPLE("mvu", "input", "dataset", "new_dim", 5, "output", "output");
BINDING_SEE_ALSO("Perceptron", "#perceptron");
.fi
.PP
.PP
This description should be verbose, and explain to a non-expert user what the program does and how to use it\&. If relevant, paper citations should be included\&.
.SH "Parsing the command line with IO"
.PP
To have \fBIO\fP parse the command line at the beginning of code execution, only a call to ParseCommandLine() is necessary:
.PP
.PP
.nf
int main(int argc, char** argv)
{
  IO::ParseCommandLine(argc, argv);

  \&.\&.\&.
}
.fi
.PP
.PP
\fBIO\fP provides --help and --info options which give nicely formatted documentation of each option; the documentation is generated from the DESC arguments in the PARAM_*() macros\&.
.SH "Getting parameters with IO"
.PP
When the parameters have been defined, the next important thing is how to access them\&. For this, the \fBHasParam()\fP and \fBGetParam()\fP methods are used\&. For instance, to see if the user passed the flag (boolean) 'naive':
.PP
.PP
.nf
if (IO::HasParam("naive"))
{
  Log::Info << "Naive has been passed!" << std::endl;
}
.fi
.PP
.PP
To get the value of a parameter, such as a string, use GetParam:
.PP
.PP
.nf
const std::string filename = IO::GetParam<std::string>("filename");
.fi
.PP
.PP
\fBNote:\fP
.RS 4
Options should only be defined in files which define \fCmain()\fP (that is, main bindings)\&. If options are defined elsewhere, they may be spuriously included into other bindings and confuse users\&. Similarly, if your binding has options which you did not define, it is probably because the option is defined somewhere else and included in your binding\&.
.RE
.PP
\fBBug\fP
.RS 4
The \fBCOUNTER\fP variable is used in most cases to guarantee a unique global identifier for options declared using the PARAM_*() macros\&. However, not all compilers have this support--most notably, gcc < 4\&.3\&. In that case, the \fBLINE\fP macro is used as an attempt to get a unique global identifier, but collisions are still possible, and they produce bizarre error messages\&. See https://github.com/mlpack/mlpack/issues/100 for more information\&. 
.RE
.PP

.PP
Definition at line 172 of file io\&.hpp\&.
.SH "Member Typedef Documentation"
.PP 
.SS "typedef std::map<std::string, std::map<std::string, void (*)(\fButil::ParamData\fP&, const void*, void*)> > \fBFunctionMapType\fP"

.PP
Map for functions and types\&. Use as functionMap['typename']['functionName']\&. 
.PP
Definition at line 312 of file io\&.hpp\&.
.SH "Member Function Documentation"
.PP 
.SS "static void Add (\fButil::ParamData\fP && d)\fC [static]\fP"

.PP
Adds a parameter to the hierarchy; use the PARAM_*() macros instead of this (i\&.e\&. PARAM_INT())\&.
.PP
\fBParameters:\fP
.RS 4
\fId\fP Utility structure holding parameter data\&. 
.RE
.PP

.SS "static std::map<char, std::string>& Aliases ()\fC [static]\fP"

.PP
Return a modifiable list of aliases that \fBIO\fP knows about\&. 
.SS "static void CheckInputMatrices ()\fC [static]\fP"

.PP
Checks all input matrices for NaN and inf values, exits if found any\&. 
.SS "static void CheckInputMatrix (const T & matrix, const std::string & identifier)\fC [static]\fP"

.PP
Utility function for \fBCheckInputMatrices()\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fImatrix\fP Matrix to check\&. 
.br
\fIidentifier\fP Name of the parameter in question\&. 
.RE
.PP

.SS "static void ClearSettings ()\fC [static]\fP"

.PP
Clear all of the settings, removing all parameters and function mappings\&. 
.SS "static T& GetParam (const std::string & identifier)\fC [static]\fP"

.PP
Get the value of type T found while parsing\&. You can set the value using this reference safely\&.
.PP
\fBParameters:\fP
.RS 4
\fIidentifier\fP The name of the parameter in question\&. 
.RE
.PP

.SS "static std::string GetPrintableParam (const std::string & identifier)\fC [static]\fP"

.PP
Cast the given parameter of the given type to a short, printable std::string, for use in status messages\&. Ideally the message returned here should be only a handful of characters, and certainly no longer than one line\&.
.PP
\fBParameters:\fP
.RS 4
\fIidentifier\fP The name of the parameter in question\&. 
.RE
.PP

.SS "static T& GetRawParam (const std::string & identifier)\fC [static]\fP"

.PP
Get the raw value of the parameter before any processing that \fBGetParam()\fP might normally do\&. So, e\&.g\&., for command-line programs, this does not perform any data loading or manipulation like \fBGetParam()\fP does\&. So if you want to access a matrix or model (or similar) parameter before it is loaded, this is the method to use\&.
.PP
\fBParameters:\fP
.RS 4
\fIidentifier\fP The name of the parameter in question\&. 
.RE
.PP

.SS "static \fBIO\fP& GetSingleton ()\fC [static]\fP"

.PP
Retrieve the singleton\&. As an end user, if you are just using the \fBIO\fP object, you should not need to use this function---the other static functions should be sufficient\&.
.PP
In this case, the singleton is used to store data for the static methods, as there is no point in defining static methods only to have users call private instance methods\&.
.PP
\fBReturns:\fP
.RS 4
The singleton instance for use in the static methods\&. 
.RE
.PP

.SS "static bool HasParam (const std::string & identifier)\fC [static]\fP"

.PP
See if the specified flag was found while parsing\&. 
.PP
\fBParameters:\fP
.RS 4
\fIidentifier\fP The name of the parameter in question\&. 
.RE
.PP

.SS "static void MakeInPlaceCopy (const std::string & outputParamName, const std::string & inputParamName)\fC [static]\fP"

.PP
Given two (matrix) parameters, ensure that the first is an in-place copy of the second\&. This will generally do nothing (as the bindings already do this automatically), except for command-line bindings, where we need to ensure that the output filename is the same as the input filename\&.
.PP
\fBParameters:\fP
.RS 4
\fIoutputParamName\fP Name of output (matrix) parameter\&. 
.br
\fIinputParamName\fP Name of input (matrix) parameter\&. 
.RE
.PP

.SS "static std::map<std::string, \fButil::ParamData\fP>& Parameters ()\fC [static]\fP"

.PP
Return a modifiable list of parameters that \fBIO\fP knows about\&. 
.SS "static std::string ProgramName ()\fC [static]\fP"

.PP
Get the program name as set by the BINDING_NAME() macro\&. 
.SS "static void RestoreSettings (const std::string & name, const bool fatal = \fCtrue\fP)\fC [static]\fP"

.PP
Restore all of the parameters and function mappings of the given name, if they exist\&. A std::invalid_argument exception will be thrown if fatal is true and no settings with the given name have been stored (with \fBStoreSettings()\fP)\&.
.PP
\fBParameters:\fP
.RS 4
\fIname\fP Name of settings to restore\&. 
.br
\fIfatal\fP Whether to throw an exception on an unknown name\&. 
.RE
.PP

.SS "static void SetPassed (const std::string & name)\fC [static]\fP"

.PP
Mark a particular parameter as passed\&. 
.PP
\fBParameters:\fP
.RS 4
\fIname\fP Name of the parameter\&. 
.RE
.PP

.PP
Referenced by mlpack::util::SetInputParam()\&.
.SS "static void StoreSettings (const std::string & name)\fC [static]\fP"

.PP
Take all parameters and function mappings and store them, under the given name\&. This can later be restored with \fBRestoreSettings()\fP\&. If settings have already been saved under the given name, they will be overwritten\&. This also clears the current parameters and function map\&.
.PP
\fBParameters:\fP
.RS 4
\fIname\fP Name of settings to save\&. 
.RE
.PP

.SH "Member Data Documentation"
.PP 
.SS "bool didParse"

.PP
True, if \fBIO\fP was used to parse command line options\&. 
.PP
Definition at line 322 of file io\&.hpp\&.
.SS "\fButil::BindingDetails\fP doc"

.PP
Holds the bindingDetails objects\&. 
.PP
Definition at line 335 of file io\&.hpp\&.
.SS "\fBFunctionMapType\fP functionMap"

.PP
Definition at line 313 of file io\&.hpp\&.
.SS "std::string programName"

.PP
Holds the name of the program for --version\&. This is the true program name (argv[0]) not what is given in BindingDetails\&. 
.PP
Definition at line 326 of file io\&.hpp\&.
.SS "\fBTimers\fP timer"

.PP
Holds the timer objects\&. 
.PP
Definition at line 329 of file io\&.hpp\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for mlpack from the source code\&.
