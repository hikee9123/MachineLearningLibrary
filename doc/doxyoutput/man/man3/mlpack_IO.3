.TH "IO" 3 "Sun Aug 22 2021" "Version 3.4.2" "mlpack" \" -*- nroff -*-
.ad l
.nh
.SH NAME
IO \- Parses the command line for parameters and holds user-specified parameters\&.  

.SH SYNOPSIS
.br
.PP
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static void \fBAddBindingName\fP (const std::string &bindingName, const std::string &name)"
.br
.RI "Add a user-friendly name for a binding\&. "
.ti -1c
.RI "static void \fBAddExample\fP (const std::string &bindingName, const std::function< std::string()> &example)"
.br
.RI "Add an example for a binding\&. "
.ti -1c
.RI "static void \fBAddFunction\fP (const std::string &type, const std::string &name, void(*func)(\fButil::ParamData\fP &, const void *, void *))"
.br
.RI "Add a function to the function map\&. "
.ti -1c
.RI "static void \fBAddLongDescription\fP (const std::string &bindingName, const std::function< std::string()> &longDescription)"
.br
.RI "Add a long description for a binding\&. "
.ti -1c
.RI "static void \fBAddParameter\fP (const std::string &bindingName, \fButil::ParamData\fP &&d)"
.br
.RI "Adds a parameter to the hierarchy; use the PARAM_*() macros instead of this (i\&.e\&. "
.ti -1c
.RI "static void \fBAddSeeAlso\fP (const std::string &bindingName, const std::string &description, const std::string &link)"
.br
.RI "Add a SeeAlso for a binding\&. "
.ti -1c
.RI "static void \fBAddShortDescription\fP (const std::string &bindingName, const std::string &shortDescription)"
.br
.RI "Add a short description for a binding\&. "
.ti -1c
.RI "static \fBIO\fP & \fBGetSingleton\fP ()"
.br
.RI "Retrieve the singleton\&. "
.ti -1c
.RI "static \fButil::Timers\fP & \fBGetTimers\fP ()"
.br
.RI "Retrieve the global Timers object\&. "
.ti -1c
.RI "static \fButil::Params\fP \fBParameters\fP (const std::string &bindingName)"
.br
.RI "Return a new Params object initialized with all the parameters of the binding \fCbindingName\fP\&. "
.in -1c
.SH "Detailed Description"
.PP 
Parses the command line for parameters and holds user-specified parameters\&. 

The \fBIO\fP class is a subsystem by which parameters for machine learning methods can be specified and accessed\&. In conjunction with the macros PARAM_DOUBLE, PARAM_INT, PARAM_STRING, PARAM_FLAG, and others, this class aims to make user configurability of mlpack methods very easy\&. There are only three methods in \fBIO\fP that a user should need: IO::ParseCommandLine(), IO::GetParam(), and IO::HasParam() (in addition to the PARAM_*() macros)\&.
.SH "Adding parameters to a program"
.PP
.PP
.nf
$ \&./executable --bar=5
.fi
.PP
.PP
\fBNote:\fP
.RS 4
The = is optional; a space can also be used\&.
.RE
.PP
A parameter is specified by using one of the following macros (this is not a complete list; see core/io/io\&.hpp):
.PP
.IP "\(bu" 2
PARAM_FLAG(ID, DESC, ALIAS)
.IP "\(bu" 2
PARAM_DOUBLE(ID, DESC, ALIAS, DEF)
.IP "\(bu" 2
PARAM_INT(ID, DESC, ALIAS, DEF)
.IP "\(bu" 2
PARAM_STRING(ID, DESC, ALIAS, DEF)
.PP
.PP
\fBParameters:\fP
.RS 4
\fIID\fP Name of the parameter\&. 
.br
\fIDESC\fP Short description of the parameter (one/two sentences)\&. 
.br
\fIALIAS\fP An alias for the parameter\&. 
.br
\fIDEF\fP Default value of the parameter\&.
.RE
.PP
The flag (boolean) type automatically defaults to false; it is specified merely as a flag on the command line (no '=true' is required)\&.
.PP
Here is an example of a few parameters being defined; this is for the KNN binding (methods/neighbor_search/knn_main\&.cpp):
.PP
.PP
.nf
PARAM_STRING_REQ("reference_file", "File containing the reference dataset\&.",
    "r");
PARAM_STRING_REQ("distances_file", "File to output distances into\&.", "d");
PARAM_STRING_REQ("neighbors_file", "File to output neighbors into\&.", "n");
PARAM_INT_REQ("k", "Number of furthest neighbors to find\&.", "k");
PARAM_STRING("query_file", "File containing query points (optional)\&.", "q",
    "");
PARAM_INT("leaf_size", "Leaf size for tree building\&.", "l", 20);
PARAM_FLAG("naive", "If true, O(n^2) naive mode is used for computation\&.",
    "N");
PARAM_FLAG("single_mode", "If true, single-tree search is used (as opposed "
    "to dual-tree search\&.", "s");
.fi
.PP
.PP
More documentation is available on the PARAM_*() macros in the documentation for core/io/io\&.hpp\&.
.SH "Documenting the program itself"
.PP
In addition to allowing documentation for each individual parameter and module, the BINDING_NAME() macro provides support for documenting the programName, BINDING_SHORT_DESC() macro provides support for documenting the shortDescription, BINDING_LONG_DESC() macro provides support for documenting the longDescription, the BINDING_EXAMPLE() macro provides support for documenting the example and the BINDING_SEE_ALSO() macro provides support for documenting the seeAlso\&. There should only be one instance of the BINDING_NAME(), BINDING_SHORT_DESC() and BINDING_LONG_DESC() macros and there can be multiple instance of BINDING_EXAMPLE() and BINDING_SEE_ALSO() macro\&. Below is an example:
.PP
.PP
.nf
BINDING_NAME("Maximum Variance Unfolding");
BINDING_SHORT_DESC("An implementation of Maximum Variance Unfolding");
BINDING_LONG_DESC( "This program performs maximum "
   "variance unfolding on the given dataset, writing a lower-dimensional "
   "unfolded dataset to the given output file\&.");
BINDING_EXAMPLE("mvu", "input", "dataset", "new_dim", 5, "output", "output");
BINDING_SEE_ALSO("Perceptron", "#perceptron");
.fi
.PP
.PP
This description should be verbose, and explain to a non-expert user what the program does and how to use it\&. If relevant, paper citations should be included\&.
.SH "Parsing the command line with IO"
.PP
To have \fBIO\fP parse the command line at the beginning of code execution, only a call to ParseCommandLine() is necessary:
.PP
.PP
.nf
int main(int argc, char** argv)
{
  IO::ParseCommandLine(argc, argv);

  \&.\&.\&.
}
.fi
.PP
.PP
\fBIO\fP provides --help and --info options which give nicely formatted documentation of each option; the documentation is generated from the DESC arguments in the PARAM_*() macros\&.
.SH "Getting parameters with IO"
.PP
When the parameters have been defined, the next important thing is how to access them\&. For this, the HasParam() and GetParam() methods are used\&. For instance, to see if the user passed the flag (boolean) 'naive':
.PP
.PP
.nf
if (IO::HasParam("naive"))
{
  Log::Info << "Naive has been passed!" << std::endl;
}
.fi
.PP
.PP
To get the value of a parameter, such as a string, use GetParam:
.PP
.PP
.nf
const std::string filename = IO::GetParam<std::string>("filename");
.fi
.PP
.PP
\fBNote:\fP
.RS 4
Options should only be defined in files which define \fCmain()\fP (that is, main bindings)\&. If options are defined elsewhere, they may be spuriously included into other bindings and confuse users\&. Similarly, if your binding has options which you did not define, it is probably because the option is defined somewhere else and included in your binding\&.
.RE
.PP
\fBBug\fP
.RS 4
The \fBCOUNTER\fP variable is used in most cases to guarantee a unique global identifier for options declared using the PARAM_*() macros\&. However, not all compilers have this support--most notably, gcc < 4\&.3\&. In that case, the \fBLINE\fP macro is used as an attempt to get a unique global identifier, but collisions are still possible, and they produce bizarre error messages\&. See https://github.com/mlpack/mlpack/issues/100 for more information\&. 
.RE
.PP

.PP
Definition at line 176 of file io\&.hpp\&.
.SH "Member Function Documentation"
.PP 
.SS "static void AddBindingName (const std::string & bindingName, const std::string & name)\fC [static]\fP"

.PP
Add a user-friendly name for a binding\&. 
.PP
\fBParameters:\fP
.RS 4
\fIbindingName\fP Name of the binding to add the user-friendly name for\&. 
.br
\fIname\fP User-friendly name\&. 
.RE
.PP

.SS "static void AddExample (const std::string & bindingName, const std::function< std::string()> & example)\fC [static]\fP"

.PP
Add an example for a binding\&. 
.PP
\fBParameters:\fP
.RS 4
\fIbindingName\fP Name of the binding to add the example for\&. 
.br
\fIexample\fP Function that returns the example\&. 
.RE
.PP

.SS "static void AddFunction (const std::string & type, const std::string & name, void(*)(\fButil::ParamData\fP &, const void *, void *) func)\fC [static]\fP"

.PP
Add a function to the function map\&. 
.PP
\fBParameters:\fP
.RS 4
\fItype\fP Type that this function should be called for\&. 
.br
\fIname\fP Name of the function\&. 
.br
\fIfunc\fP Function to call\&. 
.RE
.PP

.SS "static void AddLongDescription (const std::string & bindingName, const std::function< std::string()> & longDescription)\fC [static]\fP"

.PP
Add a long description for a binding\&. 
.PP
\fBParameters:\fP
.RS 4
\fIbindingName\fP Name of the binding to add the description for\&. 
.br
\fIlongDescription\fP Function that returns the long description\&. 
.RE
.PP

.SS "static void AddParameter (const std::string & bindingName, \fButil::ParamData\fP && d)\fC [static]\fP"

.PP
Adds a parameter to the hierarchy; use the PARAM_*() macros instead of this (i\&.e\&. PARAM_INT())\&.
.PP
\fBParameters:\fP
.RS 4
\fIbindingName\fP Name of the binding that this parameter is associated with\&. 
.br
\fId\fP Utility structure holding parameter data\&. 
.RE
.PP

.SS "static void AddSeeAlso (const std::string & bindingName, const std::string & description, const std::string & link)\fC [static]\fP"

.PP
Add a SeeAlso for a binding\&. 
.PP
\fBParameters:\fP
.RS 4
\fIbindingName\fP Name of the binding to add the example for\&. 
.br
\fIdescription\fP Description of the SeeAlso\&. 
.br
\fIlink\fP Link of the SeeAlso\&. 
.RE
.PP

.SS "static void AddShortDescription (const std::string & bindingName, const std::string & shortDescription)\fC [static]\fP"

.PP
Add a short description for a binding\&. 
.PP
\fBParameters:\fP
.RS 4
\fIbindingName\fP Name of the binding to add the description for\&. 
.br
\fIshortDescription\fP Description to use\&. 
.RE
.PP

.SS "static \fBIO\fP& GetSingleton ()\fC [static]\fP"

.PP
Retrieve the singleton\&. As an end user, if you are just using the \fBIO\fP object, you should not need to use this function---the other static functions should be sufficient\&.
.PP
In this case, the singleton is used to store data for the static methods, as there is no point in defining static methods only to have users call private instance methods\&.
.PP
\fBReturns:\fP
.RS 4
The singleton instance for use in the static methods\&. 
.RE
.PP

.SS "static \fButil::Timers\fP& GetTimers ()\fC [static]\fP"

.PP
Retrieve the global Timers object\&. 
.SS "static \fButil::Params\fP Parameters (const std::string & bindingName)\fC [static]\fP"

.PP
Return a new Params object initialized with all the parameters of the binding \fCbindingName\fP\&. This is intended to be called at the beginning of the run of a binding\&. 

.SH "Author"
.PP 
Generated automatically by Doxygen for mlpack from the source code\&.
