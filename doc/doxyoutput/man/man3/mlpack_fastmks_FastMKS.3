.TH "FastMKS< KernelType, MatType, TreeType >" 3 "Sun Aug 22 2021" "Version 3.4.2" "mlpack" \" -*- nroff -*-
.ad l
.nh
.SH NAME
FastMKS< KernelType, MatType, TreeType > \- An implementation of fast exact max-kernel search\&.  

.SH SYNOPSIS
.br
.PP
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef TreeType< \fBmetric::IPMetric\fP< KernelType >, \fBFastMKSStat\fP, MatType > \fBTree\fP"
.br
.RI "Convenience typedef\&. "
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBFastMKS\fP (const bool singleMode=false, const bool naive=false)"
.br
.RI "Create the \fBFastMKS\fP object with an empty reference set and default kernel\&. "
.ti -1c
.RI "\fBFastMKS\fP (const MatType &referenceSet, const bool singleMode=false, const bool naive=false)"
.br
.RI "Create the \fBFastMKS\fP object with the given reference set (this is the set that is searched)\&. "
.ti -1c
.RI "\fBFastMKS\fP (const MatType &referenceSet, KernelType &kernel, const bool singleMode=false, const bool naive=false)"
.br
.RI "Create the \fBFastMKS\fP object using the reference set (this is the set that is searched) with an initialized kernel\&. "
.ti -1c
.RI "\fBFastMKS\fP (MatType &&referenceSet, const bool singleMode=false, const bool naive=false)"
.br
.RI "Create the \fBFastMKS\fP object with the given reference set (this is the set that is searched), taking ownership of the reference set\&. "
.ti -1c
.RI "\fBFastMKS\fP (MatType &&referenceSet, KernelType &kernel, const bool singleMode=false, const bool naive=false)"
.br
.RI "Create the \fBFastMKS\fP object using the reference set (this is the set that is searched) with an initialized kernel, taking ownership of the reference set\&. "
.ti -1c
.RI "\fBFastMKS\fP (\fBTree\fP *referenceTree, const bool singleMode=false)"
.br
.RI "Create the \fBFastMKS\fP object with an already-initialized tree built on the reference points\&. "
.ti -1c
.RI "\fBFastMKS\fP (const \fBFastMKS\fP &other)"
.br
.RI "Copy the parameters of the given model\&. "
.ti -1c
.RI "\fBFastMKS\fP (\fBFastMKS\fP &&other)"
.br
.RI "Take ownership of the given model\&. "
.ti -1c
.RI "\fB~FastMKS\fP ()"
.br
.RI "Destructor for the \fBFastMKS\fP object\&. "
.ti -1c
.RI "const \fBmetric::IPMetric\fP< KernelType > & \fBMetric\fP () const"
.br
.RI "Get the inner-product metric induced by the given kernel\&. "
.ti -1c
.RI "\fBmetric::IPMetric\fP< KernelType > & \fBMetric\fP ()"
.br
.RI "Modify the inner-product metric induced by the given kernel\&. "
.ti -1c
.RI "bool \fBNaive\fP () const"
.br
.RI "Get whether or not brute-force (naive) search is used\&. "
.ti -1c
.RI "bool & \fBNaive\fP ()"
.br
.RI "Modify whether or not brute-force (naive) search is used\&. "
.ti -1c
.RI "\fBFastMKS\fP & \fBoperator=\fP (const \fBFastMKS\fP &other)"
.br
.RI "Assign this model to be a copy of the given model\&. "
.ti -1c
.RI "\fBFastMKS\fP & \fBoperator=\fP (\fBFastMKS\fP &&other)"
.br
.RI "Move assignment operator\&. "
.ti -1c
.RI "void \fBSearch\fP (const MatType &querySet, const size_t k, arma::Mat< size_t > &indices, arma::mat &kernels)"
.br
.RI "Search for the points in the reference set with maximum kernel evaluation to each point in the given query set\&. "
.ti -1c
.RI "void \fBSearch\fP (\fBTree\fP *querySet, const size_t k, arma::Mat< size_t > &indices, arma::mat &kernels)"
.br
.RI "Search for the points in the reference set with maximum kernel evaluation to each point in the query set corresponding to the given pre-built query tree\&. "
.ti -1c
.RI "void \fBSearch\fP (const size_t k, arma::Mat< size_t > &indices, arma::mat &products)"
.br
.RI "Search for the maximum inner products of the query set (or if no query set was passed, the reference set is used)\&. "
.ti -1c
.RI "template<typename Archive > void \fBserialize\fP (Archive &ar, const uint32_t)"
.br
.RI "Serialize the model\&. "
.ti -1c
.RI "bool \fBSingleMode\fP () const"
.br
.RI "Get whether or not single-tree search is used\&. "
.ti -1c
.RI "bool & \fBSingleMode\fP ()"
.br
.RI "Modify whether or not single-tree search is used\&. "
.ti -1c
.RI "void \fBTrain\fP (const MatType &referenceSet)"
.br
.RI "'Train' the \fBFastMKS\fP model on the given reference set (this will just build a tree, if the current search mode is not naive mode)\&. "
.ti -1c
.RI "void \fBTrain\fP (const MatType &referenceSet, KernelType &kernel)"
.br
.RI "'Train' the \fBFastMKS\fP model on the given reference set and use the given kernel\&. "
.ti -1c
.RI "void \fBTrain\fP (MatType &&referenceSet)"
.br
.RI "'Train' the \fBFastMKS\fP model on the given reference set (this will just build a tree, if the current search mode is not naive mode)\&. "
.ti -1c
.RI "void \fBTrain\fP (MatType &&referenceSet, KernelType &kernel)"
.br
.RI "'Train' the \fBFastMKS\fP model on the given reference set and use the given kernel\&. "
.ti -1c
.RI "void \fBTrain\fP (\fBTree\fP *referenceTree)"
.br
.RI "Train the \fBFastMKS\fP model on the given reference tree\&. "
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename KernelType, typename MatType = arma::mat, template< typename TreeMetricType, typename TreeStatType, typename TreeMatType > class TreeType = tree::StandardCoverTree>
.br
class mlpack::fastmks::FastMKS< KernelType, MatType, TreeType >"
An implementation of fast exact max-kernel search\&. 

Given a query dataset and a reference dataset (or optionally just a reference dataset which is also used as the query dataset), fast exact max-kernel search finds, for each point in the query dataset, the k points in the reference set with maximum kernel value K(p_q, p_r), where k is a specified parameter and K() is a Mercer kernel\&.
.PP
For more information, see the following paper\&.
.PP
.PP
.nf
@inproceedings{curtin2013fast,
  title={Fast Exact Max-Kernel Search},
  author={Curtin, Ryan R\&. and Ram, Parikshit and Gray, Alexander G\&.},
  booktitle={Proceedings of the 2013 SIAM International Conference on Data
      Mining (SDM 13)},
  year={2013}
}
.fi
.PP
.PP
This class allows specification of the type of kernel and also of the type of tree\&. \fBFastMKS\fP can be run on kernels that work on arbitrary objects -- however, this only works with cover trees and other trees that are built only on points in the dataset (and not centroids of regions or anything like that)\&.
.PP
\fBTemplate Parameters:\fP
.RS 4
\fIKernelType\fP Type of kernel to run \fBFastMKS\fP with\&. 
.br
\fIMatType\fP Type of data matrix (usually arma::mat)\&. 
.br
\fITreeType\fP Type of tree to run \fBFastMKS\fP with; it must satisfy the TreeType policy API\&. 
.RE
.PP

.PP
Definition at line 63 of file fastmks\&.hpp\&.
.SH "Member Typedef Documentation"
.PP 
.SS "typedef TreeType<\fBmetric::IPMetric\fP<KernelType>, \fBFastMKSStat\fP, MatType> \fBTree\fP"

.PP
Convenience typedef\&. 
.PP
Definition at line 67 of file fastmks\&.hpp\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "\fBFastMKS\fP (const bool singleMode = \fCfalse\fP, const bool naive = \fCfalse\fP)"

.PP
Create the \fBFastMKS\fP object with an empty reference set and default kernel\&. Make sure to call \fBTrain()\fP before \fBSearch()\fP is called!
.PP
\fBParameters:\fP
.RS 4
\fIsingleMode\fP Whether or not to run single-tree search\&. 
.br
\fInaive\fP Whether or not to run brute-force (naive) search\&. 
.RE
.PP

.SS "\fBFastMKS\fP (const MatType & referenceSet, const bool singleMode = \fCfalse\fP, const bool naive = \fCfalse\fP)"

.PP
Create the \fBFastMKS\fP object with the given reference set (this is the set that is searched)\&. Optionally, specify whether or not single-tree search or naive (brute-force) search should be used\&.
.PP
\fBParameters:\fP
.RS 4
\fIreferenceSet\fP Set of reference data\&. 
.br
\fIsingleMode\fP Whether or not to run single-tree search\&. 
.br
\fInaive\fP Whether or not to run brute-force (naive) search\&. 
.RE
.PP

.SS "\fBFastMKS\fP (const MatType & referenceSet, KernelType & kernel, const bool singleMode = \fCfalse\fP, const bool naive = \fCfalse\fP)"

.PP
Create the \fBFastMKS\fP object using the reference set (this is the set that is searched) with an initialized kernel\&. This is useful for when the kernel stores state\&. Optionally, specify whether or not single-tree search or naive (brute-force) search should be used\&.
.PP
\fBParameters:\fP
.RS 4
\fIreferenceSet\fP Reference set of data for \fBFastMKS\fP\&. 
.br
\fIkernel\fP Initialized kernel\&. 
.br
\fIsingleMode\fP Whether or not to run single-tree search\&. 
.br
\fInaive\fP Whether or not to run brute-force (naive) search\&. 
.RE
.PP

.SS "\fBFastMKS\fP (MatType && referenceSet, const bool singleMode = \fCfalse\fP, const bool naive = \fCfalse\fP)"

.PP
Create the \fBFastMKS\fP object with the given reference set (this is the set that is searched), taking ownership of the reference set\&. Optionally, specify whether or not single-tree search or naive (brute-force) search should be used\&.
.PP
\fBParameters:\fP
.RS 4
\fIreferenceSet\fP Set of reference data\&. 
.br
\fIsingleMode\fP Whether or not to run single-tree search\&. 
.br
\fInaive\fP Whether or not to run brute-force (naive) search\&. 
.RE
.PP

.SS "\fBFastMKS\fP (MatType && referenceSet, KernelType & kernel, const bool singleMode = \fCfalse\fP, const bool naive = \fCfalse\fP)"

.PP
Create the \fBFastMKS\fP object using the reference set (this is the set that is searched) with an initialized kernel, taking ownership of the reference set\&. This is useful for when the kernel stores state\&. Optionally, specify whether or not single-tree search or naive (brute-force) search should be used\&.
.PP
\fBParameters:\fP
.RS 4
\fIreferenceSet\fP Reference set of data for \fBFastMKS\fP\&. 
.br
\fIkernel\fP Initialized kernel\&. 
.br
\fIsingleMode\fP Whether or not to run single-tree search\&. 
.br
\fInaive\fP Whether or not to run brute-force (naive) search\&. 
.RE
.PP

.SS "\fBFastMKS\fP (\fBTree\fP * referenceTree, const bool singleMode = \fCfalse\fP)"

.PP
Create the \fBFastMKS\fP object with an already-initialized tree built on the reference points\&. Be sure that the tree is built with the metric type IPMetric<KernelType>\&. Optionally, whether or not to run single-tree search can be specified\&. Brute-force search is not available with this constructor since a tree is given (use one of the other constructors)\&.
.PP
\fBParameters:\fP
.RS 4
\fIreferenceTree\fP Tree built on reference data\&. 
.br
\fIsingleMode\fP Whether or not to run single-tree search\&. 
.RE
.PP

.SS "\fBFastMKS\fP (const \fBFastMKS\fP< KernelType, MatType, TreeType > & other)"

.PP
Copy the parameters of the given model\&. 
.SS "\fBFastMKS\fP (\fBFastMKS\fP< KernelType, MatType, TreeType > && other)"

.PP
Take ownership of the given model\&. 
.SS "~\fBFastMKS\fP ()"

.PP
Destructor for the \fBFastMKS\fP object\&. 
.SH "Member Function Documentation"
.PP 
.SS "const \fBmetric::IPMetric\fP<KernelType>& Metric () const\fC [inline]\fP"

.PP
Get the inner-product metric induced by the given kernel\&. 
.PP
Definition at line 291 of file fastmks\&.hpp\&.
.SS "\fBmetric::IPMetric\fP<KernelType>& Metric ()\fC [inline]\fP"

.PP
Modify the inner-product metric induced by the given kernel\&. 
.PP
Definition at line 293 of file fastmks\&.hpp\&.
.SS "bool Naive () const\fC [inline]\fP"

.PP
Get whether or not brute-force (naive) search is used\&. 
.PP
Definition at line 301 of file fastmks\&.hpp\&.
.SS "bool& Naive ()\fC [inline]\fP"

.PP
Modify whether or not brute-force (naive) search is used\&. 
.PP
Definition at line 303 of file fastmks\&.hpp\&.
.SS "\fBFastMKS\fP& operator= (const \fBFastMKS\fP< KernelType, MatType, TreeType > & other)"

.PP
Assign this model to be a copy of the given model\&. 
.SS "\fBFastMKS\fP& operator= (\fBFastMKS\fP< KernelType, MatType, TreeType > && other)"

.PP
Move assignment operator\&. 
.SS "void Search (const MatType & querySet, const size_t k, arma::Mat< size_t > & indices, arma::mat & kernels)"

.PP
Search for the points in the reference set with maximum kernel evaluation to each point in the given query set\&. The resulting kernel evaluations are stored in the kernels matrix, and the corresponding point indices are stored in the indices matrix\&. The results for each point in the query set are stored in the corresponding column of the kernels and products matrices; for instance, the index of the point with maximum kernel evaluation to point 4 in the query set will be stored in row 0 and column 4 of the indices matrix\&.
.PP
If querySet only contains a few points, the extra overhead of building a tree to perform dual-tree search may not be warranted, and it may be faster to use single-tree search, either by setting singleMode to false in the constructor or with \fBSingleMode()\fP\&.
.PP
\fBParameters:\fP
.RS 4
\fIquerySet\fP Set of query points (can be a single point)\&. 
.br
\fIk\fP The number of maximum kernels to find\&. 
.br
\fIindices\fP Matrix to store resulting indices of max-kernel search in\&. 
.br
\fIkernels\fP Matrix to store resulting max-kernel values in\&. 
.RE
.PP

.SS "void Search (\fBTree\fP * querySet, const size_t k, arma::Mat< size_t > & indices, arma::mat & kernels)"

.PP
Search for the points in the reference set with maximum kernel evaluation to each point in the query set corresponding to the given pre-built query tree\&. The resulting kernel evaluations are stored in the kernels matrix, and the corresponding point indices are stored in the indices matrix\&. The results for each point in the query set are stored in the corresponding column of the kernels and products matrices; for instance, the index of the point with maximum kernel evaluation to point 4 in the query set will be stored in row 0 and column 4 of the indices matrix\&.
.PP
This will throw an exception if called while the \fBFastMKS\fP object has 'single' set to true\&.
.PP
Be aware that if your tree modifies the original input matrix, the results here are with respect to the modified input matrix (that is, queryTree->Dataset())\&.
.PP
\fBParameters:\fP
.RS 4
\fIquerySet\fP Tree built on query points\&. 
.br
\fIk\fP The number of maximum kernels to find\&. 
.br
\fIindices\fP Matrix to store resulting indices of max-kernel search in\&. 
.br
\fIkernels\fP Matrix to store resulting max-kernel values in\&. 
.RE
.PP

.SS "void Search (const size_t k, arma::Mat< size_t > & indices, arma::mat & products)"

.PP
Search for the maximum inner products of the query set (or if no query set was passed, the reference set is used)\&. The resulting maximum inner products are stored in the products matrix and the corresponding point indices are stores in the indices matrix\&. The results for each point in the query set are stored in the corresponding column of the indices and products matrices; for instance, the index of the point with maximum inner product to point 4 in the query set will be stored in row 0 and column 4 of the indices matrix\&.
.PP
\fBParameters:\fP
.RS 4
\fIk\fP The number of maximum kernels to find\&. 
.br
\fIindices\fP Matrix to store resulting indices of max-kernel search in\&. 
.br
\fIproducts\fP Matrix to store resulting max-kernel values in\&. 
.RE
.PP

.SS "void serialize (Archive & ar, const uint32_t)"

.PP
Serialize the model\&. 
.PP
Referenced by FastMKS< mlpack::kernel::CosineDistance >::Naive()\&.
.SS "bool SingleMode () const\fC [inline]\fP"

.PP
Get whether or not single-tree search is used\&. 
.PP
Definition at line 296 of file fastmks\&.hpp\&.
.SS "bool& SingleMode ()\fC [inline]\fP"

.PP
Modify whether or not single-tree search is used\&. 
.PP
Definition at line 298 of file fastmks\&.hpp\&.
.SS "void Train (const MatType & referenceSet)"

.PP
'Train' the \fBFastMKS\fP model on the given reference set (this will just build a tree, if the current search mode is not naive mode)\&. 
.PP
\fBParameters:\fP
.RS 4
\fIreferenceSet\fP Set of reference points\&. 
.RE
.PP

.SS "void Train (const MatType & referenceSet, KernelType & kernel)"

.PP
'Train' the \fBFastMKS\fP model on the given reference set and use the given kernel\&. This will just build a tree and replace the metric, if the current search mode is not naive mode\&.
.PP
\fBParameters:\fP
.RS 4
\fIreferenceSet\fP Set of reference points\&. 
.br
\fIkernel\fP Kernel to use for search\&. 
.RE
.PP

.SS "void Train (MatType && referenceSet)"

.PP
'Train' the \fBFastMKS\fP model on the given reference set (this will just build a tree, if the current search mode is not naive mode)\&. This takes ownership of the reference set\&.
.PP
\fBParameters:\fP
.RS 4
\fIreferenceSet\fP Set of reference points\&. 
.RE
.PP

.SS "void Train (MatType && referenceSet, KernelType & kernel)"

.PP
'Train' the \fBFastMKS\fP model on the given reference set and use the given kernel\&. This will just build a tree and replace the metric, if the current search mode is not naive mode\&. This takes ownership of the reference set\&.
.PP
\fBParameters:\fP
.RS 4
\fIreferenceSet\fP Set of reference points\&. 
.br
\fIkernel\fP Kernel to use for search\&. 
.RE
.PP

.SS "void Train (\fBTree\fP * referenceTree)"

.PP
Train the \fBFastMKS\fP model on the given reference tree\&. This takes ownership of the tree, so you do not need to delete it! This will throw an exception if the model is searching in naive mode (i\&.e\&. if \fBNaive()\fP == true)\&.
.PP
\fBParameters:\fP
.RS 4
\fIreferenceTree\fP Tree to use as reference data\&. 
.RE
.PP


.SH "Author"
.PP 
Generated automatically by Doxygen for mlpack from the source code\&.
