.TH "mlpack::bound::addr" 3 "Sun Aug 22 2021" "Version 3.4.2" "mlpack" \" -*- nroff -*-
.ad l
.nh
.SH NAME
mlpack::bound::addr
.SH SYNOPSIS
.br
.PP
.SS "Functions"

.in +1c
.ti -1c
.RI "template<typename AddressType , typename VecType > void \fBAddressToPoint\fP (VecType &point, const AddressType &address)"
.br
.RI "Translate the address to the point\&. "
.ti -1c
.RI "template<typename AddressType1 , typename AddressType2 > int \fBCompareAddresses\fP (const AddressType1 &addr1, const AddressType2 &addr2)"
.br
.RI "Compare two addresses\&. "
.ti -1c
.RI "template<typename AddressType1 , typename AddressType2 , typename AddressType3 > bool \fBContains\fP (const AddressType1 &address, const AddressType2 &loBound, const AddressType3 &hiBound)"
.br
.RI "Returns true if an address is contained between two other addresses\&. "
.ti -1c
.RI "template<typename AddressType , typename VecType > void \fBPointToAddress\fP (AddressType &address, const VecType &point)"
.br
.RI "Calculate the address of a point\&. "
.in -1c
.SH "Function Documentation"
.PP 
.SS "void mlpack::bound::addr::AddressToPoint (VecType & point, const AddressType & address)"

.PP
Translate the address to the point\&. Be careful, the point and the address variables should be equal-sized and the type of the address should correspond to the type of the vector\&.
.PP
The function makes the backward transform to the function above\&.
.PP
\fBParameters:\fP
.RS 4
\fIaddress\fP An address to translate\&. 
.br
\fIpoint\fP The point that corresponds to the address\&. 
.RE
.PP

.PP
Definition at line 153 of file address\&.hpp\&.
.SS "int mlpack::bound::addr::CompareAddresses (const AddressType1 & addr1, const AddressType2 & addr2)"

.PP
Compare two addresses\&. The function returns 1 if the first address is greater than the second one, -1 if the first address is less than the second one, otherwise the function returns 0\&. 
.PP
Definition at line 233 of file address\&.hpp\&.
.PP
Referenced by Contains()\&.
.SS "bool mlpack::bound::addr::Contains (const AddressType1 & address, const AddressType2 & loBound, const AddressType3 & hiBound)"

.PP
Returns true if an address is contained between two other addresses\&. 
.PP
Definition at line 256 of file address\&.hpp\&.
.PP
References CompareAddresses()\&.
.PP
Referenced by HRectBound< MetricType >::Metric()\&.
.SS "void mlpack::bound::addr::PointToAddress (AddressType & address, const VecType & point)"

.PP
Calculate the address of a point\&. Be careful, the point and the address variables should be equal-sized and the type of the address should correspond to the type of the vector\&.
.PP
The function maps each floating point coordinate to an equal-sized unsigned integer datatype in such a way that the transform preserves the ordering (i\&.e\&. lower floating point values correspond to lower integers)\&. Thus, the mapping saves the exponent and the mantissa of each floating point value consequently, furthermore the exponent is stored before the mantissa\&. In the case of negative numbers the resulting integer value should be inverted\&. In the multi-dimensional case, after we transform the representation, we have to interleave the bits of the new representation across all the elements in the address vector\&.
.PP
\fBParameters:\fP
.RS 4
\fIaddress\fP The resulting address\&. 
.br
\fIpoint\fP The point that is being translated to the address\&.
.RE
.PP
mlpack is free software; you may redistribute it and/or modify it under the terms of the 3-clause BSD license\&. You should have received a copy of the 3-clause BSD license along with mlpack\&. If not, see http://www.opensource.org/licenses/BSD-3-Clause for more information\&. 
.PP
Definition at line 57 of file address\&.hpp\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for mlpack from the source code\&.
