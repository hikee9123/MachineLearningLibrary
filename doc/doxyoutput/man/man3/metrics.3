.TH "metrics" 3 "Sun Aug 22 2021" "Version 3.4.2" "mlpack" \" -*- nroff -*-
.ad l
.nh
.SH NAME
metricsThe MetricType policy in mlpack 
 \- Many machine learning methods operate with some sort of metric, and often, this metric can be any arbitrary metric\&. For instance, consider the problem of nearest neighbor search; one can find the nearest neighbor of a point with respect to the standard Euclidean distance, or the Manhattan (city-block) distance\&. The actual search techniques, though, remain the same\&. And this is true of many machine learning methods: the specific metric that is used can be any valid metric\&.
.PP
mlpack algorithms, when possible, allow the use of an arbitrary metric via the use of the \fCMetricType\fP template parameter\&. Any metric passed as a \fCMetricType\fP template parameter will need to have
.PP
.IP "\(bu" 2
an \fCEvaluate\fP function
.IP "\(bu" 2
a default constructor\&.
.PP
.PP
The signature of the \fCEvaluate\fP function is straightforward:
.PP
.PP
.nf
template<typename VecTypeA, typename VecTypeB>
double Evaluate(const VecTypeA& a, const VecTypeB& b);
.fi
.PP
.PP
The function takes two vector arguments, \fCa\fP and \fCb\fP, and returns a \fCdouble\fP that is the evaluation of the metric between the two arguments\&. So, for a particular metric $d(\cdot, \cdot)$, the \fCEvaluate()\fP function should return $d(a, b)$\&.
.PP
The arguments \fCa\fP and \fCb\fP, of types \fCVecTypeA\fP and \fCVecTypeB\fP, respectively, will be an Armadillo-like vector type (usually \fCarma::vec\fP, \fCarma::sp_vec\fP, or similar)\&. In general it should be valid to assume that \fCVecTypeA\fP is a class with the same API as \fCarma::vec\fP\&.
.PP
Note that for metrics that do not hold any state, the \fCEvaluate()\fP method can be marked as \fCstatic\fP\&.
.PP
Overall, the \fCMetricType\fP template policy is quite simple (much like the \fBThe KernelType policy in mlpack\fP KernelType policy)\&. Below is an example metric class, which implements the L2 distance:
.PP
.PP
.nf
class ExampleMetric
{
  // Default constructor is required\&.
  ExampleMetric() { }

  // The example metric holds no state, so we can mark Evaluate() as static\&.
  template<typename VecTypeA, typename VecTypeB>
  static double Evaluate(const VecTypeA& a, const VecTypeB& b)
  {
    // Return the L2 norm of the difference between the points, which is the
    // same as the L2 distance\&.
    return arma::norm(a - b);
  }
};
.fi
.PP
.PP
Then, this metric can easily be used inside of other mlpack algorithms\&. For example, the code below runs range search on a random dataset with the \fCExampleKernel\fP, by instantiating a \fC\fBmlpack::range::RangeSearch\fP\fP object that uses the \fCExampleKernel\fP\&. Then, the number of results are printed\&. The \fCRangeSearch\fP class takes three template parameters: \fCMetricType\fP, \fCMatType\fP, and \fCTreeType\fP\&. (All three have defaults, so we will just leave \fCMatType\fP and \fCTreeType\fP to their defaults\&.)
.PP
.PP
.nf
#include <mlpack/core\&.hpp>
#include <mlpack/methods/range_search/range_search\&.hpp>
#include "example_metric\&.hpp" // A file that contains ExampleKernel\&.

using namespace mlpack;
using namespace mlpack::range;
using namespace std;

int main()
{
  // Create a random dataset with 10 dimensions and 5000 points\&.
  arma::mat data = arma::randu<arma::mat>(10, 5000);

  // Instantiate the RangeSearch object with the ExampleKernel\&.
  RangeSearch<ExampleKernel> rs(data);

  // These vectors will store the results\&.
  vector<vector<size_t>> neighbors;
  vector<vector<double>> distances;

  // Create a random 10-dimensional query point\&.
  arma::vec query = arma::randu<arma::vec>(10);

  // Find those points with distance (according to ExampleMetric) between 1 and
  // 2 from the query point\&.
  rs\&.Search(query, math::Range(1\&.0, 2\&.0), neighbors, distances);

  // Now, print the number of points inside the desired range\&.  We know that
  // neighbors and distances will have length 1, since there was only one query
  // point\&.
  cout << neighbors[0]\&.size() << " points within the range [1\&.0, 2\&.0] of the "
      << "query point!" << endl;
}
.fi
.PP
.PP
mlpack comes with a number of pre-written metrics that satisfy the \fCMetricType\fP policy:
.PP
.IP "\(bu" 2
\fBmlpack::metric::ManhattanDistance\fP
.IP "\(bu" 2
\fBmlpack::metric::EuclideanDistance\fP
.IP "\(bu" 2
\fBmlpack::metric::ChebyshevDistance\fP
.IP "\(bu" 2
\fBmlpack::metric::MahalanobisDistance\fP
.IP "\(bu" 2
\fBmlpack::metric::LMetric\fP (for arbitrary L-metrics)
.IP "\(bu" 2
\fBmlpack::metric::IPMetric\fP (requires a \fBKernelType\fP parameter) 
.PP

