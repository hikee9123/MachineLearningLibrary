.TH "RangeSearch< MetricType, MatType, TreeType >" 3 "Thu Jun 24 2021" "Version 3.4.2" "mlpack" \" -*- nroff -*-
.ad l
.nh
.SH NAME
RangeSearch< MetricType, MatType, TreeType > \- The \fBRangeSearch\fP class is a template class for performing range searches\&.  

.SH SYNOPSIS
.br
.PP
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef TreeType< MetricType, \fBRangeSearchStat\fP, MatType > \fBTree\fP"
.br
.RI "Convenience typedef\&. "
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBRangeSearch\fP (MatType referenceSet, const bool naive=false, const bool singleMode=false, const MetricType metric=MetricType())"
.br
.RI "Initialize the \fBRangeSearch\fP object with a given reference dataset (this is the dataset which is searched)\&. "
.ti -1c
.RI "\fBRangeSearch\fP (\fBTree\fP *referenceTree, const bool singleMode=false, const MetricType metric=MetricType())"
.br
.RI "Initialize the \fBRangeSearch\fP object with the given pre-constructed reference tree (this is the tree built on the reference set, which is the set that is searched)\&. "
.ti -1c
.RI "\fBRangeSearch\fP (const bool naive=false, const bool singleMode=false, const MetricType metric=MetricType())"
.br
.RI "Initialize the \fBRangeSearch\fP object without any reference data\&. "
.ti -1c
.RI "\fBRangeSearch\fP (const \fBRangeSearch\fP &other)"
.br
.RI "Construct the \fBRangeSearch\fP model as a copy of the given model\&. "
.ti -1c
.RI "\fBRangeSearch\fP (\fBRangeSearch\fP &&other)"
.br
.RI "Construct the \fBRangeSearch\fP model by taking ownership of the given model\&. "
.ti -1c
.RI "\fB~RangeSearch\fP ()"
.br
.RI "Destroy the \fBRangeSearch\fP object\&. "
.ti -1c
.RI "size_t \fBBaseCases\fP () const"
.br
.RI "Get the number of base cases during the last search\&. "
.ti -1c
.RI "bool \fBNaive\fP () const"
.br
.RI "Get whether naive search is being used\&. "
.ti -1c
.RI "bool & \fBNaive\fP ()"
.br
.RI "Modify whether naive search is being used\&. "
.ti -1c
.RI "\fBRangeSearch\fP & \fBoperator=\fP (const \fBRangeSearch\fP &other)"
.br
.RI "Deep copy the given \fBRangeSearch\fP model\&. "
.ti -1c
.RI "\fBRangeSearch\fP & \fBoperator=\fP (\fBRangeSearch\fP &&other)"
.br
.RI "Move the given \fBRangeSearch\fP model\&. "
.ti -1c
.RI "const MatType & \fBReferenceSet\fP () const"
.br
.RI "Return the reference set\&. "
.ti -1c
.RI "\fBTree\fP * \fBReferenceTree\fP ()"
.br
.RI "Return the reference tree (or NULL if in naive mode)\&. "
.ti -1c
.RI "size_t \fBScores\fP () const"
.br
.RI "Get the number of scores during the last search\&. "
.ti -1c
.RI "void \fBSearch\fP (const MatType &querySet, const math::Range &range, std::vector< std::vector< size_t >> &neighbors, std::vector< std::vector< double >> &distances)"
.br
.RI "Search for all reference points in the given range for each point in the query set, returning the results in the neighbors and distances objects\&. "
.ti -1c
.RI "void \fBSearch\fP (\fBTree\fP *queryTree, const math::Range &range, std::vector< std::vector< size_t >> &neighbors, std::vector< std::vector< double >> &distances)"
.br
.RI "Given a pre-built query tree, search for all reference points in the given range for each point in the query set, returning the results in the neighbors and distances objects\&. "
.ti -1c
.RI "void \fBSearch\fP (const math::Range &range, std::vector< std::vector< size_t >> &neighbors, std::vector< std::vector< double >> &distances)"
.br
.RI "Search for all points in the given range for each point in the reference set (which was passed to the constructor), returning the results in the neighbors and distances objects\&. "
.ti -1c
.RI "template<typename Archive > void \fBserialize\fP (Archive &ar, const uint32_t version)"
.br
.RI "Serialize the model\&. "
.ti -1c
.RI "bool \fBSingleMode\fP () const"
.br
.RI "Get whether single-tree search is being used\&. "
.ti -1c
.RI "bool & \fBSingleMode\fP ()"
.br
.RI "Modify whether single-tree search is being used\&. "
.ti -1c
.RI "void \fBTrain\fP (MatType referenceSet)"
.br
.RI "Set the reference set to a new reference set, and build a tree if necessary\&. "
.ti -1c
.RI "void \fBTrain\fP (\fBTree\fP *referenceTree)"
.br
.RI "Set the reference tree to a new reference tree\&. "
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename MetricType = metric::EuclideanDistance, typename MatType = arma::mat, template< typename TreeMetricType, typename TreeStatType, typename TreeMatType > class TreeType = tree::KDTree>
.br
class mlpack::range::RangeSearch< MetricType, MatType, TreeType >"
The \fBRangeSearch\fP class is a template class for performing range searches\&. 

It is implemented in the style of a generalized tree-independent dual-tree algorithm; for more details on the actual algorithm, see the \fBRangeSearchRules\fP class\&.
.PP
\fBTemplate Parameters:\fP
.RS 4
\fIMetricType\fP Metric to use for range search calculations\&. 
.br
\fIMatType\fP Type of data to use\&. 
.br
\fITreeType\fP Type of tree to use; must satisfy the TreeType policy API\&. 
.RE
.PP

.PP
Definition at line 45 of file range_search\&.hpp\&.
.SH "Member Typedef Documentation"
.PP 
.SS "typedef TreeType<MetricType, \fBRangeSearchStat\fP, MatType> \fBTree\fP"

.PP
Convenience typedef\&. 
.PP
Definition at line 49 of file range_search\&.hpp\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "\fBRangeSearch\fP (MatType referenceSet, const bool naive = \fCfalse\fP, const bool singleMode = \fCfalse\fP, const MetricType metric = \fCMetricType()\fP)"

.PP
Initialize the \fBRangeSearch\fP object with a given reference dataset (this is the dataset which is searched)\&. Optionally, perform the computation in naive mode or single-tree mode\&. Additionally, an instantiated metric can be given, for cases where the distance metric holds data\&.
.PP
This method will move the matrices to internal copies, which are rearranged during tree-building\&. You can avoid creating an extra copy by pre-constructing the trees and passing them in using std::move\&.
.PP
\fBParameters:\fP
.RS 4
\fIreferenceSet\fP Reference dataset\&. 
.br
\fInaive\fP Whether the computation should be done in O(n^2) naive mode\&. 
.br
\fIsingleMode\fP Whether single-tree computation should be used (as opposed to dual-tree computation)\&. 
.br
\fImetric\fP Instantiated distance metric\&. 
.RE
.PP

.SS "\fBRangeSearch\fP (\fBTree\fP * referenceTree, const bool singleMode = \fCfalse\fP, const MetricType metric = \fCMetricType()\fP)"

.PP
Initialize the \fBRangeSearch\fP object with the given pre-constructed reference tree (this is the tree built on the reference set, which is the set that is searched)\&. Optionally, choose to use single-tree mode, which will not build a tree on query points\&. Naive mode is not available as an option for this constructor\&. Additionally, an instantiated distance metric can be given, for cases where the distance metric holds data\&.
.PP
There is no copying of the data matrices in this constructor (because tree-building is not necessary), so this is the constructor to use when copies absolutely must be avoided\&.
.PP
\fBNote:\fP
.RS 4
Because tree-building (at least with BinarySpaceTree) modifies the ordering of a matrix, be aware that mapping of the points back to their original indices is not done when this constructor is used\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIreferenceTree\fP Pre-built tree for reference points\&. 
.br
\fIsingleMode\fP Whether single-tree computation should be used (as opposed to dual-tree computation)\&. 
.br
\fImetric\fP Instantiated distance metric\&. 
.RE
.PP

.SS "\fBRangeSearch\fP (const bool naive = \fCfalse\fP, const bool singleMode = \fCfalse\fP, const MetricType metric = \fCMetricType()\fP)"

.PP
Initialize the \fBRangeSearch\fP object without any reference data\&. If the monochromatic \fBSearch()\fP is called before a reference set is set with \fBTrain()\fP, no results will be returned (since the reference set is empty)\&.
.PP
\fBParameters:\fP
.RS 4
\fInaive\fP Whether to use naive search\&. 
.br
\fIsingleMode\fP Whether single-tree computation should be used (as opposed to dual-tree computation)\&. 
.br
\fImetric\fP Instantiated metric\&. 
.RE
.PP

.SS "\fBRangeSearch\fP (const \fBRangeSearch\fP< MetricType, MatType, TreeType > & other)"

.PP
Construct the \fBRangeSearch\fP model as a copy of the given model\&. Note that this may be computationally intensive!
.PP
\fBParameters:\fP
.RS 4
\fIother\fP \fBRangeSearch\fP model to copy\&. 
.RE
.PP

.SS "\fBRangeSearch\fP (\fBRangeSearch\fP< MetricType, MatType, TreeType > && other)"

.PP
Construct the \fBRangeSearch\fP model by taking ownership of the given model\&. 
.PP
\fBParameters:\fP
.RS 4
\fIother\fP \fBRangeSearch\fP model to take ownership of\&. 
.RE
.PP

.SS "~\fBRangeSearch\fP ()"

.PP
Destroy the \fBRangeSearch\fP object\&. If trees were created, they will be deleted\&. 
.SH "Member Function Documentation"
.PP 
.SS "size_t BaseCases () const\fC [inline]\fP"

.PP
Get the number of base cases during the last search\&. 
.PP
Definition at line 282 of file range_search\&.hpp\&.
.SS "bool Naive () const\fC [inline]\fP"

.PP
Get whether naive search is being used\&. 
.PP
Definition at line 277 of file range_search\&.hpp\&.
.SS "bool& Naive ()\fC [inline]\fP"

.PP
Modify whether naive search is being used\&. 
.PP
Definition at line 279 of file range_search\&.hpp\&.
.SS "\fBRangeSearch\fP& operator= (const \fBRangeSearch\fP< MetricType, MatType, TreeType > & other)"

.PP
Deep copy the given \fBRangeSearch\fP model\&. 
.PP
\fBParameters:\fP
.RS 4
\fIother\fP \fBRangeSearch\fP model to copy\&. 
.RE
.PP

.SS "\fBRangeSearch\fP& operator= (\fBRangeSearch\fP< MetricType, MatType, TreeType > && other)"

.PP
Move the given \fBRangeSearch\fP model\&. 
.PP
\fBParameters:\fP
.RS 4
\fIother\fP \fBRangeSearch\fP model to move\&. 
.RE
.PP

.SS "const MatType& ReferenceSet () const\fC [inline]\fP"

.PP
Return the reference set\&. 
.PP
Definition at line 291 of file range_search\&.hpp\&.
.SS "\fBTree\fP* ReferenceTree ()\fC [inline]\fP"

.PP
Return the reference tree (or NULL if in naive mode)\&. 
.PP
Definition at line 294 of file range_search\&.hpp\&.
.SS "size_t Scores () const\fC [inline]\fP"

.PP
Get the number of scores during the last search\&. 
.PP
Definition at line 284 of file range_search\&.hpp\&.
.SS "void Search (const MatType & querySet, const math::Range & range, std::vector< std::vector< size_t >> & neighbors, std::vector< std::vector< double >> & distances)"

.PP
Search for all reference points in the given range for each point in the query set, returning the results in the neighbors and distances objects\&. Each entry in the external vector corresponds to a query point\&. Each of these entries holds a vector which contains the indices and distances of the reference points falling into the given range\&.
.PP
That is:
.PP
.IP "\(bu" 2
neighbors\&.size() and distances\&.size() both equal the number of query points\&.
.IP "\(bu" 2
neighbors[i] contains the indices of all the points in the reference set which have distances inside the given range to query point i\&.
.IP "\(bu" 2
distances[i] contains all of the distances corresponding to the indices contained in neighbors[i]\&.
.IP "\(bu" 2
neighbors[i] and distances[i] are not sorted in any particular order\&.
.PP
.PP
\fBParameters:\fP
.RS 4
\fIquerySet\fP Set of query points to search with\&. 
.br
\fIrange\fP Range of distances in which to search\&. 
.br
\fIneighbors\fP Object which will hold the list of neighbors for each point which fell into the given range, for each query point\&. 
.br
\fIdistances\fP Object which will hold the list of distances for each point which fell into the given range, for each query point\&. 
.RE
.PP

.SS "void Search (\fBTree\fP * queryTree, const math::Range & range, std::vector< std::vector< size_t >> & neighbors, std::vector< std::vector< double >> & distances)"

.PP
Given a pre-built query tree, search for all reference points in the given range for each point in the query set, returning the results in the neighbors and distances objects\&. Each entry in the external vector corresponds to a query point\&. Each of these entries holds a vector which contains the indices and distances of the reference points falling into the given range\&.
.PP
That is:
.PP
.IP "\(bu" 2
neighbors\&.size() and distances\&.size() both equal the number of query points\&.
.IP "\(bu" 2
neighbors[i] contains the indices of all the points in the reference set which have distances inside the given range to query point i\&.
.IP "\(bu" 2
distances[i] contains all of the distances corresponding to the indices contained in neighbors[i]\&.
.IP "\(bu" 2
neighbors[i] and distances[i] are not sorted in any particular order\&.
.PP
.PP
If either naive or singleMode are set to true, this will throw an invalid_argument exception; passing in a query tree implies dual-tree search\&.
.PP
If you want to use the reference tree as the query tree, instead call the overload of \fBSearch()\fP that does not take a query set\&.
.PP
\fBParameters:\fP
.RS 4
\fIqueryTree\fP Tree built on query points\&. 
.br
\fIrange\fP Range of distances in which to search\&. 
.br
\fIneighbors\fP Object which will hold the list of neighbors for each point which fell into the given range, for each query point\&. 
.br
\fIdistances\fP Object which will hold the list of distances for each point which fell into the given range, for each query point\&. 
.RE
.PP

.SS "void Search (const math::Range & range, std::vector< std::vector< size_t >> & neighbors, std::vector< std::vector< double >> & distances)"

.PP
Search for all points in the given range for each point in the reference set (which was passed to the constructor), returning the results in the neighbors and distances objects\&. This means that the query set and the reference set are the same\&.
.PP
Each entry in the external vector corresponds to a query point\&. Each of these entries holds a vector which contains the indices and distances of the reference points falling into the given range\&.
.PP
That is:
.PP
.IP "\(bu" 2
neighbors\&.size() and distances\&.size() both equal the number of query points\&.
.IP "\(bu" 2
neighbors[i] contains the indices of all the points in the reference set which have distances inside the given range to query point i\&.
.IP "\(bu" 2
distances[i] contains all of the distances corresponding to the indices contained in neighbors[i]\&.
.IP "\(bu" 2
neighbors[i] and distances[i] are not sorted in any particular order\&.
.PP
.PP
\fBParameters:\fP
.RS 4
\fIrange\fP Range of distances in which to search\&. 
.br
\fIneighbors\fP Object which will hold the list of neighbors for each point which fell into the given range, for each query point\&. 
.br
\fIdistances\fP Object which will hold the list of distances for each point which fell into the given range, for each query point\&. 
.RE
.PP

.SS "void serialize (Archive & ar, const uint32_t version)"

.PP
Serialize the model\&. 
.PP
Referenced by RangeSearch< metric::EuclideanDistance, arma::mat, TreeType >::Scores()\&.
.SS "bool SingleMode () const\fC [inline]\fP"

.PP
Get whether single-tree search is being used\&. 
.PP
Definition at line 272 of file range_search\&.hpp\&.
.SS "bool& SingleMode ()\fC [inline]\fP"

.PP
Modify whether single-tree search is being used\&. 
.PP
Definition at line 274 of file range_search\&.hpp\&.
.SS "void Train (MatType referenceSet)"

.PP
Set the reference set to a new reference set, and build a tree if necessary\&. This method is called '\fBTrain()\fP' in order to match the rest of the mlpack abstractions, even though calling this 'training' is maybe a bit of a stretch\&.
.PP
Use std::move to pass in the reference set if the old copy is no longer needed\&.
.PP
\fBParameters:\fP
.RS 4
\fIreferenceSet\fP New set of reference data\&. 
.RE
.PP

.SS "void Train (\fBTree\fP * referenceTree)"

.PP
Set the reference tree to a new reference tree\&. 

.SH "Author"
.PP 
Generated automatically by Doxygen for mlpack from the source code\&.
