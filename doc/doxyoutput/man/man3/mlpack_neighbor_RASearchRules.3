.TH "RASearchRules< SortPolicy, MetricType, TreeType >" 3 "Sun Aug 22 2021" "Version 3.4.2" "mlpack" \" -*- nroff -*-
.ad l
.nh
.SH NAME
RASearchRules< SortPolicy, MetricType, TreeType > \- The \fBRASearchRules\fP class is a template helper class used by \fBRASearch\fP class when performing rank-approximate search via random-sampling\&.  

.SH SYNOPSIS
.br
.PP
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef \fBtree::TraversalInfo\fP< TreeType > \fBTraversalInfoType\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBRASearchRules\fP (const arma::mat &referenceSet, const arma::mat &querySet, const size_t k, MetricType &metric, const double tau=5, const double alpha=0\&.95, const bool naive=false, const bool sampleAtLeaves=false, const bool firstLeafExact=false, const size_t singleSampleLimit=20, const bool sameSet=false)"
.br
.RI "Construct the \fBRASearchRules\fP object\&. "
.ti -1c
.RI "double \fBBaseCase\fP (const size_t queryIndex, const size_t referenceIndex)"
.br
.RI "Get the distance from the query point to the reference point\&. "
.ti -1c
.RI "void \fBGetResults\fP (arma::Mat< size_t > &neighbors, arma::mat &distances)"
.br
.RI "Store the list of candidates for each query point in the given matrices\&. "
.ti -1c
.RI "size_t \fBMinimumBaseCases\fP () const"
.br
.RI "Get the minimum number of base cases that must be performed for each query point for an acceptable result\&. "
.ti -1c
.RI "size_t \fBNumDistComputations\fP ()"
.br
.ti -1c
.RI "size_t \fBNumEffectiveSamples\fP ()"
.br
.ti -1c
.RI "double \fBRescore\fP (const size_t queryIndex, TreeType &referenceNode, const double oldScore)"
.br
.RI "Re-evaluate the score for recursion order\&. "
.ti -1c
.RI "double \fBRescore\fP (TreeType &queryNode, TreeType &referenceNode, const double oldScore)"
.br
.RI "Re-evaluate the score for recursion order\&. "
.ti -1c
.RI "double \fBScore\fP (const size_t queryIndex, TreeType &referenceNode)"
.br
.RI "Get the score for recursion order\&. "
.ti -1c
.RI "double \fBScore\fP (const size_t queryIndex, TreeType &referenceNode, const double baseCaseResult)"
.br
.RI "Get the score for recursion order\&. "
.ti -1c
.RI "double \fBScore\fP (TreeType &queryNode, TreeType &referenceNode)"
.br
.RI "Get the score for recursion order\&. "
.ti -1c
.RI "double \fBScore\fP (TreeType &queryNode, TreeType &referenceNode, const double baseCaseResult)"
.br
.RI "Get the score for recursion order, passing the base case result (in the situation where it may be needed to calculate the recursion order)\&. "
.ti -1c
.RI "const \fBTraversalInfoType\fP & \fBTraversalInfo\fP () const"
.br
.ti -1c
.RI "\fBTraversalInfoType\fP & \fBTraversalInfo\fP ()"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename SortPolicy, typename MetricType, typename TreeType>
.br
class mlpack::neighbor::RASearchRules< SortPolicy, MetricType, TreeType >"
The \fBRASearchRules\fP class is a template helper class used by \fBRASearch\fP class when performing rank-approximate search via random-sampling\&. 


.PP
\fBTemplate Parameters:\fP
.RS 4
\fISortPolicy\fP The sort policy for distances\&. 
.br
\fIMetricType\fP The metric to use for computation\&. 
.br
\fITreeType\fP The tree type to use; must adhere to the TreeType API\&. 
.RE
.PP

.PP
Definition at line 33 of file ra_search_rules\&.hpp\&.
.SH "Member Typedef Documentation"
.PP 
.SS "typedef \fBtree::TraversalInfo\fP<TreeType> \fBTraversalInfoType\fP"

.PP
Definition at line 239 of file ra_search_rules\&.hpp\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "\fBRASearchRules\fP (const arma::mat & referenceSet, const arma::mat & querySet, const size_t k, MetricType & metric, const double tau = \fC5\fP, const double alpha = \fC0\&.95\fP, const bool naive = \fCfalse\fP, const bool sampleAtLeaves = \fCfalse\fP, const bool firstLeafExact = \fCfalse\fP, const size_t singleSampleLimit = \fC20\fP, const bool sameSet = \fCfalse\fP)"

.PP
Construct the \fBRASearchRules\fP object\&. This is usually done from within the \fBRASearch\fP class at search time\&.
.PP
\fBParameters:\fP
.RS 4
\fIreferenceSet\fP Set of reference data\&. 
.br
\fIquerySet\fP Set of query data\&. 
.br
\fIk\fP Number of neighbors to search for\&. 
.br
\fImetric\fP Instantiated metric\&. 
.br
\fItau\fP The rank-approximation in percentile of the data\&. 
.br
\fIalpha\fP The desired success probability\&. 
.br
\fInaive\fP If true, the rank-approximate search will be performed by directly sampling the whole set instead of using the stratified sampling on the tree\&. 
.br
\fIsampleAtLeaves\fP Sample at leaves for faster but less accurate computation\&. 
.br
\fIfirstLeafExact\fP Traverse to the first leaf without approximation\&. 
.br
\fIsingleSampleLimit\fP The limit on the largest node that can be approximated by sampling\&. 
.br
\fIsameSet\fP If true, the query and reference set are taken to be the same, and a query point will not return itself in the results\&. 
.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "double BaseCase (const size_t queryIndex, const size_t referenceIndex)"

.PP
Get the distance from the query point to the reference point\&. This will update the list of candidates with the new point if appropriate\&.
.PP
\fBParameters:\fP
.RS 4
\fIqueryIndex\fP Index of query point\&. 
.br
\fIreferenceIndex\fP Index of reference point\&. 
.RE
.PP

.SS "void GetResults (arma::Mat< size_t > & neighbors, arma::mat & distances)"

.PP
Store the list of candidates for each query point in the given matrices\&. 
.PP
\fBParameters:\fP
.RS 4
\fIneighbors\fP Matrix storing lists of neighbors for each query point\&. 
.br
\fIdistances\fP Matrix storing distances of neighbors for each query point\&. 
.RE
.PP

.SS "size_t MinimumBaseCases () const\fC [inline]\fP"

.PP
Get the minimum number of base cases that must be performed for each query point for an acceptable result\&. This is only needed in defeatist search mode\&. 
.PP
Definition at line 247 of file ra_search_rules\&.hpp\&.
.PP
References RASearchRules< SortPolicy, MetricType, TreeType >::Score()\&.
.SS "size_t NumDistComputations ()\fC [inline]\fP"

.PP
Definition at line 230 of file ra_search_rules\&.hpp\&.
.SS "size_t NumEffectiveSamples ()\fC [inline]\fP"

.PP
Definition at line 231 of file ra_search_rules\&.hpp\&.
.SS "double Rescore (const size_t queryIndex, TreeType & referenceNode, const double oldScore)"

.PP
Re-evaluate the score for recursion order\&. A low score indicates priority for recursion, while DBL_MAX indicates that the node should not be recursed into at all (it should be pruned)\&. This is used when the score has already been calculated, but another recursion may have modified the bounds for pruning\&. So the old score is checked against the new pruning bound\&.
.PP
For rank-approximation, it also checks if the number of samples left for a query to satisfy the rank constraint is small enough at this point of the algorithm, then this node is approximated by sampling and given a new score of 'DBL_MAX'\&.
.PP
\fBParameters:\fP
.RS 4
\fIqueryIndex\fP Index of query point\&. 
.br
\fIreferenceNode\fP Candidate node to be recursed into\&. 
.br
\fIoldScore\fP Old score produced by \fBScore()\fP (or \fBRescore()\fP)\&. 
.RE
.PP

.SS "double Rescore (TreeType & queryNode, TreeType & referenceNode, const double oldScore)"

.PP
Re-evaluate the score for recursion order\&. A low score indicates priority for recursion, while DBL_MAX indicates that the node should not be recursed into at all (it should be pruned)\&. This is used when the score has already been calculated, but another recursion may have modified the bounds for pruning\&. So the old score is checked against the new pruning bound\&.
.PP
For the rank-approximation, we check if the referenceNode can be approximated by sampling\&. If it can be, enough samples are made for every query in the queryNode\&. No further query-tree traversal is performed\&.
.PP
The 'NumSamplesMade' query stat is propagated up the tree\&. And then if pruning occurs (by distance or by sampling), the 'NumSamplesMade' stat is not propagated down the tree\&. If no pruning occurs, the stat is propagated down the tree\&.
.PP
\fBParameters:\fP
.RS 4
\fIqueryNode\fP Candidate query node to recurse into\&. 
.br
\fIreferenceNode\fP Candidate reference node to recurse into\&. 
.br
\fIoldScore\fP Old score produced by Socre() (or \fBRescore()\fP)\&. 
.RE
.PP

.SS "double Score (const size_t queryIndex, TreeType & referenceNode)"

.PP
Get the score for recursion order\&. A low score indicates priority for recursion, while DBL_MAX indicates that the node should not be recursed into at all (it should be pruned)\&.
.PP
For rank-approximation, the scoring function first checks if pruning by distance is possible\&. If yes, then the node is given the score of 'DBL_MAX' and the expected number of samples from that node are added to the number of samples made for the query\&.
.PP
If no, then the function tries to see if the node can be pruned by approximation\&. If number of samples required from this node is small enough, then that number of samples are acquired from this node and the score is set to be 'DBL_MAX'\&.
.PP
If the pruning by approximation is not possible either, the algorithm continues with the usual tree-traversal\&.
.PP
\fBParameters:\fP
.RS 4
\fIqueryIndex\fP Index of query point\&. 
.br
\fIreferenceNode\fP Candidate node to be recursed into\&. 
.RE
.PP

.PP
Referenced by RASearchRules< SortPolicy, MetricType, TreeType >::MinimumBaseCases()\&.
.SS "double Score (const size_t queryIndex, TreeType & referenceNode, const double baseCaseResult)"

.PP
Get the score for recursion order\&. A low score indicates priority for recursion, while DBL_MAX indicates that the node should not be recursed into at all (it should be pruned)\&.
.PP
For rank-approximation, the scoring function first checks if pruning by distance is possible\&. If yes, then the node is given the score of 'DBL_MAX' and the expected number of samples from that node are added to the number of samples made for the query\&.
.PP
If no, then the function tries to see if the node can be pruned by approximation\&. If number of samples required from this node is small enough, then that number of samples are acquired from this node and the score is set to be 'DBL_MAX'\&.
.PP
If the pruning by approximation is not possible either, the algorithm continues with the usual tree-traversal\&.
.PP
\fBParameters:\fP
.RS 4
\fIqueryIndex\fP Index of query point\&. 
.br
\fIreferenceNode\fP Candidate node to be recursed into\&. 
.br
\fIbaseCaseResult\fP Result of BaseCase(queryIndex, referenceNode)\&. 
.RE
.PP

.SS "double Score (TreeType & queryNode, TreeType & referenceNode)"

.PP
Get the score for recursion order\&. A low score indicates priority for recursionm while DBL_MAX indicates that the node should not be recursed into at all (it should be pruned)\&.
.PP
For the rank-approximation, we check if the referenceNode can be approximated by sampling\&. If it can be, enough samples are made for every query in the queryNode\&. No further query-tree traversal is performed\&.
.PP
The 'NumSamplesMade' query stat is propagated up the tree\&. And then if pruning occurs (by distance or by sampling), the 'NumSamplesMade' stat is not propagated down the tree\&. If no pruning occurs, the stat is propagated down the tree\&.
.PP
\fBParameters:\fP
.RS 4
\fIqueryNode\fP Candidate query node to recurse into\&. 
.br
\fIreferenceNode\fP Candidate reference node to recurse into\&. 
.RE
.PP

.SS "double Score (TreeType & queryNode, TreeType & referenceNode, const double baseCaseResult)"

.PP
Get the score for recursion order, passing the base case result (in the situation where it may be needed to calculate the recursion order)\&. A low score indicates priority for recursion, while DBL_MAX indicates that the node should not be recursed into at all (it should be pruned)\&.
.PP
For the rank-approximation, we check if the referenceNode can be approximated by sampling\&. If it can be, enough samples are made for every query in the queryNode\&. No further query-tree traversal is performed\&.
.PP
The 'NumSamplesMade' query stat is propagated up the tree\&. And then if pruning occurs (by distance or by sampling), the 'NumSamplesMade' stat is not propagated down the tree\&. If no pruning occurs, the stat is propagated down the tree\&.
.PP
\fBParameters:\fP
.RS 4
\fIqueryNode\fP Candidate query node to recurse into\&. 
.br
\fIreferenceNode\fP Candidate reference node to recurse into\&. 
.br
\fIbaseCaseResult\fP Result of BaseCase(queryIndex, referenceNode)\&. 
.RE
.PP

.SS "const \fBTraversalInfoType\fP& TraversalInfo () const\fC [inline]\fP"

.PP
Definition at line 241 of file ra_search_rules\&.hpp\&.
.SS "\fBTraversalInfoType\fP& TraversalInfo ()\fC [inline]\fP"

.PP
Definition at line 242 of file ra_search_rules\&.hpp\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for mlpack from the source code\&.
