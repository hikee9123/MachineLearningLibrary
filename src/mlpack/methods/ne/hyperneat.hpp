/**
 * @file hyperneat.hpp
 * @author Bang Liu
 *
 * Definition of the HyperNEAT class.
 */
#ifndef MLPACK_METHODS_NE_HYPERNEAT_HPP
#define MLPACK_METHODS_NE_HYPERNEAT_HPP

#include <mlpack/core.hpp>

#include "link_gene.hpp"
#include "neuron_gene.hpp"
#include "genome.hpp"
#include "species.hpp"
#include "population.hpp"
#include "tasks.hpp"
#include "parameters.hpp"
#include "neat.hpp"
#include "substrate.hpp"

namespace mlpack {
namespace ne {

/**
 * This class defines HyperNEAT.
 */
template<typename TaskType>
class HyperNEAT
{
 public:
  // // NEAT instance.
  // NEAT<TaskType> neat;

  // Substrate.
  Substrate substrate;

  // /**
  //  * Parametric constructor.
  //  *
  //  * @param task The task to solve.
  //  * @param substrate The substrate configuration for the task.
  //  * @param seedGenome The genome to initialize population.
  //  * @param params The Parameter object that contains algorithm parameters.
  //  */
  // HyperNEAT(TaskType task, Substrate& substrate, Genome& seedGenome, Parameters& params)
  // {
  //   neat = NEAT<TaskType>(task, seedGenome, params);
  //   this->substrate = substrate;  // New member compared with NEAT.
  // }

  // /**
  //  * Destructor.
  //  */
  // ~HyperNEAT() {}

  // /**
  //  * Evaluate genomes in population. 
  //  * Set genomes' fitness, species' and population's best fitness and genome.
  //  *
  //  * This is the key difference with NEAT. Thus need to override it.
  //  * Rather than evaluate each genome in population directly, we need to query 
  //  * the substrate to decide the connections in the substrate, and evaluate the 
  //  * substrate genome.
  //  */
  // void Evaluate()
  // {
  // 	Genome genome;  // The genome generated by the substrate.
  // 	substrate.InitGenome(genome);

  //   for (int i = 0; i < neat.population.species.size(); ++i)
  //   {
  //     for (int j = 0; j < neat.population.species[i].genomes.size(); ++j)
  //     {
  //       neat.population.species[i].genomes[j].Flush();
  //       substrate.QueryLink(neat.population.species[i].genomes[j], genome);  // Query weight.

  //       double fitness = neat.task.EvalFitness(genome);  // Evaluate genome generated by substrate.
  //       neat.population.species[i].genomes[j].Fitness(fitness);
  //     }

  //     double oldSpeciesBestFitness = neat.population.species[i].BestFitness();
  //     neat.population.species[i].SetBestFitnessAndGenome();
  //     double newSpeciesBestFitness = neat.population.species[i].BestFitness();
  //     if (newSpeciesBestFitness < oldSpeciesBestFitness)
  //     {
  //       neat.population.species[i].StaleAge(0);
  //     } else
  //     {
  //       int staleAge = neat.population.species[i].StaleAge();
  //       neat.population.species[i].StaleAge(staleAge + 1);
  //     }
  //   }
  //   neat.population.SetBestFitnessAndGenome();
  // }

  // /**
  //  * Evolve population of genomes to get a task's solution genome.
  //  *
  //  * This function is the whole progress of HyperNEAT algorithm.
  //  * It is almost the same with NEAT's Evolve. The difference is that
  //  * it use the Evaluate function defined in HyperNEAT.
  //  */
  // bool Evolve()
  // {
  //   // Generate initial species at random.
  //   int generation = 0;
  //   neat.InitPopulation();

  //   // Speciate genomes into species.
  //   std::vector<Genome> genomes;
  //   neat.AggregateGenomes(neat.population, genomes);
  //   neat.population.species.clear();
  //   for (int i = 0; i < genomes.size(); ++i)
  //   {
  //     neat.AddGenomeToSpecies(neat.population, genomes[i]);
  //   }
    
  //   // Repeat
  //   while (generation < neat.maxGeneration)
  //   {
  //     // Evaluate all genomes in population.
  //     Evaluate();  // Here different with NEAT.

  //     // Output some information.
  //     printf("Generation: %zu\tBest fitness: %f\n", generation, neat.population.BestFitness());
  //     Log::Info << "Generation: " << generation << " best fitness: " <<  neat.population.BestFitness() << std::endl;
  //     if (neat.task.Success())
  //     {
  //       printf("Task succeed in %zu iterations.\n", generation);
  //       return true;
  //     }

  //     //Debug
  //     Genome bestGenome = neat.population.BestGenome();
  //     Genome substrateGenome;
  //     substrate.InitGenome(substrateGenome);
  //     substrate.QueryLink(bestGenome, substrateGenome);
  //     substrateGenome.PrintGenome();
  //     bestGenome.PrintGenome();

  //     // Reproduce next generation.
  //     neat.Reproduce();
  //     ++generation;
  //   }

  //   return false;
  // }

 private:

};

}  // namespace ne
}  // namespace mlpack

#endif  // MLPACK_METHODS_NE_HYPERNEAT_HPP