 /**
 * @file cne.hpp
 * @author Bang Liu
 *
 * Definition of CNE class.
 */
#ifndef MLPACK_METHODS_NE_CNE_HPP
#define MLPACK_METHODS_NE_CNE_HPP

#include <cstdio>

#include <mlpack/core.hpp>

#include "link_gene.hpp"
#include "neuron_gene.hpp"
#include "genome.hpp"
#include "species.hpp"
#include "tasks.hpp"
#include "parameters.hpp"

namespace mlpack {
namespace ne {

/**
 * This class implements Conventional Neuro-evolution (CNE): weight
 * evolution on topologically fixed neural networks.
 */
template<typename TaskType>
class CNE
{
 public:
  /**
   * Parametric constructor.
   *
   * @param task The task to solve.
   * @param seedGenome The genome to initialize species.
   * @param params The Parameter object that contains algorithm parameters.
   */
  CNE(TaskType task, Genome& seedGenome, Parameters& params)
  {
    this->task = task;
    this->seedGenome = seedGenome;
    speciesSize = params.speciesSize;
    maxGeneration = params.maxGeneration;
    mutateRate = params.mutateRate;
    mutateSize = params.mutateSize;
    elitePercentage = params.elitePercentage;
  }

  /**
   * Parametric constructor with default algorithm parameters.
   *
   * @param task The task to solve.
   * @param seedGenome The genome to initialize species.
   */
  CNE(TaskType task, Genome& seedGenome)
  {
    this->task = task;
    this->seedGenome = seedGenome;
    speciesSize = 500;
    maxGeneration = 5000;
    mutateRate = 0.1;
    mutateSize = 0.02;
    elitePercentage = 0.2;
  }

  /**
   * Destructor.
   */
  ~CNE() {}

  /** 
   * Soft weight mutation: add a Gaussian random value to genome link weights.
   *
   * @param genome The genome to mutate.
   * @param mutateProb The probability to mutate the genome's weight.
   * @param mutateSize The variance of Gaussian noise added to genome weights.
   */
  static void MutateWeightsBiased(Genome& genome, double mutateProb, double mutateSize)
  {
    for (int i = 0; i < genome.linkGenes.size(); ++i)
    {
      double p = mlpack::math::Random();  // rand 0~1
      if (p < mutateProb)
      {
        double deltaW = mlpack::math::RandNormal(0, mutateSize);
        double oldW = genome.linkGenes[i].Weight();
        genome.linkGenes[i].Weight(oldW + deltaW);
      }
    }
  }

  /** 
   * Hard weight mutation: replace genome link weights with Gaussian random values.
   *
   * @param genome The genome to mutate.
   * @param mutateProb The probability to mutate the genome's weight.
   * @param mutateSize The variance of Gaussian noise added to genome weights.
   */
  static void MutateWeightsUnbiased(Genome& genome, double mutateProb, double mutateSize)
  {
    for (int i = 0; i < genome.linkGenes.size(); ++i)
    {
      double p = mlpack::math::Random();
      if (p < mutateProb)
      {
        double weight = mlpack::math::RandNormal(0, mutateSize);
        genome.linkGenes[i].Weight(weight);
      }
    }
  }

  /**
   * Crossover two genomes' weights to generate two child genomes.
   *
   * NOTICE: child genomes need to set genome id based on its population's max id.
   *
   * @param momGenome The mother genome of two child genomes.
   * @param dadGenome The father genome of two child genomes.
   * @param child1Genome One child genome generated by crossover.
   * @param child2Genmoe Another child genome generated by crossover.
   */
  static void CrossoverWeights(Genome& momGenome, 
                               Genome& dadGenome, 
                               Genome& child1Genome, 
                               Genome& child2Genome)
  {
    child1Genome = momGenome;
    child2Genome = dadGenome;
    for (int i = 0; i < momGenome.linkGenes.size(); ++i)
    { // assume genome are the same structure.
      double t = mlpack::math::RandNormal();
      if (t > 0)
      {  // prob = 0.5
        child1Genome.linkGenes[i].Weight(momGenome.linkGenes[i].Weight());
        child2Genome.linkGenes[i].Weight(dadGenome.linkGenes[i].Weight());
      } else
      {
        child1Genome.linkGenes[i].Weight(dadGenome.linkGenes[i].Weight());
        child2Genome.linkGenes[i].Weight(momGenome.linkGenes[i].Weight());
      }
    }
  }

  /** 
   * Create initial species from seed genome and species size.
   */
  void InitSpecies()
  {
    species = Species(seedGenome, speciesSize);
  }

  /**
   * Reproduce the next species. Heart function for CNE.
   *
   * Select parents from previous generation based on genomes' fitness.
   * Apply search operators to parents and produce offspring which
   * form next generation.
   */
  void Reproduce()
  {
    // Sort species by fitness
    species.SortGenomes();

    // Select parents from elite genomes and crossover.
    int numElite = floor(elitePercentage * speciesSize);
    int numDrop = floor((speciesSize - numElite) / 2) * 2;  // Make sure even number.
    numElite = speciesSize - numDrop;
    for (int i = numElite; i < speciesSize - 1; ++i)
    {
      // Randomly select two parents from elite genomes.
      int idx1 = RandInt(0, numElite);
      int idx2 = RandInt(0, numElite);

      // Crossover to get two children genomes.
      CrossoverWeights(species.genomes[idx1], species.genomes[idx2],
                       species.genomes[i], species.genomes[i + 1]);
    }

    // Keep the best genome and mutate the rests.
    for (int i = 1; i < speciesSize; ++i)
    {
      MutateWeightsBiased(species.genomes[i], mutateRate, mutateSize);
    }
  }

  /**
   * Evolution of species.
   *
   * The whole process of CNE algorithm.
   * Iteratively evolve genomes for a number of generations to get a solution
   * genome for a specific task.
   */
  bool Evolve()
  {
    // Generate initial species at random.
    int generation = 0;
    InitSpecies();
    
    // Repeat
    while (generation < maxGeneration)
    {
    	// Evaluate all genomes in the species.
      for (int i = 0; i < species.SpeciesSize(); ++i)
      {
        double fitness = task.EvalFitness(species.genomes[i]);
        species.genomes[i].Fitness(fitness);
      }
      species.SetBestFitnessAndGenome();

    	// Output some information.
      printf("Generation: %zu\tBest fitness: %f\n", generation, species.BestFitness());
      if (task.Success())
      {
        printf("Task succeed in %zu iterations.\n", generation);
        return true;
      }

    	// Reproduce next generation.
      Reproduce();
      ++generation;
    }

    return false;
  }

 private:
  //! Task.
  TaskType task;

  //! Seed genome. It is used for init species.
  Genome seedGenome;

  //! Species to evolve.
  Species species;

  //! Species size.
  int speciesSize;

  //! Max number of generation to evolve.
  int maxGeneration;

  //! Mutation rate.
  double mutateRate;

  //! Mutate size. For normal distribution, it is mutate variance.
  double mutateSize;

  //! Elite percentage.
  double elitePercentage;

};

}  // namespace ne
}  // namespace mlpack

#endif  // MLPACK_METHODS_NE_CNE_HPP
